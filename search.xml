<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React</title>
      <link href="/2022/03/13/yuque/React/"/>
      <url>/2022/03/13/yuque/React/</url>
      
        <content type="html"><![CDATA[<p>change logReact 做了两件事：渲染 UI 和响应事件</p><p>性能提升React 虚拟 dom 的数据结构时间复杂度是 O(n^3)，链表的数据结构时间复杂度是 O(n)，所以 React16.0 之后使用链表的数据结构。因为 React16.0 之前的虚拟 dom 更新采用的是循环和递归，由于是线性的主线程会被一直占用，复杂的业务场景会出现卡顿。</p><p>Fiber利用浏览器空闲时间执行，不会长时间占用主线程</p><ul><li>requestIdleCallback 浏览器 API，可暂停当前任务利用浏览器空闲时间执行优先级更高的任务。</li></ul><p>将对比更新 dom 的操作碎片化碎片化的任务，可以根据需要被暂停</p><p>生命周期React 生命周期在 React16.0 版本加入了 Fiber 时发生了变化，您想听哪个？</p><ul><li>初始化：constructor 设置 props 和 state</li><li>挂载：componentWillMount –&gt; render –&gt; componentDidMount</li><li>更新：<ul><li>props 更新：componentWillReceiveProps –&gt; shouldComponentUpdate –&gt; componentWillUpdate –&gt; render –&gt; componentDidUpdate</li><li>state 更新：suouldComponentUpdate –&gt; componentWillUpdate –&gt; render –&gt; componentDidUpdate</li></ul></li><li>卸载：componentWillUnmount</li></ul><p>面试复盘，录音，值得录音的面试</p><p>React diff 算法策略</p><ul><li><p>针对树结构(tree diff)：对 UI 层的 DOM 节点跨层级的操作进行忽略。(数量少)</p><pre><code>  type变化，比如div变成了p  key变化</code></pre></li><li><p>针对组件结构( component diff)：拥有相同类的两个组件生成相似的树形结构，拥有不同类的两个组件会生成不同的属性结构。</p></li><li><p>针对元素结构(element-diff)：对于同一层级的一组节点，使用具有唯一性的 id 区分(key 属性)</p></li></ul><p>Fiber 算法</p><ul><li>通过 state 计算出新的 Fiber 节点</li><li>对比节点的 tag 和 key 确定节点操作(修改，删除，新增，移动)</li><li>effectTag 标记 Fiber 对象</li><li>收集所有标记的 Fiber 对象，形成 effectList</li><li>commit 阶段一次性处理所有变化的节点</li></ul><p>答题留有一定的空间，不要一次全部答完。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用方法之数据类型</title>
      <link href="/2022/03/10/yuque/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/03/10/yuque/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^\[Object (.+)\]$/</span>;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span></span><br><span class="line">    ? reg.test(<span class="built_in">Object</span>.prototype.toString(obj))[<span class="number">1</span>].toLowerCase()</span><br><span class="line">    : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto, Ctor;</span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="built_in">Object</span>.prototype.toString.call(obj) !== <span class="string">&quot;[object Object]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">  <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  Ctor =</span><br><span class="line">    <span class="built_in">Object</span>.prototype.hasOwnProperty.call(proto, <span class="string">&quot;constructor&quot;</span>) &amp;&amp;</span><br><span class="line">    proto.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> Ctor === <span class="string">&quot;function&quot;</span> &amp;&amp; Ctor === <span class="built_in">Object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span> || <span class="regexp">/^(object|function)$/</span>.test(<span class="keyword">typeof</span> obj)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">    keys = keys.concat(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line">  <span class="keyword">return</span> keys.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流实现原理</title>
      <link href="/2022/03/10/yuque/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/10/yuque/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>在用户频繁的进行某项操作时，只识别一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearTimer</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> timer !== <span class="literal">null</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;func必须是一个函数&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait !== <span class="string">&quot;number&quot;</span>) wait = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    timer = clearTimer(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      clearTimer(timer);</span><br><span class="line">      func.call(<span class="built_in">this</span>, ...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持自定义边界</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, flag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;func必须是一个函数&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&quot;boolean&quot;</span>) flag = wait;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait !== <span class="string">&quot;number&quot;</span>) wait = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> flag !== <span class="string">&quot;boolean&quot;</span>) flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> beforeRun = !timer &amp;&amp; flag;</span><br><span class="line">    timer = clearTimer(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timer = clearTimer(timer);</span><br><span class="line">      !flag &amp;&amp; func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">    beforeRun &amp;&amp; unc.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>在用户频繁的进行某项操作时，降低默认触发的频率</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearTimer</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> timer !== <span class="string">&quot;null&quot;</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> TypeErrot(<span class="string">&quot;func必须是一个函数&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait !== <span class="string">&quot;number&quot;</span>) wait = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>,</span><br><span class="line">    previousTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> remaining = wait - (now - previousTime);</span><br><span class="line">    <span class="comment">// 间隔超过或者等于300</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      previousTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      timer = clearTimer(timer);</span><br><span class="line">      func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有到达间隔时间，并且之前没有设置过定时器，如果之前设置过定时器就不管了</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        previousTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        timer = clearTimer(timer);</span><br><span class="line">        func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之数据类型</title>
      <link href="/2022/03/10/yuque/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/03/10/yuque/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-中的数据类型被分为两大类："><a href="#JS-中的数据类型被分为两大类：" class="headerlink" title="JS 中的数据类型被分为两大类："></a>JS 中的数据类型被分为两大类：</h2><div class="story post-story"><h4 id="原始值类型（值类型-基本数据类型）"><a href="#原始值类型（值类型-基本数据类型）" class="headerlink" title="原始值类型（值类型/基本数据类型）"></a>原始值类型（值类型/基本数据类型）</h4><ol><li>number 数字</li><li>string 字符串</li><li>boolean 布尔</li><li>null 空对象指针</li><li>undefined 未定义</li><li>symbol 唯一值</li><li>bigint 大数</li></ol><h4 id="对象类型（引用数据类型）"><a href="#对象类型（引用数据类型）" class="headerlink" title="对象类型（引用数据类型）"></a>对象类型（引用数据类型）</h4><ol><li>标准普通对象 <code>Object</code></li><li>标准特殊对象 <code>Array</code>、<code>RegExp</code>、<code>Date</code>、<code>Math</code>、<code>Error</code>……</li><li>非标准特殊对象 <code>Number</code>、<code>String</code>、<code>Boolean</code></li><li>可调用/执行对象（函数） <code>Function</code></li></ol></div><h2 id="数据类型检测的方式（4-种）"><a href="#数据类型检测的方式（4-种）" class="headerlink" title="数据类型检测的方式（4 种）"></a>数据类型检测的方式（4 种）</h2><div class="story post-story"><ol><li><code>typeof [value]</code> 返回值是字符串，字符串中包含所属的类型<ol><li>typeof 检测对象类型，除函数被识别’function’，其余都是’object’（不能细分对象）</li><li>基于 typeof 检测一个未被声明的变量，不会报错，结果是’undefined’</li><li><code>typeof null -&gt; &#39;object&#39;</code> typeof 检测 null 结果是’object’的原因是：如果是以’000’开始的二进制，则被识别为对象(null 存储的二进制都是 0，符合以’000’开始)；然后再去看对象是否实现了[[call]]，实现了则为函数(返回’function’)，没实现就是对象(返回’object’)</li></ol></li><li><code>Object.prototype.toString.call([value])</code></li><li><code>[value] instanceof [constructor]</code></li><li><code>[value].constructor</code></li></ol><p>其他检测固定类型的方法：<code>Array.isArray([value])</code>、<code>isNaN([value])</code> ……检测是否为对象：<code>val !== null &amp;&amp; /^(object|function)$/i.test(typeof val)</code>0.1 + 0.2 != 0.3 计算机是二进制形式存储数据的，十进制浮点数在转换为二进制时，由于计算机存储位数限制，有可能出现精度丢失。运算保证精度，实现思路：把小数变成整数(乘以系数)运算，运算后的结果再除以系数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> coefficent = <span class="function"><span class="keyword">function</span> <span class="title">coefficent</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num = <span class="built_in">String</span>(num);</span><br><span class="line">  <span class="keyword">const</span> [, char = <span class="string">&quot;&quot;</span>] = num.split(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">    len = char.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">10</span>, len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  n = <span class="built_in">Number</span>(n);</span><br><span class="line">  m = <span class="built_in">Number</span>(m);</span><br><span class="line">  <span class="keyword">let</span> coeffic = <span class="built_in">Math</span>.max(coefficient(n), coefficent(m));</span><br><span class="line">  <span class="keyword">return</span> (n * coeffic + m * coeffic) / coeffic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><div class="story post-story"><p>一般将其他数据类型转换为<code>Number</code>、<code>String</code>、<code>Boolean</code></p><h4 id="把其他类型值转换为Number"><a href="#把其他类型值转换为Number" class="headerlink" title="把其他类型值转换为Number"></a>把其他类型值转换为<code>Number</code></h4><ol><li><code>Number([value])</code></li><li><code>parseInt([val],[radix])</code>、<code>parseFloat([val])</code></li></ol><h4 id="把其他类型值转换为String"><a href="#把其他类型值转换为String" class="headerlink" title="把其他类型值转换为String"></a>把其他类型值转换为<code>String</code></h4><ol><li><code>[value].toString()</code></li><li><code>String([value])</code></li></ol><h4 id="把其他类型值转换为Boolean"><a href="#把其他类型值转换为Boolean" class="headerlink" title="把其他类型值转换为Boolean"></a>把其他类型值转换为<code>Boolean</code></h4><p>转换规则：除了“0/NaN/空字符串/null/undefined”五个值是 false，其余的都是 true出现情况：</p><ol><li><code>Boolean([val])</code>或者<code>!/!!</code></li><li><code>条件判断</code></li></ol></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络通信原理</title>
      <link href="/2021/07/25/yuque/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2021/07/25/yuque/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>网络通信中有 tcp/ip、ftp、arp、http 等这些协议或模型，他们本质上解决的问题其实是主机与主机之间的网络通信的问题。</p><h2 id="主机通信的必要条件"><a href="#主机通信的必要条件" class="headerlink" title="主机通信的必要条件"></a>主机通信的必要条件</h2><div class="story post-story"><ol><li>主机之间需要有传输介质例如网线、光纤、蓝牙、Wifi 等。</li><li>主机上必须要有网卡设备主要完成信号的调制和解调。无论我们使用哪种编程语言，计算机都不能直接识别，因为在计算机的世界中，一切都是以二机制的形式存在。A 主机将封装好的二进制数据，通过网卡转换为电信号（调制），再通过传输介质发送给 B 主机；B 主机接收到信号后，通过网卡将电信号转换为二进制（解调），再由 B 主机自己的通信体系对数据进行拆包、解包，最终在我们的应用程序里获取到 A 主机发送过来的数据。</li><li>主机之间需要协商网络速率A、B 主机由于网卡的网络速率不同，所以在通信之间需要协商网络速率，让他们保持一致。</li></ol></div><h2 id="网络通讯方式"><a href="#网络通讯方式" class="headerlink" title="网络通讯方式"></a>网络通讯方式</h2><div class="story post-story"><ol><li>交换机通信</li><li>路由器通信</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1429353/1627260256341-6939a46a-da3f-4e29-9414-0e07d4e12319.png#clientId=u06388d18-a111-4&from=paste&height=1366&id=u0e464cc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2732&originWidth=2048&originalType=binary%E2%88%B6=1&size=369092&status=done&style=stroke&taskId=ufcd07110-e9be-4895-b5e3-fba7584ccf8&width=1024" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/1429353/1627260256341-6939a46a-da3f-4e29-9414-0e07d4e12319.png#clientId=u06388d18-a111-4&from=paste&height=1366&id=u0e464cc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2732&originWidth=2048&originalType=binary%E2%88%B6=1&size=369092&status=done&style=stroke&taskId=ufcd07110-e9be-4895-b5e3-fba7584ccf8&width=1024" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p></div><h2 id="网络层次模型"><a href="#网络层次模型" class="headerlink" title="网络层次模型"></a>网络层次模型</h2><div class="story post-story"><p>为了兼容不同厂商生产的不同品牌的设备，需要一个组织对它们制定一个模型，这个模型就是七层网络模型 OSI。这个模型分别有物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ol><li>物理层：各种物理设备和标准</li><li>数据链路层：确定目标主机</li><li>网络层：确定目标网络</li><li>传输层：控制数据传输可靠性</li><li>会话层：控制网络连接建立与终止</li><li>表示层：数据加密、转换、压缩</li><li>应用层：用户与网络的接口</li></ol><p>数据从 A 主机发送到 B 主机时，先根据层次从高到低的进行封装，到了 B 主机后，会根据层次从低到高一层一层的解包数据，最后在应用层中拿到 A 主机发送过来的原始数据。tcp/ip 模型：</p><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>应用层</li></ol></div><h2 id="数据封装与解封装"><a href="#数据封装与解封装" class="headerlink" title="数据封装与解封装"></a>数据封装与解封装</h2><div class="story post-story"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>知识汇总</title>
      <link href="/2021/06/29/yuque/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
      <url>/2021/06/29/yuque/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-的模块化方案"><a href="#JS-的模块化方案" class="headerlink" title="JS 的模块化方案"></a>JS 的模块化方案</h2><div class="story post-story"><p>在浏览器端，有 AMD，通过 require.js 库实现，具有异步按需加载和兼容性好的特点。有 ES Module，它是一种新特性，通过 import、export 实现导入和导出，它的兼容性不太好。在 NodeJS 端，有 CommonJS 方案，它是同步加载的</p></div><h2 id="JS-小数点计算为什么会丢失精度"><a href="#JS-小数点计算为什么会丢失精度" class="headerlink" title="JS 小数点计算为什么会丢失精度"></a>JS 小数点计算为什么会丢失精度</h2><div class="story post-story"><h2 id="JS-如何精确浮点计算"><a href="#JS-如何精确浮点计算" class="headerlink" title="JS 如何精确浮点计算"></a>JS 如何精确浮点计算</h2><p>例如：如何实现 0.1+0.2=0.3</p></div><h2 id="JS-如何进行大数计算"><a href="#JS-如何进行大数计算" class="headerlink" title="JS 如何进行大数计算"></a>JS 如何进行大数计算</h2><div class="story post-story"><p>Int 类型超出最大安全数的计算</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack核心原理</title>
      <link href="/2021/06/27/yuque/Webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2021/06/27/yuque/Webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>对于<code>Webpack</code>来说，它本质上就是一个模块打包器，正是由于有了<code>Loader</code>和<code>Plugin</code>，才让<code>Webpack</code>有了其他各种各样的功能。</p><h2 id="Webpack-打包后的文件"><a href="#Webpack-打包后的文件" class="headerlink" title="Webpack 打包后的文件"></a>Webpack 打包后的文件</h2><div class="story post-story"><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo &amp;&amp; cd demo</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack webpack-cli html-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="comment">// devtool: &#x27;none&#x27;, // webpack5中不用配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;built.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="运行打包"><a href="#运行打包" class="headerlink" title="运行打包"></a>运行打包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn webpack</span><br></pre></td></tr></table></figure><p><code>Webpack4</code>打包结果：在<code>Webpack4</code>中，<code>Webpack</code>打包后的文件只是一个<code>IIFE</code>，这个函数的参数是一个“模块定义”的对象。键名是当前被加载文件的文件路径和文件名拼接而来的，键值是一个函数(和<code>NodeJS</code>中的模块加载有些类似)，这个函数会在将来的某个时机被调用，同时会接收到一定的参数，利用这些参数就可以实现模块的加载操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(</span><br><span class="line">      <span class="string">&quot;const test = __webpack_require__(/*! ./test */ \&quot;./src/test.js\&quot;)\nconsole.log(&#x27;hello wlord!&#x27;)\nconsole.log(test)\n\nmodule.exports = &#x27;Index Export&#x27;\n\n//# sourceURL=webpack:///./src/index.js?&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;./src/test.js&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(</span><br><span class="line">      <span class="string">&quot;console.log(11111)\n\n\nmodule.exports = &#x27;Test Exports&#x27;\n\n//# sourceURL=webpack:///./src/test.js?&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Webpack5</code>打包结果：而在<code>Webpack5</code>中，模块定义对象被放到函数内部了，函数参数是空的，代码相比<code>Webpack4</code>更少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">    <span class="string">&quot;./src/index.js&quot;</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      __unused_webpack_exports,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_require__</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(</span><br><span class="line">        <span class="string">&quot;const test = __webpack_require__(/*! ./test */ \&quot;./src/test.js\&quot;)\nconsole.log(&#x27;hello wlord!&#x27;)\nconsole.log(test)\n\nmodule.exports = &#x27;Index Export&#x27;\n\n//# sourceURL=webpack://01/./src/index.js?&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./src/test.js&quot;</span>: <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(</span><br><span class="line">        <span class="string">&quot;console.log(11111)\n\n\nmodule.exports = &#x27;Test Exports&#x27;\n\n//# sourceURL=webpack://01/./src/test.js?&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">    <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">      <span class="comment">// no module.id needed</span></span><br><span class="line">      <span class="comment">// no module.loaded needed</span></span><br><span class="line">      <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// startup</span></span><br><span class="line">  <span class="comment">// Load entry module and return exports</span></span><br><span class="line">  <span class="comment">// This entry module is referenced by other modules so it can&#x27;t be inlined</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_exports__ = __webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们可以看到打包后是一个<code>IIFE</code>(自执行函数)，而这是为了产生一个闭包。</p></div><h2 id="单文件打包执行流程解析"><a href="#单文件打包执行流程解析" class="headerlink" title="单文件打包执行流程解析"></a>单文件打包执行流程解析</h2><div class="story post-story"><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1624954520614-a2d77776-1d40-42f2-8a94-fe74ab2a5ce0.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1624954520614-a2d77776-1d40-42f2-8a94-fe74ab2a5ce0.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="Webpack-打包主流程分析"><a href="#Webpack-打包主流程分析" class="headerlink" title="Webpack 打包主流程分析"></a>Webpack 打包主流程分析</h2><div class="story post-story"><p>编写调试代码，新建<code>debug.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(options);</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    stats.toJson(&#123;</span><br><span class="line">      <span class="attr">entries</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">assets</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打开<code>VS Code</code>调试模式，将断点定到第四行，接下来就开始分析它的主要流程：<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1625118006345-c39ec915-6b29-46c3-90dd-0e76dc54b3ad.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1625118006345-c39ec915-6b29-46c3-90dd-0e76dc54b3ad.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/2021/06/07/yuque/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
      <url>/2021/06/07/yuque/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在没有 Node 的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是 Node，如果说 Ajax 给前端能力范围带来了一次革命，那么 Node 也同样给前端工程化带来一次伟大的革命！</p><h2 id="工程化概述"><a href="#工程化概述" class="headerlink" title="工程化概述"></a>工程化概述</h2><div class="story post-story"><p>前端工程化是指遵循一定标准和规范，通过工具去提升效率，他是一种降低成本的手段。</p><p>当下前端功能不断提高，业务复杂日益复杂。因此，在我们没有工程化之前，我们不得不面对一些问题：</p><ul><li>想要使用 ES6+新特性，但是兼容有问题</li><li>想要使用 Less/Sass/PostCSS 增强 CSS 的编程性，但是运行环境不能直接支持。</li><li>想要使用模块化的方式提高项目的可维护性，但是运行环境不能直接支持。</li><li>部署上线前需要<strong>手动</strong>压缩代码及资源文件，部署过程需要<strong>手动</strong>上传代码到服务器。</li><li>多人协作开发，无法硬性统一大家的代码风格，从仓库中 pull 的代码质量无法保证。</li><li>部分功能开发时需要等待后端服务接口提前完成</li></ul><h3 id="工程化主要解决的问题"><a href="#工程化主要解决的问题" class="headerlink" title="工程化主要解决的问题"></a>工程化主要解决的问题</h3><ul><li>传统语言或语法的弊端</li><li>无法使用模块化/组件化</li><li>重复的机械式工作</li><li>代码风格统一、质量保证</li><li>依赖后端服务接口支持</li><li>整体依赖后端项目</li></ul><h3 id="一个项目过程中工程化的表现"><a href="#一个项目过程中工程化的表现" class="headerlink" title="一个项目过程中工程化的表现"></a>一个项目过程中工程化的表现</h3><p>一切以提高效率、降低成本、质量保证为目的的手段都属于工程化。一切重复的工作都应该被自动化，例如：创建项目一&gt;编码一&gt;预览/测试一&gt;提交一&gt;部署</p><h3 id="工程化不等工具"><a href="#工程化不等工具" class="headerlink" title="工程化不等工具"></a>工程化不等工具</h3><p>工具不是工程化的核心，工程化的核心是对项目整体的规划、架构。而工具只是帮助我们去实现和落地的一种手段，例如文件的组织结构，源代码的开发范式(语法、规范、标准)一些成熟的工程化集成有：create-react-app、vue-cli、angular-cli、gatsby-cli</p><p>工程化的一切都应该归功于 Node.js，它让整个前端进行了一次工业革命，可以说，没有 Node.js 就没有现在的前端。因为几乎所有的工程化工具都是用 Node.js 来编写的。但是，面对各种技术工具和新鲜名词，我们不必盲目追求，因为所有的工具都应该是为了解决问题而存在的。</p><p>从一个项目的开发过程开始，我们来了解前端工程化具体实现：</p></div><h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><div class="story post-story"><p>自动帮助我们创建项目基础结构，并且提供项目规范和约定。看似很普通的需求，背后却隐藏了一定的哲学。因为除了创建文件，它更重要的是还给开发者<strong>提供了一套规范和约定</strong>。比如在开发类似项目时，他们都有以下特征：</p><ul><li>相同的组织结构</li><li>相同的开发范式</li><li>相同的模块依赖</li><li>相同的工具配置</li><li>相同的基础代码</li></ul><p>这导致我们在创建新项目时，有大量的重复工作要做，所以脚手架工具就是用来解决这一类问题的。我们可以通过脚手架快速搭建项目基础骨架，然后基于这个项目骨架来开发项目。由于前端技术选型比较多样，另外也没有一个统一的标准，所以前端方向的脚手架不会集成在某个 IDE 中，它都是以一个独立的工具存在。</p><h3 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h3><p>是一个用于创建现代化 web 应用的脚手架工具。不同于<code>vue-cli</code>这样的工具，它更像一个脚手架的运行平台，我们可以通过<code>Yeoman</code>搭配不同的<code>generator</code>去创建任何类型的项目。也就是说，我们可以创建自己的<code>generator</code>，从而定制属于我们自己的前端的前端脚手架。</p><p>但是它的优点也是它的缺点，在专注于基于框架开发项目的人的眼中，它过于通用化，不够专注。所以他们更愿意使用<code>vue-cli</code>这种专注于某个框架的脚手架。</p><h3 id="Yeoman-基本使用"><a href="#Yeoman-基本使用" class="headerlink" title="Yeoman 基本使用"></a>Yeoman 基本使用</h3><h4 id="安装Yeoman"><a href="#安装Yeoman" class="headerlink" title="安装Yeoman"></a>安装<code>Yeoman</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add yo</span><br></pre></td></tr></table></figure><p>Yeoman 是搭配特定的 generator 才能使用的，所以还需要安装 generator</p><h4 id="安装对应的generator"><a href="#安装对应的generator" class="headerlink" title="安装对应的generator"></a>安装对应的<code>generator</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add generator-node</span><br></pre></td></tr></table></figure><h4 id="通过yo运行generator"><a href="#通过yo运行generator" class="headerlink" title="通过yo运行generator"></a>通过<code>yo</code>运行<code>generator</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo node</span><br></pre></td></tr></table></figure><p>然后根据提示输入项目的相关信息，完成后会自动生成项目。</p><h3 id="Sub-Generator"><a href="#Sub-Generator" class="headerlink" title="Sub Generator"></a>Sub Generator</h3><p>有时候我们并不想安转完整的项目，仅仅只是想在原有的项目基础之上去增加部分文件。</p><p>例如我们想运行<code>generator-node</code>子集下面的 cli 命令，创建一个 cli 应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo node:cli</span><br></pre></td></tr></table></figure></div><h2 id="自定义-Generator"><a href="#自定义-Generator" class="headerlink" title="自定义 Generator"></a>自定义 Generator</h2><div class="story post-story"><p>虽然市面上也有很多<code>generator</code>，但是他们并不包含我们自己项目的一些公用的依赖或者业务代码。所以，我们仍然有必要自己编写一个专属的<code>generator</code>。</p><h3 id="创建-Generator-模块"><a href="#创建-Generator-模块" class="headerlink" title="创建 Generator 模块"></a>创建 Generator 模块</h3><p>generator 本质上就是一个 npm 模块。不同于其他模块，yeoman 的 ganerator 模块名称必须是 generator-<name>的格式命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir generator</span><br><span class="line">cd generator</span><br><span class="line">yarn init</span><br><span class="line">yarn add yeoman-generator</span><br></pre></td></tr></table></figure><p>上述命令完成后，接下来我们打开项目，然后在项目根目录创建<code>generators/app/index.js</code>文件这个文件会作为<code>Generator</code>的核心入口它需要导出一个继承自<code>Yeoman Generator</code>的类Yeoman Generator 在工作时会自动调用我们在此类中定义的一些生命周期方法我们在这些方法中可以调用父类提供的一些工具方法实现一些功能，例如文件写入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Genetator = <span class="built_in">require</span>(<span class="string">&quot;yeoman-generator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="built_in">this</span>.fs.write(<span class="built_in">this</span>.destinationPath(<span class="string">&quot;temp.txt&quot;</span>), <span class="built_in">Math</span>.random().toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们把这个模块，挂载到本地全局上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure><p>接着就可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo simple  // simple 是上面创建项目定义的项目名称</span><br></pre></td></tr></table></figure><h3 id="根据模板创建文件"><a href="#根据模板创建文件" class="headerlink" title="根据模板创建文件"></a>根据模板创建文件</h3><p>很多时候我们需要自动去创建的文件有很多，而且文件的内容也相对复杂，在这样的情况下，我们可以用模板来创建文件，因为这样更加便捷。在 app 目录下创建<code>templates/foo.txt</code>文件，模板文件支持 ejs 模板引擎的模板语法，比如我们可以使用模板标记<code>&lt;%= title %&gt;</code>动态输出内容，也可以做一些判断、循环的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Genetator = <span class="built_in">require</span>(<span class="string">&quot;yeoman-generator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="built_in">this</span>.templatePath(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = &#123; <span class="attr">title</span>: <span class="string">&quot;Hello xsl~&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tmpl, output, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对于手动创建每一个文件，通过模板创建大大提升了效率，特别是文件比较多比较复杂的情况下。</p><h3 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a>接收用户输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="title">prompting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Yeoman 在询问用户环节会自动调用此方法</span></span><br><span class="line">   <span class="comment">//  在此方法中可以调用父类的prompt() 方法发出对用户的命令行询问</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.prompt([&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;input&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">      <span class="attr">message</span>:<span class="string">&quot;Your project name&quot;</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="built_in">this</span>.appname, <span class="comment">// appname为项目生成目录名称</span></span><br><span class="line">   &#125;]).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.answers = answers</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">writing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="built_in">this</span>.fs.copyTpl(tmpl, output, <span class="built_in">this</span>.answers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Plop"><a href="#Plop" class="headerlink" title="Plop"></a>Plop</h2><div class="story post-story"><p>一个小而美的脚手架工具。主要创建项目中特定类型文件的小工具，它类似于 Yeoman 中的 Sub Generator。不过它一般不会独立运行，它用来集成在项目当中，去创建同类型的项目文件。在一个项目当中使用 Plop，需要以下几个步骤：</p><ol><li>将 Plop 模块作为项目开发依赖安装</li><li>在项目根目录下创建一个 plopfile.js 文件</li><li>在 plopfile.js 文件中定义脚手架任务</li><li>编写用于生成特定类型文件的模板</li><li>通过 Plop 提供的 CLI 运行脚手架任务</li></ol></div><h2 id="脚手架工作原理"><a href="#脚手架工作原理" class="headerlink" title="脚手架工作原理"></a>脚手架工作原理</h2><div class="story post-story"><p>脚手架启动后，会先询问用户一些问题，然后根据这些问题的答案，结合一些模版文件去自动生成项目结构。</p></div><h2 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h2><div class="story post-story"><blockquote><p>一切重复工作本应该自动化。自动化：让机器代替手工；构建：将 A 转换为 B。</p></blockquote><p>将开发环境的源代码自动化构建为生产环境可运行的代码。一般我们把这个转换的过程称为自动化构建工作流，它的作用是尽可能脱离运行环境兼容带来的问题，在开发环境阶段使用一些提高效率的语法、规范和标准。</p><p>自动化构建将那些不被支持的『特性』，转换为能够直接运行的代码，我们在开发过程中就可以尽情使用提高效率的代码了。</p></div><h2 id="NPM-Scripts-自动构建工作流"><a href="#NPM-Scripts-自动构建工作流" class="headerlink" title="NPM Scripts 自动构建工作流"></a>NPM Scripts 自动构建工作流</h2><div class="story post-story"><p>可以在 package.json 中定义一些与项目相关的构建命令，它是实现自动化构建工作流的最简方式。在启动 serve 之前构建项目：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;preserve&quot;</span>: <span class="string">&quot;yarn build&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync .&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时执行多个任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add npm-run-all</span><br></pre></td></tr></table></figure><p>然后在 scripts 中添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;build&quot;</span>: <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync .&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;run-p build serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听文件变化并重新编译，监听文件变化并自动热更新：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;build&quot;</span>: <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync . --files \“css/*.css\&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;run-p build serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="常见的自动化构建工具"><a href="#常见的自动化构建工具" class="headerlink" title="常见的自动化构建工具"></a>常见的自动化构建工具</h2><div class="story post-story"><blockquote><p>严格意义上来说，Webpack 属于模块化打包工具，所以不归类在此处</p></blockquote><h3 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h3><p>最早的前端构建系统，生态完善。因为它基于临时文件编译的，它在构建过程会对磁盘进行读写操作，所以构建速度会比较慢。例如它在工作时，上个插件将构建结果存储到一个临时文件中，下一个插件又会基于这个临时文件读取内容。如果处理的环节越多，那么对磁盘读写的次数也就会越多，也会更加耗时。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>对于文件读写都是在内存中完成的，所以相对于磁盘读写操作，它的速度更快。同时他也支持多个任务同时执行。它的使用方式比 Grunt 更简单，生态也很完善，是目前前端构建最流行的系统。</p><h3 id="FIS"><a href="#FIS" class="headerlink" title="FIS"></a>FIS</h3><p>百度前端开源内部的构建系统，它把我们在项目中常见的需求都集成在内部了。例如资源加载、模块化开发、代码部署、性能优化。</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS性能优化</title>
      <link href="/2021/05/26/yuque/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2021/05/26/yuque/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><div class="story post-story"><p>内存为什么需要管理？如果我们在写代码的过程中，不够了解内存的管理机制，写出不容易被察觉的内存问题性代码，就会给程序带来意想不到的 BUG。</p><ul><li>内存：由可读写单元组成，表示一片可操作空间</li><li>管理：人为的去操作一片空间的申请、使用和释放。</li><li>内存管理: 开发者主动申请空间、使用空间、释放空间。</li><li>管理流程:申请一使用一释放</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请空间（由于JavaScript没有提供相关api，我们只能通过JS执行引擎，遇到变量定义的时候，自动去申请空间）</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 使用空间</span></span><br><span class="line">obj.name = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><h2 id="JS-中的垃圾回收"><a href="#JS-中的垃圾回收" class="headerlink" title="JS 中的垃圾回收"></a>JS 中的垃圾回收</h2><div class="story post-story"><p>对象在什么情况下会被视为垃圾？</p><ul><li>JS 中的垃圾回收是自动的</li><li>当对象不再被引用时，被视为垃圾</li><li>对象不能从根(全局执行上下文)上访问到时是垃圾</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> ali = obj;</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// &#123;name: 11&#125; 被ali引用，不是一个垃圾</span></span><br></pre></td></tr></table></figure></div><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><div class="story post-story"><p>GC：垃圾回收机制；它可以找到内存中的垃圾、并释放和回收空间。那么什么样的东西可以被当作垃圾呢？</p><ul><li>程序中不再使用的对象</li><li>程序中能再访问的对象</li></ul><p>GC 算法：算法就是工作时查找和回收所遵循的规则。常见的 GC 算法有：</p><ul><li><p>引用计数</p><p>判断对象的引用来决定是不是垃圾</p></li><li><p>标记清除</p><p>给活动对象添加标记，来判断他是不是垃圾</p></li><li><p>标记整理</p><p>类似标记清除</p></li><li><p>分代回收</p></li></ul></div><h2 id="引用计数算法实现原理"><a href="#引用计数算法实现原理" class="headerlink" title="引用计数算法实现原理"></a>引用计数算法实现原理</h2><div class="story post-story"><p>核心思想：内部通过一个计数器来维护当前对象的引用数，从而判断当前对象的引用数是否为 0，来决定它是不是一个垃圾对象。当这个对象的引用为 0 的时候，GC 就开始工作，将其所在的对象空间进行回收和释放，然后再使用。</p><p>当某个对象的引用关系发生改变时，引用计数器就会主动去修改当前对象所对应的引用数值。当引用为 0 时，GC 就会将其所在的空间回收。引用关系发生改变：假设我们的代码里面有一个对象空间，如果有一个变量名指向它，这时就把对象空间的引用加 1，如果又有一个变量指向它，那就再加 1；如果是减少的情况，例如取消引用，那就减 1。为 0 时，GC 就会立即将其回收。</p><h3 id="引用计数算法的优缺点"><a href="#引用计数算法的优缺点" class="headerlink" title="引用计数算法的优缺点"></a>引用计数算法的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>发现垃圾时立即回收</li></ul><p>如果引用为 0 就会立即进行回收、释放</p><ul><li>最大限度减少程序暂停</li></ul><p>由于引用计数算法会时刻监控着那么引用为 0 的对象，如果在栈满时，会以最快的速度释放空间。程序就不会因为栈满而停止运行了。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法回收循环引用的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 在全局上下文中，没有使用到这两个对象了，他们已经可以被回收了</span></span><br><span class="line">  <span class="comment">// 但是由于这两个对象相互循环引用，在使用引用计数算法时，他仍然还是有引用并且不为0，因此GC无法对其回收。</span></span><br><span class="line">  obj1.name = obj2;</span><br><span class="line">  obj2.name = obj1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 当函数执行完毕，会释放里面的空间</span></span><br></pre></td></tr></table></figure><ul><li>时间开销大</li></ul><p>需要时刻监控对象是否修改，如果有很多的对象需要修改，需要的时间就会更久一点</p></div><h2 id="标记清除算法实现原理"><a href="#标记清除算法实现原理" class="headerlink" title="标记清除算法实现原理"></a>标记清除算法实现原理</h2><div class="story post-story"><blockquote><p>标记清除算法相较于引用计数算法，他能解决更多的问题，因此它在 V8 中被大量使用。</p></blockquote><p>核心思想：将整个垃圾回收操作分为两个阶段；第一个阶段，遍历所有对象，然后找到这些活动的对象(可达对象)并进行标记，如果不可达就不会标记并且会在第二个阶段被回收掉。第二个阶段，再次遍历所有对象，然后把那些没有被标记的对象进行清除操作，并把第一阶段中设置的标记抹掉，便于下次 GC 还能够正常工作。最后就可以把相应的垃圾进行回收，然后再把回收的空间交给空闲链表进行维护，下次程序执行就可以向空闲链表申请空间进行使用。</p><h3 id="标记清除算法的优缺点"><a href="#标记清除算法的优缺点" class="headerlink" title="标记清除算法的优缺点"></a>标记清除算法的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>解决了引用计数算法中对象循环引用无法回收的问题</li></ul><p>标记清除算法会递归遍历所有对象，然后将可达对象进行标记；如果两个对象相互循环引用，一旦对象不可达，它始终也能清除标记，GC 也能正常回收。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>不会立即回收对象</p><pre><code> 当遍历对象的时候，即使发现了不可达对象，它也不会立即去进行回收，只有等到最后才会去回收，而且其实这个时候程序是停止工作的。</code></pre></li><li><p>空间碎片化</p></li></ul><p>回收后的空闲地址有可能不是连续的，使用空间时很容易造成空间上的浪费。</p></div><h2 id="标记整理算法实现原理"><a href="#标记整理算法实现原理" class="headerlink" title="标记整理算法实现原理"></a>标记整理算法实现原理</h2><div class="story post-story"><blockquote><p>和标记清除算法一样，标记整理算法在 V8 也被频繁使用</p></blockquote><p>标记整理算法其实可以看做是标记清除算法的增强版，因为它们在第一个阶段是相同的，都会先遍历所有对象，然后对当前活动对象(可达对象)进行标记操作。</p><p>但是不同的是，标记清除算法是直接对没有标记的进行清除，而标记整理算法会在清除之前进行整理操作，移动对象的位置，并让他们在地址上产生连续。</p><p>这样连续的可用空间，能够最大化的让程序使用到内存释放出来的空闲空间，避免空间碎片化造成空间浪费。</p><h3 id="标记整理算法优缺点"><a href="#标记整理算法优缺点" class="headerlink" title="标记整理算法优缺点"></a>标记整理算法优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>减少碎片化空间</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>不会立即回收垃圾对象</p></div><h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><div class="story post-story"><p>V8 是一款主流的 JavaScript 执行引擎。V8 之所以有优越的性能，是因为它优秀的内存管理机制以及 V8 采用的即时编译机制。V8 内存的上限设定：64 位 1.5G 32 位 800M</p><h3 id="V8-垃圾回收策略"><a href="#V8-垃圾回收策略" class="headerlink" title="V8 垃圾回收策略"></a>V8 垃圾回收策略</h3><p>采用分代回收的思想，把内存空间按照一定的规则分为两类，<strong>新生代</strong>存储区和<strong>老生代</strong>存储区。针对不同代采用最高效的 GC 算法，从而对不同的对象进行回收操作。<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1622989590392-e6acf015-001d-47af-a104-21ed4ab67419.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1622989590392-e6acf015-001d-47af-a104-21ed4ab67419.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="V8-中常用的-GC-算法"><a href="#V8-中常用的-GC-算法" class="headerlink" title="V8 中常用的 GC 算法"></a>V8 中常用的 GC 算法</h3><ul><li>分代回收</li><li>空间复制</li><li>标记清除</li><li>标记整理</li><li>标记增量</li></ul><h3 id="V8-如何回收新生代对象"><a href="#V8-如何回收新生代对象" class="headerlink" title="V8 如何回收新生代对象"></a>V8 如何回收新生代对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1429353/1622954154226-5f921e40-e7a4-4868-9956-afae918bd89f.png#crop=0&crop=0&crop=1&crop=1&height=89&id=ubca4cc3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=831&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12542&status=done&style=shadow&title=&width=749" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/1429353/1622954154226-5f921e40-e7a4-4868-9956-afae918bd89f.png#crop=0&crop=0&crop=1&crop=1&height=89&id=ubca4cc3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=831&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12542&status=done&style=shadow&title=&width=749" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png">如图所示，V8 内部将空间分为了两部分，左侧(From To)小空间专门用于存储新生代对象，在 64 位操作系统中，它的大小为 32M，32 位系统中，它的大小是 16M；<strong>新生代指的是存活时间较短的对象</strong>。比如局部作用域(函数)中定义的变量，当函数执行完，函数出栈时函数中的变量就会被回收。那么，V8 是如何完成新生代对象回收的呢？</p><h4 id="新生代对象回收实现"><a href="#新生代对象回收实现" class="headerlink" title="新生代对象回收实现"></a>新生代对象回收实现</h4><p>回收过程采用复制算法+标记整理算法。首先它会将左侧的小空间也会分成两个部分(From、To)，而且这两个空间是相同大小的。其中我们将 From 称为使用空间，将 To 称为空闲空间。当程序要申请空间时，它会将新申请的活动对象存储于 From 空间，这个时候 To 空间是空闲的没有使用。当 From 使用到一定程度后就会触发 GC 操作，它将 From 空间中的活动对象进行标记，然后对空间整理为连续的，便于后续不会产生碎片化空间，这些操作完成后再将这些活动对象拷贝至 To 空间，From 空间里的对象就有一份备份，这就意味着可以对它进行回收，因为活动对象都在 To 空间里有所体现，所以会直接把 From 空间中的对象进行回收。</p><h4 id="回收细节"><a href="#回收细节" class="headerlink" title="回收细节"></a>回收细节</h4><p>如果我们在拷贝时，发现某一个变量对象所指向的空间，在我们老生代存储区也存在，这个时候就会发生<strong>晋升</strong>的现象。这里的晋升指的就是将新生代的对象移动至老生代中进行存储。判断是否晋升的条件有以下几个：</p><ul><li>经过一轮 GC 还存活的新生代对象需要晋升</li></ul><p>如果新生代中的对象经过一轮 GC 还存活的，我们就可以把它拷贝至老生代存储区进行存储操作。</p><ul><li>在拷贝的过程中，发现 To 空间的使用率超过 25%，也需要把这次的活动对象都移动至老生代存储区中进行存储。</li></ul><p>To 空间的使用率如果超过了限制，那么新进来的对象空间好像就存放不进去了，所以在这里有 25%的限制操作。</p><h3 id="V8-如何回收老生代对象"><a href="#V8-如何回收老生代对象" class="headerlink" title="V8 如何回收老生代对象"></a>V8 如何回收老生代对象</h3><p>如上图所示，老生代对象存放在右侧老生代区域。同样针对于老生代存储区也有大小限制，64 位的操作系统为 1.4G，32 位的操作系统为 700M。老生代对象就是指存活时间较长的对象，例如在全局上下文中存放的变量、闭包中存放的变量数据等。</p><h3 id="老生代对象回收实现"><a href="#老生代对象回收实现" class="headerlink" title="老生代对象回收实现"></a>老生代对象回收实现</h3><p>主要采用标记清除、标记整理、增量标记算法。其实首先使用的是标记清除算法完成垃圾空间的释放和回收，因为它执行的速度是比较快的。当把新生代区域中的内容往老生代存储区域中移动(也就是晋升)的时候，而且老生代的空间又不足以存放所移过来的这些对象，就会触发标记整理，把之前的碎片空间进行整理回收，让我们有更多的空间进行使用。最后会采用增量标记算法对回收效率进行提升。</p><h4 id="新老代细节对比"><a href="#新老代细节对比" class="headerlink" title="新老代细节对比"></a>新老代细节对比</h4><p>新生代区域垃圾回收使用空间换时间，因为他采用的是复制算法，这也就意味着每时每刻都会有空闲的空间存在。但是新生代存储区本身的存储就很小，那么优化出来的空间就更小，所以相对于它带来的时间效率上的提升是微不足道的。老生代区域垃圾回收不适合复制算法，因为他的空间很大，复制很多对象时也会非常消耗时间。</p></div><h2 id="标记增量如何优化垃圾回收"><a href="#标记增量如何优化垃圾回收" class="headerlink" title="标记增量如何优化垃圾回收"></a>标记增量如何优化垃圾回收</h2><div class="story post-story"><p>当垃圾回收机制工作的时候，是会阻塞我们的程序运行的，程序执行完成后，会暂停下来进行回收操作。标记增量其实就是将一整段的垃圾回收操作拆分成多个小步骤组合着去完成，从而替换掉我们之前一口气去做完的垃圾回收操作。这样做的好处是可以让程序和垃圾回收机制交替着去执行，而不是执行程序时不能进行垃圾回收，垃圾回收时不能执行程序，这样带来的时间消耗也是非常合理的。而且 GC 执行的效率非常快，给用户带来的体验也更加友好了。</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES新特性与TypeScript</title>
      <link href="/2021/05/26/yuque/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript/"/>
      <url>/2021/05/26/yuque/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript/</url>
      
        <content type="html"><![CDATA[<p>我们常说 ECMAScript 是一种脚本语言，通常我们把 ECMAScript 看做是一种标准化规范，而实际上是 JavaScript 是 ECMAScript 的扩展语言。</p><p>在浏览器环境中，JavaScript 等于 ECMAScript 加上 WEB API(DOM+BOM)</p><p>在 NodeJs 环境中，JavaScript 等于 ECMAScript 加上 Node APIS(fs、net、etc.)</p><p>所以，JavaScript 语言本身指的就是 ECMAScript。</p><p>由于 ES5.1 以后的版本相较于之前有了很大的改动，有很多人就习惯简称它们为 ES6，其实他的准确简称应该是 ES2015。</p><h2 id="ES2015-let-与块级作用域"><a href="#ES2015-let-与块级作用域" class="headerlink" title="ES2015 let 与块级作用域"></a>ES2015 let 与块级作用域</h2><div class="story post-story"><p>var 会被变量提升，let 不会有这个问题</p></div><h2 id="ES2015-const"><a href="#ES2015-const" class="headerlink" title="ES2015 const"></a>ES2015 const</h2><div class="story post-story"><p>const 声明的常量不能再次修改引用的内存地址。</p></div><h2 id="ES2015-数组的解构"><a href="#ES2015-数组的解构" class="headerlink" title="ES2015 数组的解构"></a>ES2015 数组的解构</h2><div class="story post-story"><p>const [a.b] = [100, 200]可以根据位置提取对应的值</p></div><h2 id="ES2015-对象的解构"><a href="#ES2015-对象的解构" class="headerlink" title="ES2015 对象的解构"></a>ES2015 对象的解构</h2><div class="story post-story"><p>const {a} = {a:200}和数组不同的是，它需要指定解构的属性名</p></div><h2 id="ES2015-模板字符串"><a href="#ES2015-模板字符串" class="headerlink" title="ES2015 模板字符串"></a>ES2015 模板字符串</h2><div class="story post-story"><p>和传统的字符串相比，支持多行字符串，还可以使用插值表达式拼接内容，而不用像传统字符串用+号拼接，更便捷。</p></div><h2 id="ES2015-带标签的模板字符串"><a href="#ES2015-带标签的模板字符串" class="headerlink" title="ES2015 带标签的模板字符串"></a>ES2015 带标签的模板字符串</h2><div class="story post-story"><p>const str = console.log’hello wolrd’模板字符串前面可以带上一个函数，这个函数中可以接收到所有表达式出现的值。</p></div><h2 id="ES2015-字符串的扩展方法"><a href="#ES2015-字符串的扩展方法" class="headerlink" title="ES2015 字符串的扩展方法"></a>ES2015 字符串的扩展方法</h2><div class="story post-story"><p>startWithendWithincludes</p></div><h2 id="ES-2015-参数默认值"><a href="#ES-2015-参数默认值" class="headerlink" title="ES 2015 参数默认值"></a>ES 2015 参数默认值</h2><div class="story post-story"><p>function fn(a = 100){}可以在形参后面加上=值一定要将需要添加默认值的形参放在最后，不然可能导致参数默认值无法正常工作。比如:function fn(a=100,b){}fn(100) //我想要形参 a 有一个默认值，但是我可能只会传这一个参数，a 的参数默认值就不能正常工作。因为参数是依次传递的，可选的参数应该放在后面，保证必传的参数能够优先传递。</p></div><h2 id="ES2015-剩余参数"><a href="#ES2015-剩余参数" class="headerlink" title="ES2015 剩余参数"></a>ES2015 剩余参数</h2><div class="story post-story"><p>arguments…args</p></div><h2 id="ES2015-展开数组"><a href="#ES2015-展开数组" class="headerlink" title="ES2015 展开数组"></a>ES2015 展开数组</h2><div class="story post-story"><p>console.log(…[100,200,300])</p></div><h2 id="ES2015-箭头函数与-this"><a href="#ES2015-箭头函数与-this" class="headerlink" title="ES2015 箭头函数与 this"></a>ES2015 箭头函数与 this</h2><div class="story post-story"><p>在箭头函数中没有 this，它的 this 指向它的上级作用域。</p></div><h2 id="ES2015-对象字面量的增强"><a href="#ES2015-对象字面量的增强" class="headerlink" title="ES2015 对象字面量的增强"></a>ES2015 对象字面量的增强</h2><div class="story post-story"><p>对象中可以省略属性名对应的值，前提是属性名和字面量名称相同。</p></div><h2 id="ES2015-Object-assign"><a href="#ES2015-Object-assign" class="headerlink" title="ES2015 Object.assign"></a>ES2015 Object.assign</h2><div class="story post-story"><p>var obj3=Object.assign(obj1, obj2)用 obj2 覆盖 obj1 对象，返回的 obj3 它其实就是 obj1</p></div><h2 id="ES2015-Object-is"><a href="#ES2015-Object-is" class="headerlink" title="ES2015 Object.is"></a>ES2015 Object.is</h2><div class="story post-story"><p>==只比较值，不比较类型，会自动类型转换===比较值和类型，严格模式NaN ===NaN //falseObject.is(NaN,NaN)//true</p></div><h2 id="ES2015-Proxy"><a href="#ES2015-Proxy" class="headerlink" title="ES2015 Proxy"></a>ES2015 Proxy</h2><div class="story post-story"><p>可以对对象的属性改动进行检测和拦截</p></div><h2 id="ES2015-Proxy-对比-Object-defineProperty"><a href="#ES2015-Proxy-对比-Object-defineProperty" class="headerlink" title="ES2015 Proxy 对比 Object.defineProperty"></a>ES2015 Proxy 对比 Object.defineProperty</h2><div class="story post-story"><p>Proxy 功能更强大一些。proxy 能够检测 defineProperty 检测不到的行为，比如属性删除，方法调用可以对数组检测Proxy 是一种非侵入式的方式进行代理，不用对原来的对象做任何改动，而 Object.definePropery 则需要我们对原对象做一些特有的改动。</p></div><h2 id="ES2015-Reflect"><a href="#ES2015-Reflect" class="headerlink" title="ES2015 Reflect"></a>ES2015 Reflect</h2><div class="story post-story"><p>Reflect.getReflect.set提供了一套对对象操作的 api以前的操作方式可能会被废弃掉</p></div><h2 id="ES2015-Promise"><a href="#ES2015-Promise" class="headerlink" title="ES2015 Promise"></a>ES2015 Promise</h2><div class="story post-story"><p>异步编程解决方案</p></div><h2 id="ES2015-class"><a href="#ES2015-class" class="headerlink" title="ES2015 class"></a>ES2015 class</h2><div class="story post-story"><h2 id="es2015-静态方法"><a href="#es2015-静态方法" class="headerlink" title="es2015 静态方法"></a>es2015 静态方法</h2><h2 id="es2015-类的继承"><a href="#es2015-类的继承" class="headerlink" title="es2015 类的继承"></a>es2015 类的继承</h2><p>super</p></div><h2 id="ES2015-Set"><a href="#ES2015-Set" class="headerlink" title="ES2015 Set"></a>ES2015 Set</h2><div class="story post-story"><p>不重复的数组 常用来去重</p></div><h2 id="ES2015-Map"><a href="#ES2015-Map" class="headerlink" title="ES2015 Map"></a>ES2015 Map</h2><div class="story post-story"><p>let obj ={a:100}let o = new Map()o.set(obj, 666) //它的键就是 obj 对象本身严格的键值对集合，它的键可以是任意类型。</p></div><h2 id="ES2015-Symbol"><a href="#ES2015-Symbol" class="headerlink" title="ES2015 Symbol"></a>ES2015 Symbol</h2><div class="story post-story"><p>Symbol 表示独一无二的值，他可以作为对象的键( key)。</p><h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h4><p>内部维护了一个全局的注册表，提供了字符串和 Symbol 的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此Symbol.for(&quot;aa&quot;) = Symbol. for(&quot;aa&quot;) // true</span></span><br><span class="line"><span class="comment">// 如果传入的不是字符串，会自动转换为字符串。</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="literal">true</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot; true&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Symbol-用途"><a href="#Symbol-用途" class="headerlink" title="Symbol 用途"></a>Symbol 用途</h4><ol><li>我们在使用第三方模块时，想要对其扩展，由于我们不知道内部具体定义的哪些属性，在这种情况下，去为其扩展属性，就会很大可能发生冲突的问题。那么使用<code>Symbol</code>作为属性就不会出现这种问题。</li><li>可以为对象添加私有属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  [name]: <span class="string">&quot;xsl&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 只能通过这种方式访问</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.[name])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而当我们在外部使用时，由于不知道内部的唯一键是什么，因此只能通过实例间接访问，而无法在外部直接访问。</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>. log(obj.say)</span><br></pre></td></tr></table></figure><ol start="3"><li> <code>Symbol</code>提供了很多内置常量，用于作为内部方法的标识。这些标识符可以让自定义对象实现 JS 当中内置的接口。比如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol.iterator</span></span><br><span class="line"><span class="comment">// Symbol.hasInstance</span></span><br><span class="line"><span class="comment">// Symbol.toStringTag</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;XObject&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">// [ object XObject]</span></span><br></pre></td></tr></table></figure><p>对象的<code>Symbol</code>属性无法通过<code>for in</code>和<code>Object.keys</code>获取，<code>JSON.stringify</code>时<code>Symbol</code>的属性也会被忽略掉。<strong>可以使用</strong><code>**Object.getOwnPropertySymbols**</code><strong>获取对象的所有</strong><code>**Symbol**</code><strong>类型的属性。</strong></p></div><h2 id="ES2015-for-of"><a href="#ES2015-for-of" class="headerlink" title="ES2015 for of"></a>ES2015 for of</h2><div class="story post-story"><p>使用 for of 可以遍历所有数据类型默认可以对数组遍历需要实现统一的 Iterable 接口，数组默认内部已经实现了。</p></div><h2 id="ES2015-Iterable"><a href="#ES2015-Iterable" class="headerlink" title="ES2015 Iterable"></a>ES2015 Iterable</h2><div class="story post-story"><h2 id="ES2016-概述"><a href="#ES2016-概述" class="headerlink" title="ES2016 概述"></a>ES2016 概述</h2><h2 id="ES2017-概述"><a href="#ES2017-概述" class="headerlink" title="ES2017 概述"></a>ES2017 概述</h2><p>允许在参数和数组字面量后边加上小逗号</p></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript中的异步编程</title>
      <link href="/2021/05/25/yuque/Javascript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/05/25/yuque/Javascript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>javascript 被设计为单线程的，因为如果是多线程的话，在多个并行任务中去操作 DOM 会发生意想不到的内容。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>说透函数式编程</title>
      <link href="/2021/05/22/yuque/%E8%AF%B4%E9%80%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/05/22/yuque/%E8%AF%B4%E9%80%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>说到函数式编程，不得不提到数学里的函数，例如数学公式 x=f(y)就很好的描述了 x 和 y 的映射关系，其实，函数式编程正来源于此。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><div class="story post-story"><p>函数式编程(Function Programming FP)，FP 是编程范式之一。函数式编程是一个很古老的概念，它和面向对象等概念是并列的，我们可以认为它是一种如何编写代码的“方法论”。函数式编程的思维方式是把现实世界的事物和事物之间的联系抽象到程序世界，在程序中对运算过程进行抽象，具体的做法是，根据输入某种运算获得相应的输出，因为程序开发过程中会涉及很多有输入和输出的函数。有一点需要注意的是，函数式编程中的函数指的不是程序中的函数，而是数学中的函数，即不同数据之间的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数学中的函数</span></span><br><span class="line">y = sin(x); <span class="comment">// 描述x和y之间的映射关系</span></span><br></pre></td></tr></table></figure><p>由此可见在函数式编程的中，对于相同的输入，函数的输出是恒定的，也就是没有副作用的纯函数；没有副作用的意思是它的输出不会因为外部变量的变化而发生变化。</p><p>上面说它是一种“方法论”，那么我们为什么要使用这种“方法论”呢？要想弄清楚这个问题，我们可以从使用函数式编程有什么好处来作为切入口。</p></div><h2 id="使用函数式编程的好处"><a href="#使用函数式编程的好处" class="headerlink" title="使用函数式编程的好处"></a>使用函数式编程的好处</h2><div class="story post-story"><ul><li>函数式编程可以抛弃 this，不再向面向对象那样经常用到 this</li><li>打包过程中可以更好的利用 tree shaking 过滤无用代码</li><li>方便测试和并行处理</li></ul><p>了解了它的好处，下面来介绍常见的函数式编程都有哪些？不过在此之前，我们先来了解一下函数是一等公民的概念，因为它是后续高阶函数、柯里化等的基础。</p></div><h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><div class="story post-story"><p>在 JavaScript 中函数就是一个普通的对象(可以通过 new Function()创建)，我们可以把函数存储到变量、数组、对象中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 new Function(‘alert(1)’)来构造一个新的函数。总结来说，函数是一等公民，它有以下特点：</p><ul><li>函数可以存储在变量中</li><li>函数可以作为参数</li><li>函数可以作为返回值</li></ul></div><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><div class="story post-story"><p>高阶函数(Higher-order-function)的定义是：可以把函数作为参数传递给另一个函数；可以把函数作为另一个函数的返回结果。我们为什么要使用高阶函数呢？</p><h3 id="使用高阶函数的意义-好处"><a href="#使用高阶函数的意义-好处" class="headerlink" title="使用高阶函数的意义/好处"></a>使用高阶函数的意义/好处</h3><ul><li>使函数抽象化，可以帮我们屏蔽实现细节，每次在调用函数时，我们只需要关注想要的目标。</li><li>对通用问题进行抽象，方便重复调用</li><li>使代码更加简洁</li></ul></div><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><div class="story post-story"><p>闭包(Closure)的定义是：函数和周围的状态(词法环境)的引用捆绑在一起形成闭包。换句话说就是，闭包的形成是因为函数引用了当前作用域以外的其他作用域中的变量。</p><p>深入函数执行机制，函数执行会形成一个执行栈，当执行栈中的内容被执行完成之后，会被游览器垃圾回收机制移除。但如果堆上的作用域成员被外部引用，是不会被移除的，因此内部函数依然可以访问外部函数中的成员。这就是闭包的本质。</p><h3 id="使用闭包的好处"><a href="#使用闭包的好处" class="headerlink" title="使用闭包的好处"></a>使用闭包的好处</h3><p>延长了外部函数中的变量的作用范围。</p></div><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><div class="story post-story"><p>纯函数的概念其实很简单：“相同的输入永远会得到相同的输出”。也就是我们重复调用同一个函数，函数的返回值是和函数的参数一一对应的。我们可以把纯函数理解为数学中的函数，比如数学中常见的数学公式：y=f(x)，它描述了数据与数据之间(x 和 y)的映射关系。纯函数的特点就是不会保留中间的计算结果，比如无法访问函数内部的运算中间结果，因为它不会对计算结果做数据持久化，并且变量是不可变的，所以纯函数是无状态的。</p><h3 id="使用纯函数的好处"><a href="#使用纯函数的好处" class="headerlink" title="使用纯函数的好处"></a>使用纯函数的好处</h3><ul><li>可缓存：由于纯函数相同的输入始终有相同的输出，我们就可以把函数的结果<strong>缓存</strong>起来，避免重复调用，提高性能。</li><li>方便测试</li><li>方便并行处理：在多线程环境下，避免并行操作共享的内存数据引发的意外情况。</li></ul></div><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><div class="story post-story"><p>副作用会让一个函数变得不纯，纯函数根据相同的输入返回相同的输出，如果一个函数依赖于外部的状态就无法保证函数输出相同，就会带来副作用。副作用可能的来源：配置文件、数据库、获取用户的输入等。所有的外部交互都有可能导致副作用，副作用也使得方法通用性下降不适合可扩展性和通用性，同时副作用会给程序中带来安全隐患和不确定性，但是副作用不可能完全禁止，我们应该尽可能控制他们在可控的范围内发生。</p></div><h2 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h2><div class="story post-story"><p>当一个函数有多个参数的时候，先传一部分参数并调用它，这部分参数以后永远不变。然后返回一个新的函数接收剩余的参数，最后返回结果。柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数。因此，柯里化是一种对函数参数的<strong>缓存</strong>。</p><h3 id="柯里化的好处"><a href="#柯里化的好处" class="headerlink" title="柯里化的好处"></a>柯里化的好处</h3><ul><li>让函数变得灵活，让函数的粒度变得更小</li><li>可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能。</li></ul><h3 id="通用柯里化函数"><a href="#通用柯里化函数" class="headerlink" title="通用柯里化函数"></a>通用柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">iner</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length !== args.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> iner(args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fn.apply(fn, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="函数组合-compose"><a href="#函数组合-compose" class="headerlink" title="函数组合(compose)"></a>函数组合(compose)</h2><div class="story post-story"><p>纯函数和柯里化函数很容易写出洋葱代码，这是我们不希望看到的。而函数组合可以让我们把细粒度的函数重新组合生成一个新的函数。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">ret, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn(ret);</span><br><span class="line">    &#125;, value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数组合需要满足<strong>结合律</strong>，假如有三个函数 a、b、c，我们可以先把 a、b 函数组合，然后再组合 c；也可以先把 b、c 组合，然后再组合 a，结果是一样的。</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何提升开发与设计表单类页面时的效率</title>
      <link href="/2021/03/06/yuque/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%8D%95%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87/"/>
      <url>/2021/03/06/yuque/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%8D%95%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>可视化表单   编辑器   代码生成   表单设计</p><table><thead><tr><th align="center">版本</th><th align="center">作者</th><th align="center">更新日期</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">1.0</td><td align="center">feline</td><td align="center">2021/3/8</td><td align="left">拖拽方式组合控件</td></tr><tr><td align="center">2.0</td><td align="center">feline</td><td align="center">2021/3/16</td><td align="left">1.重新布局，设计区域扩大很多(核心不变)</td></tr><tr><td align="center">2.控件拖拽时，页面展示辅助线</td><td align="center"></td><td align="center"></td><td align="left"></td></tr></tbody></table><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><div class="story post-story"><p>开发者要开发表单类业务时，由于表单类型多而且复杂，要将这些表单控件一一组合，未免费时费力。而表单通常都是一些固定的组合，那么能不能在编码之间通过某种方式生成出来呢？此时，我想到如果有一款可视化的编辑器产品能够通过拖拽方式组装页面，同时通过设置面板给所有/单个控件设置统一属性，最后不仅能直观的看到页面效果，还能一键复制代码，一定会带来很大的效率提升！同时也可以用于产品原型的制作。</p><p><a href="https://resonances.gitee.io/react-visual-editor/">点此进入预览版</a> | <a href="https://gitee.com/resonances/react-visual-editor/tree/master/docs/imgs">效果图</a></p></div><h2 id="利益相关方"><a href="#利益相关方" class="headerlink" title="利益相关方**"></a>利益相关方**</h2><div class="story post-story"><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1617853708633-c4bf2a5c-fe21-4c9f-9931-5d9383eedded.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1617853708633-c4bf2a5c-fe21-4c9f-9931-5d9383eedded.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><div class="story post-story"><ol><li>用例开始</li><li>用户打开页面</li><li>页面提示可以点击左侧按钮展开控件面板</li><li>用户点击左侧菜单按钮</li><li>左侧区域出现控件面板</li><li>用户点选某个控件</li><li>控件被自动添加到页面中间的设计区域</li><li>系统提示可以对控件进行设置属性</li><li>用户右击控件</li><li>弹出菜单选项</li><li>用户选择“设置属性”</li><li>右侧区域出现属性面板</li><li>用户直接选择系统预设的不同属性</li><li>系统提示可以点击运行按钮查看生成的页面与代码</li><li>用户点击运行按钮</li><li>系统自动生成代码成功</li><li>系统展示生成完成的代码与效果页面</li><li>用户将代码复制</li><li>用例结束</li></ol></div><h2 id="扩展流程"><a href="#扩展流程" class="headerlink" title="扩展流程"></a>扩展流程</h2><div class="story post-story"><p>11a. 用户选择“复制这个”11a1. 系统自动添加一个相同的控件11b. 用户选择“删除这个”11b1. 系统自动将此控件删除16a. 系统自动生成代码失败16a1. 系统提示：运行错误16a2. 执行用例 1</p></div><h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><div class="story post-story"><ul><li><input checked="" disabled="" type="checkbox"> 布局设置流程打通</li></ul><p>目前可以对全部或部分组件进行布局设置了。</p><ul><li><input disabled="" type="checkbox"> 支持用户自定义请求 options</li><li><input disabled="" type="checkbox"> 支持用户自定义表单提交方法</li></ul><p>比如请求某个接口</p><ul><li><input disabled="" type="checkbox"> 生成的代码提取公共部分并抽离</li><li><input disabled="" type="checkbox"> 快捷键支持</li></ul><p>使用快捷键来快速实现某个功能比如：复制、剪切、删除、打开面板</p><ul><li><input disabled="" type="checkbox"> 生成后的页面可以转为 HTML 并下载、预览</li><li><input disabled="" type="checkbox"> 支持绘制元素</li></ul><p>不仅限于表单，也可以绘制图标、方块、等多种元素</p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思维导图之面向对象</title>
      <link href="/2020/11/13/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/11/13/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>{“format”:”lakemind”,”type”:”Mind”,”version”:”1.0”,”diagramData”:{“head”:{“version”:”2.0.0”},”body”:[{“id”:”init”,”type”:”mindmap”,”html”:”new 执行的原理”,”zIndex”:4,”children”:[{“html”:”1.创建一个实例对象：<div>&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;实例.<strong>proto</strong> = 类.prototype 或 Object.create(类.prototype)</span></div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”85ce6913-dcd3-425e-b6ef-aee7f0886c4c”,”children”:[],”zIndex”:0},{“html”:”2.把函数执行，并让函数中的 this 指向实例对象”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”96200052-d822-404c-afd7-60f20c8d1271”,”children”:[],”zIndex”:1},{“html”:”3.处理返回值”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”0f9642a7-e861-4100-b45a-a696688e9b18”,”children”:[{“html”:”如果函数有返回值并且返回值是引用数据类型，则返回函数的返回值；<div>否则返回创建的实例对象</div>“,”id”:”18ffee2e-f3b7-4655-a51e-48db60913134”,”children”:[],”zIndex”:3}],”zIndex”:2}],”x”:-131,”y”:-132},{“id”:”09c49c10-bffa-4053-9219-878620a2f3da”,”x”:-131,”y”:12.5,”html”:”Object.create”,”type”:”mindmap”,”children”:[{“html”:”创建一个对象，并让这个对象的<strong>proto</strong>指向传入的对象的 prototype”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”632b4468-6098-473e-a033-ff06f23c64d4”,”children”:[],”zIndex”:5},{“html”:”Object.create(null) ： 创建一个空对象，并且取消对象的<strong>proto</strong>属性”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”ecc00729-f2c3-4e30-ae83-8cad91c2940b”,”children”:[],”zIndex”:6}],”zIndex”:7},{“id”:”6f913443-31ef-4424-8346-2fbd3e3e7562”,”x”:-129,”y”:193.75,”html”:”函数的多种角色”,”type”:”mindmap”,”children”:[{“html”:”1.作为函数(第一角色)”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”5b137287-648e-4d2f-89dd-40cbd6afaae4”,”children”:[{“html”:”1.普通函数”,”id”:”072d4913-a4f0-40a6-8561-8210526bea47”,”children”:[],”zIndex”:10},{“html”:”2.构造函数<div>类/原型和原型链</div>“,”id”:”84e94270-1b3b-4e13-a291-b4cf8a3ca6bc”,”children”:[],”zIndex”:11}],”zIndex”:8},{“html”:”2.作为对象”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”6ded07ac-ef75-4e5e-99ba-a36f9f0f3eac”,”children”:[{“html”:”键值对”,”id”:”2f854a27-ddad-4b7f-9ede-fdd5b2111375”,”children”:[],”zIndex”:12}],”zIndex”:9},{“html”:”注意点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”8fc86a61-a0ca-4bad-8e37-b4d38e836230”,”children”:[{“html”:”函数是一等公民(数据类型归类)”,”id”:”208cd520-48dc-43f9-aa06-a34737c26868”,”children”:[],”zIndex”:14},{“html”:”三种角色之间没有必然的联系”,”id”:”8f50d9ef-5f0d-4ff8-9f44-9f3d5c20a456”,”children”:[],”zIndex”:15}],”zIndex”:13}],”zIndex”:16},{“id”:”49af2de2-9361-4cf1-827d-b6ba949e6770”,”x”:-131.81879728408808,”y”:379.9729407979514,”html”:”Function 和 Object 是两大基类”,”type”:”mindmap”,”children”:[{“html”:”Object.<strong>proto</strong> === Function.<strong>proto</strong>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”16dcc1fa-0869-4148-9270-77f5d4de94b4”,”children”:[],”zIndex”:17},{“html”:”Function.<strong>proto</strong>.<strong>proto</strong> === Object.prototype”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”d75ff7bb-2648-4432-b8b3-1afbf6833718”,”children”:[],”zIndex”:18}],”zIndex”:19},{“id”:”ec75acf4-2122-41c1-b6b2-84158d399c25”,”x”:-134.13175384962597,”y”:590.4962846636315,”html”:”不具备 prototype 的函数”,”type”:”mindmap”,”children”:[{“html”:”1.箭头函数”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”bcb15d2f-4314-4d9f-9401-660b15079d4a”,”children”:[],”zIndex”:20},{“html”:”2.let obj = {<div>    fn(){} //  这种写法不具备</div><div>}</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”4c3b78ce-c64f-4cac-8334-bc1b3c40b10a”,”children”:[],”zIndex”:21},{“html”:”3.Function.prototype”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”b2766f89-bd1e-4b4d-b7b0-fb08bd673bc1”,”children”:[],”zIndex”:22},{“html”:”特点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”b1846653-a45f-4c2d-9e0b-aecffe27d33e”,”children”:[{“html”:”不能被 new 执行（不是构造函数）”,”id”:”951a3597-2619-443f-a5e4-cab71e21f7a5”,”children”:[],”zIndex”:24}],”zIndex”:23}],”zIndex”:25},{“id”:”47ef0862-265f-414a-b645-e73dbd35b629”,”x”:-136.16110284270343,”y”:929.2477717010211,”html”:”检测数据类型的方法”,”type”:”mindmap”,”children”:[{“html”:”1.typeof”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”95131760-5b3e-4ba0-b475-c2dc831c229d”,”children”:[{“html”:”按照二进制存储的值进行检测的”,”id”:”d0b02dae-57b1-4455-a679-6ebda4f0e5be”,”children”:[],”zIndex”:30},{“html”:”缺点”,”id”:”0bf9936e-0805-40bf-95d8-af27e9d301f9”,”children”:[{“html”:”bug: typeof null 等于 object”,”id”:”250fb09b-964e-4f76-b30e-9423697b0b0e”,”children”:[],”zIndex”:37,”height”:null},{“html”:”不能细分具体的引用数据类型”,”id”:”b433a4d1-f5a7-4be8-87a8-d4d68f031ee9”,”children”:[],”zIndex”:32}],”zIndex”:31}],”zIndex”:26},{“html”:”2.Object.prototype.toString”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”b46509c1-89a3-4d9c-82fe-a83b38f51c53”,”children”:[],”zIndex”:27},{“html”:”3.contructor”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”d07e6c2d-6b29-4c1c-b480-f3860bcdf761”,”children”:[{“html”:”当前实例是否是当前类的实例(只找一级)”,”id”:”592ec3fe-508d-43b7-9a15-e07c73b5cdb3”,”children”:[],”zIndex”:36}],”zIndex”:28},{“html”:”4.instance of”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”22a2252a-98ab-4861-9bdd-8618dfee7a24”,”children”:[{“html”:”原理”,”id”:”3d5ef254-8fe2-4489-9259-8d0c7020adae”,”children”:[{“html”:”static 构造函数<a href="%E5%AE%9E%E4%BE%8B">Symbol.hasInstance</a>“,”id”:”32acc5d3-94f0-4995-8770-d45be84e6788”,”children”:[],”zIndex”:34},{“html”:”当前构造函数的原型 prototype 是否出现在，当前实例所在的原型链上<strong>proto</strong>“,”id”:”6cab9c06-2191-4c40-8a72-b1af716add11”,”children”:[],”zIndex”:35}],”zIndex”:33}],”zIndex”:29}],”zIndex”:38}]},”viewportSetting”:{“zoom”:1.0506695938270962,”tlCanvasPoint”:[-147.65729938911286,646.4696602662399,1],”width”:1366,”height”:898},”text”:”new 执行的原理 1.创建一个实例对象：实例.<strong>proto</strong> = 类.prototype 或 Object.create(类.prototype)2.把函数执行，并让函数中的 this 指向实例对象 3.处理返回值如果函数有返回值并且返回值是引用数据类型，则返回函数的返回值；否则返回创建的实例对象 Object.create 创建一个对象，并让这个对象的<strong>proto</strong>指向传入的对象的 prototypeObject.create(null) ： 创建一个空对象，并且取消对象的<strong>proto</strong>属性函数的多种角色 1.作为函数(第一角色)1.普通函数 2.构造函数类/原型和原型链 2.作为对象键值对注意点函数是一等公民(数据类型归类)三种角色之间没有必然的联系 Function 和 Object 是两大基类 Object.<strong>proto</strong> === Function.<strong>proto</strong>Function.<strong>proto</strong>.<strong>proto</strong> === Object.prototype 不具备 prototype 的函数 1.箭头函数 2.let obj = {    fn(){} //  这种写法不具备}3.Function.prototype 特点不能被 new 执行（不是构造函数）检测数据类型的方法 1.typeof 按照二进制存储的值进行检测的缺点 bug: typeof null 等于 object 不能细分具体的引用数据类型 2.Object.prototype.toString3.contructor 当前实例是否是当前类的实例(只找一级)4.instance of 原理 static 构造函数<a href="%E5%AE%9E%E4%BE%8B">Symbol.hasInstance</a>当前构造函数的原型 prototype 是否出现在，当前实例所在的原型链上<strong>proto</strong>“}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思维导图之作用域和闭包</title>
      <link href="/2020/10/29/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2020/10/29/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>{“format”:”lakemind”,”type”:”Mind”,”version”:”1.0”,”diagramData”:{“head”:{“version”:”2.0.0”},”body”:[{“id”:”init”,”type”:”mindmap”,”html”:”数据类型”,”children”:[{“html”:”基本类型”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”f1b51e22-5556-41c2-8bdf-f900a8c5cf6f”,”children”:[{“html”:”number”,”id”:”3c85803e-2ab1-47d3-93e4-34e924d6d361”,”children”:[],”zIndex”:2},{“html”:”string”,”id”:”0714922a-cb2e-4e85-ba85-d73c7bafc728”,”children”:[],”zIndex”:3},{“html”:”undefined”,”id”:”42f4fa35-8257-402a-ae08-12ea56d761ee”,”children”:[],”zIndex”:4},{“html”:”null”,”id”:”bee1c28d-be83-4edf-af03-08b8dd29d91e”,”children”:[],”zIndex”:5},{“html”:”boolean”,”id”:”c5ae2d7f-12b8-4379-a4ea-7679e6f99b6f”,”children”:[],”zIndex”:9},{“html”:”symbol”,”id”:”b326de10-646c-48e5-985e-32744066f033”,”children”:[],”zIndex”:6}],”zIndex”:0},{“html”:”引用类型”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”1a581807-35a4-47d7-bfe1-cf8f93e51df8”,”children”:[{“html”:”object”,”id”:”aae01172-12c8-4c6a-8da9-dae7ff8f1997”,”children”:[{“html”:”array”,”id”:”abdcf0cb-edc5-40ce-913c-86c1b24bceec”,”children”:[],”zIndex”:10},{“html”:”…”,”id”:”6d40973b-4f4b-4c09-90b8-c7046fbdbf13”,”children”:[],”zIndex”:11}],”zIndex”:7},{“html”:”function”,”id”:”f5803c67-eec6-4f23-82b7-0a3da47141e8”,”children”:[],”zIndex”:8}],”zIndex”:1}],”zIndex”:12,”x”:2024.4623834304057,”y”:-3472.70048927316,”border”:{“shape”:”rect”,”stroke”:”transparent”}},{“id”:”fc99eff4-03ef-4955-9ac3-c3dd0fc2e483”,”x”:2003.6096233018084,”y”:-2194.5299924160363,”html”:”JS 代码执行”,”type”:”mindmap”,”children”:[{“html”:”1.游览器会在内存中开辟一块栈内存，全局上下文（环境），也叫 ECStack。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”733f2abd-2dc1-4e82-a9cc-25b7be0d2ef7”,”children”:[{“html”:”&lt;div style=&quot;text-align:center;&quot;&gt;</div>“,”id”:”a40eafd0-87de-4158-b9c7-9f35fdb611c3”,”children”:[{“html”:”&lt;div style=&quot;text-align:center;&quot;&gt;</div>“,”id”:”a78d3f71-b03d-4d09-82f2-5bbf0bd07162”,”children”:[],”zIndex”:16,”image”:{“src”:”<a href="https://cdn.nlark.com/yuque/0/2020/png/1429353/1604060996415-32302ab3-f32b-4e45-9ead-6ac9698e07ab.png&quot;,&quot;naturalWidth&quot;:700,&quot;naturalHeight&quot;:504,&quot;width&quot;:283,&quot;height&quot;:203.76000000000002%7D,&quot;width&quot;:299,&quot;height&quot;:216%7D],&quot;zIndex&quot;:15,&quot;image&quot;:%7B&quot;src&quot;:&quot;https://cdn.nlark.com/yuque/0/2020/png/1429353/1604059782703-5690a93e-e8c8-4593-95d1-e68ab4bee13b.png&quot;,&quot;naturalWidth&quot;:589,&quot;naturalHeight&quot;:479,&quot;width&quot;:206,&quot;height&quot;:167.52801358234296%7D,&quot;border&quot;:%7B&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;%7D,&quot;width&quot;:222,&quot;height&quot;:187.52801358234296%7D],&quot;zIndex&quot;:13,&quot;border&quot;:%7B&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;%7D%7D,%7B&quot;html&quot;:&quot;2.%E7%84%B6%E5%90%8E%E5%BD%A2%E6%88%90%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87EC(G)%EF%BC%88%E9%BB%98%E8%AE%A4%E5%B0%B1%E6%98%AFwindow/global%EF%BC%89%E4%BE%9B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E3%80%82&quot;,&quot;layout&quot;:%7B&quot;quadrant&quot;:1%7D,&quot;treeEdge&quot;:%7B&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;cde0a14e-ccf0-40d0-8e05-0ccb4d1868f4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:14}],&quot;zIndex&quot;:17},{&quot;id&quot;:&quot;129c5c0c-ad88-4e63-9320-a350ee1f58df&quot;,&quot;x&quot;:3374.297353377579,&quot;y&quot;:-2207.5561578019106,&quot;html&quot;:&quot;%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[{&quot;html&quot;:&quot;1.%E5%8D%95%E7%8B%AC%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%8816%E8%BF%9B%E5%88%B6%E5%9C%B0%E5%9D%80%EF%BC%89%EF%BC%8C%E5%87%BD%E6%95%B0%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E4%BD%93%E4%B8%AD%E7%9A%84%E2%80%9C%E4%BB%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9D%E3%80%82&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;5859bc97-b0cc-4727-809e-482555f526ce&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:18},{&quot;html&quot;:&quot;2.%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E5%A3%B0%E6%98%8E%E4%BA%86%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F[scope]%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%89%80%E5%9C%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E3%80%82&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;a151950e-08f2-436f-ba60-896f20e404f9&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:19},{&quot;html&quot;:&quot;3.%E6%8A%8A16%E8%BF%9B%E5%88%B6%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E5%88%B0%E6%A0%88%E4%B8%AD%EF%BC%8C%E4%BE%9B%E5%8F%98%E9%87%8F%EF%BC%88%E5%87%BD%E6%95%B0%E5%90%8D%E7%AD%89%EF%BC%89%E5%85%B3%E8%81%94%E5%BC%95%E7%94%A8%E5%8D%B3%E5%8F%AF&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#69B1E4&quot;},&quot;id&quot;:&quot;6596c13c-9913-405a-b5d5-efa629c25397&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:20},{&quot;html&quot;:&quot;">https://cdn.nlark.com/yuque/0/2020/png/1429353/1604060996415-32302ab3-f32b-4e45-9ead-6ac9698e07ab.png&quot;,&quot;naturalWidth&quot;:700,&quot;naturalHeight&quot;:504,&quot;width&quot;:283,&quot;height&quot;:203.76000000000002},&quot;width&quot;:299,&quot;height&quot;:216}],&quot;zIndex&quot;:15,&quot;image&quot;:{&quot;src&quot;:&quot;https://cdn.nlark.com/yuque/0/2020/png/1429353/1604059782703-5690a93e-e8c8-4593-95d1-e68ab4bee13b.png&quot;,&quot;naturalWidth&quot;:589,&quot;naturalHeight&quot;:479,&quot;width&quot;:206,&quot;height&quot;:167.52801358234296},&quot;border&quot;:{&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;},&quot;width&quot;:222,&quot;height&quot;:187.52801358234296}],&quot;zIndex&quot;:13,&quot;border&quot;:{&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;}},{&quot;html&quot;:&quot;2.然后形成全局执行上下文EC(G)（默认就是window/global）供代码执行。&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;cde0a14e-ccf0-40d0-8e05-0ccb4d1868f4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:14}],&quot;zIndex&quot;:17},{&quot;id&quot;:&quot;129c5c0c-ad88-4e63-9320-a350ee1f58df&quot;,&quot;x&quot;:3374.297353377579,&quot;y&quot;:-2207.5561578019106,&quot;html&quot;:&quot;创建函数&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[{&quot;html&quot;:&quot;1.单独开辟一个堆内存（16进制地址），函数堆内存中存储的是函数体中的“代码字符串”。&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;5859bc97-b0cc-4727-809e-482555f526ce&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:18},{&quot;html&quot;:&quot;2.创建函数的时候，就声明了它的作用域[scope]，也就是所在的上下文环境。&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;a151950e-08f2-436f-ba60-896f20e404f9&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:19},{&quot;html&quot;:&quot;3.把16进制的地址存放到栈中，供变量（函数名等）关联引用即可&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#69B1E4&quot;},&quot;id&quot;:&quot;6596c13c-9913-405a-b5d5-efa629c25397&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:20},{&quot;html&quot;:&quot;</a>&lt;div style=&quot;text-align:center;&quot;&gt;</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”14419622-89b2-404d-96bb-6122e3cd7723”,”children”:[],”zIndex”:21,”image”:{“src”:”<a href="https://cdn.nlark.com/yuque/0/2020/png/1429353/1604062395688-a40f493f-f76f-4dcd-83e0-a3eddcbbc1f0.png&quot;,&quot;naturalWidth&quot;:463,&quot;naturalHeight&quot;:281,&quot;width&quot;:463,&quot;height&quot;:281%7D%7D],&quot;zIndex&quot;:22%7D,%7B&quot;id&quot;:&quot;ea92f014-dfb7-4bc5-9fec-3e2a2d3219a6&quot;,&quot;x&quot;:1991.010600069691,&quot;y&quot;:-1629.5675587544767,&quot;html&quot;:&quot;%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[%7B&quot;html&quot;:&quot;1.%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%85%A8%E6%96%B0%E7%9A%84%EF%BC%8C%E7%A7%81%E6%9C%89%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87EC(...)&quot;,&quot;layout&quot;:%7B&quot;quadrant&quot;:1%7D,&quot;treeEdge&quot;:%7B&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;27859533-85ab-45c2-9635-0fa167fe12d4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:23},{&quot;html&quot;:&quot;2.%E5%BD%93%E5%89%8D%E7%A7%81%E6%9C%89%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%98%E6%94%BE%E6%9C%AC%E4%B8%8A%E4%B8%8B%E6%96%87%E5%86%85%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E6%96%B9AO(...)">https://cdn.nlark.com/yuque/0/2020/png/1429353/1604062395688-a40f493f-f76f-4dcd-83e0-a3eddcbbc1f0.png&quot;,&quot;naturalWidth&quot;:463,&quot;naturalHeight&quot;:281,&quot;width&quot;:463,&quot;height&quot;:281}}],&quot;zIndex&quot;:22},{&quot;id&quot;:&quot;ea92f014-dfb7-4bc5-9fec-3e2a2d3219a6&quot;,&quot;x&quot;:1991.010600069691,&quot;y&quot;:-1629.5675587544767,&quot;html&quot;:&quot;函数执行&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[{&quot;html&quot;:&quot;1.形成一个全新的，私有的上下文EC(...)&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;27859533-85ab-45c2-9635-0fa167fe12d4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:23},{&quot;html&quot;:&quot;2.当前私有的上下文中，有一个存放本上下文内声明的变量的地方AO(...)</a><div>私有变量对象 -&gt; 这里的变量都是当前上下文内的私有变量(当前上下文中声明的变量，形参变量)</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”aeb76700-4daf-41bf-ad15-bd81f116a967”,”children”:[],”zIndex”:24},{“html”:”3.进栈执行”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”dba0e235-fbce-41f5-a599-f92fc2cdd99b”,”children”:[],”zIndex”:25},{“html”:”4.代码执行之前还要处理很多事情”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”3d19547f-97dd-4f3d-9e85-a27c668ace9e”,”children”:[{“html”:”1.初始化作用域链[scope-chain]: <div>&lt;当前自己的上下文，上级上下文(创建函数时形成的作用域)&gt;</div><div>&lt;span style=&quot;color:rgb(89, 89, 89);&quot;&gt;当前函数的上级上下文是创建函数所在的上下文（作用域）</span></div><div>&lt;span style=&quot;color:rgb(251, 50, 0);&quot;&gt;后期函数内代码执行，遇到一个变量，我们首先看是否为自己上下文中的私有变量（看 AO 中有没有），如果是私有的变量，则当前变量的操作和外界环境中的变量互不干扰（没有直接关系）；如果不是自己的私有变量，则按照作用域链，查找是否为其上级上下文中的私有变量…直到找到 EC(G)全局上下文为止 作用域链查找机制</span></div>“,”id”:”3192a6da-bc0c-4b2f-bd6a-60b80bf1e611”,”children”:[],”zIndex”:27},{“html”:”2.初始化 this…”,”id”:”fc880192-ab33-4a87-94e1-7496dea6d304”,”children”:[],”zIndex”:28},{“html”:”3.初始化 arguments…”,”id”:”af0e886b-2f8c-4fd8-9ff5-cdbb6b38ce37”,”children”:[],”zIndex”:29},{“html”:”4.形参赋值<div>形参都是私有变量（放到 AO 中的）</div><div>如果不传递实参值，默认值是 undefined</div>“,”id”:”356f8dcf-856c-469f-937d-feaebdc14b5b”,”children”:[],”zIndex”:30},{“html”:”5.变量提升”,”id”:”ede4a7ea-4ca1-40e4-82fa-fe18dad5266d”,”children”:[],”zIndex”:31}],”zIndex”:26},{“html”:”5.代码自上而下执行”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”97df9f13-b220-47dd-b944-78332dd062f7”,”children”:[],”zIndex”:32},{“html”:”6.一般情况下， 函数进栈执行的上下文，进栈执行完成后，会默认出栈释放掉（私有上下文中存储的私有变量和一些值都会被释放掉） -&gt; 目的：为了优化内存空间，减少栈内存的消耗，提高页面或者计算机的处理速度…”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”499021f1-ad43-47cf-b4fc-d7067ad68161”,”children”:[],”zIndex”:33}],”zIndex”:34},{“id”:”bbea95d2-e3d3-4e69-8a4c-86d3a5cd4247”,”x”:1963.3765434958004,”y”:82.81621411828132,”html”:”GC：游览器的垃圾回收机制（内存管理）”,”type”:”mindmap”,”children”:[{“html”:”谷歌：基于查找引用”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”c9e933a5-abac-4736-9646-4da6c8f7d331”,”children”:[],”zIndex”:38},{“html”:”游览器的渲染引擎会在空闲的时候（定期一个时间），依次遍历所有的内存：栈/堆”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”a552e576-57ab-4670-8cdd-2fd1f47182c8”,”children”:[],”zIndex”:35},{“html”:”堆：当前内存如果被占用（指针关联地址），则不能释放；如果没有任何的事物占用这个堆，则游览器会自动把这个堆内存释放掉。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”71b45608-3dd0-4147-ac2b-b543e5f7b8c4”,”children”:[],”zIndex”:36},{“html”:”栈：当前上下文中是否有内容（一般是堆内存）被上下文以外的事物所占用，如果被占用则无法释放（闭包），如果没有被占用则释放掉。&lt;span style=&quot;color:rgb(251, 50, 0);&quot;&gt;EC(G)是加载页面的时候创建，只有关闭页面的时候才会被释放。</span>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”83ab9934-e818-4905-a27b-4830dcf9f399”,”children”:[],”zIndex”:37},{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;主动释放：把占用的事物手动赋值为 null（其余的值也可以，但是 null 更好，null 不占空间的），可以实现内存的手动优化</span>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”7f65522e-b320-4d09-b515-d6946c6b49e5”,”children”:[],”zIndex”:39}],”zIndex”:40},{“id”:”cde09247-87b4-4213-8fda-abefc26c8ca4”,”x”:2917.6565158848593,”y”:69.40691075334075,”html”:”this”,”type”:”mindmap”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212); font-weight:bold;&quot;&gt;函数的执行主体</span>（不等价于执行上下文/作用域）：谁把这个函数执行的”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”b3412def-d12b-42b0-9e81-b06491748424”,”children”:[],”zIndex”:41},{“html”:”在游览器端运行 JS 代码，非函数中的 this 一般都是 window；研究 this 都是研究函数中的 this；有一个特殊的，就是 ES6+中“块级上下文”中的 this，是其所在上下文中的 this（理解为：块级上下文是没有自己 this 的）；”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”f4099a09-54c3-4ded-a4a4-cd92d7da35ce”,”children”:[],”zIndex”:42},{“html”:”想要分清楚函数执行的执行主体(this)，可以按照如下的规律来分析”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”6caf7a24-5eea-48ab-8863-5a4c7c5f12b5”,”children”:[{“html”:”事件绑定”,”id”:”5b615342-4631-45a0-8064-5fca2acb30a2”,”children”:[{“html”:”当前元素本身”,”id”:”d7a4240e-86ef-474b-90d7-5824fc7c3f47”,”children”:[],”zIndex”:49}],”zIndex”:44},{“html”:”普通函数执行”,”id”:”65a6d7ec-7d7c-48b7-bbbb-c0be86de1d6f”,”children”:[{“html”:”看函数前面是否有点，点前面是谁 this 就是谁”,”id”:”a3eda677-65f9-4afc-93ea-d977be9a4484”,”children”:[],”zIndex”:50},{“html”:”没有点就是 window/undefiend(严格模式)”,”id”:”5e8a148b-c639-49d9-93b4-59a428f64a06”,”children”:[],”zIndex”:51},{“html”:”自执行函数中的 this 一般都是 window/undefined(严格模式)”,”id”:”f45e3d01-1e3e-42af-82e8-187a938d4af5”,”children”:[],”zIndex”:52},{“html”:”回调函数中的 this 一般也是 window/undefined(严格模式)，除非做过特殊处理”,”id”:”d889cc4d-2c27-4f10-8ab8-3caff342b27b”,”children”:[],”zIndex”:53},{“html”:”&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;括号包起来的函数执行：</span><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;如果括号中只有一项，就相当于没有括号；</span></div><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;如果括号中有很多项，this 就是最后一项</span></div><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;     (obj.fn)() -&gt; obj</span></div><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;     (a, b, obj.fn)() -&gt; obj</span></div>“,”id”:”1862b77b-564c-4df1-841b-380e09d76cc6”,”children”:[],”zIndex”:54}],”zIndex”:45},{“html”:”构造函数执行”,”id”:”4ed6a01a-8c9c-4c9d-86ea-e5b460d27f93”,”children”:[{“html”:”所属类的实例”,”id”:”4eeacbf2-bb19-435d-b314-be1175456f54”,”children”:[],”zIndex”:56}],”zIndex”:46},{“html”:”箭头函数执行”,”id”:”ec859e1e-b16f-464f-bc42-c30fef007884”,”children”:[{“html”:”它的上级上下文”,”id”:”f41f3832-532e-4dec-997d-a29b355d8d89”,”children”:[],”zIndex”:55}],”zIndex”:47},{“html”:”基于 call/apply/bind 强制改变 this”,”id”:”9213fa2d-0097-4666-8672-ef4eaa5e0637”,”children”:[],”zIndex”:48}],”zIndex”:43}],”zIndex”:57},{“id”:”bb33ab1a-a703-4b16-9298-88e1c82463a8”,”x”:1952.0194459168001,”y”:714.3310716568769,”html”:”高阶编程技巧”,”type”:”mindmap”,”children”:[{“html”:”利用闭包的机制，实现出来的一些高阶编程方式”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”3bc71dce-2aa6-48fa-9edf-547ca5ecc3cd”,”children”:[],”zIndex”:58},{“html”:”高级单例设计模式”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”b1b99533-26bc-4bed-8fb6-93f8037976a3”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(251, 50, 0);&quot;&gt;早期的模块化设计思想</span>“,”id”:”a9c872d8-b357-418c-a123-7119cfea1f45”,”children”:[],”zIndex”:60},{“html”:”闭包+单例<div>一个对象就是一个单例模式<br></div>“,”id”:”09e4872d-3747-47f6-b2d5-32ddc61e3cfb”,”children”:[],”zIndex”:61},{“html”:”基于闭包的“保护作用”，防止了全局变量污染”,”id”:”bb674be6-14cf-4192-8396-742b230695da”,”children”:[],”zIndex”:62}],”zIndex”:59},{“html”:”惰性函数”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”a2524d75-2fa4-4645-ab8c-05a93f75b539”,”children”:[{“html”:”获取元素样式的小知识点”,”id”:”496afb35-356c-4cd0-b91c-e17ac07b2f60”,”children”:[{“html”:”1.dom.style<div>只有获取元素的内联样式</div>“,”id”:”74840378-e046-413e-953c-bcd7faaed8f2”,”children”:[],”zIndex”:65},{“html”:”2.getComputedStyle  IE6<del>8 不兼容<div>获取经过浏览器计算的样式（返回样式对象）</div>“,”id”:”701178cc-bce7-433b-9e36-3a5bd064adf3”,”children”:[],”zIndex”:66}],”zIndex”:64},{“html”:”&lt;span style=&quot;color:rgb(105, 177, 228);&quot;&gt;惰性思想</span>：干一次可以搞定的，绝对不去做第二次”,”id”:”8fb6e374-51db-40c0-9007-4731cdd6bfe7”,”children”:[],”zIndex”:67}],”zIndex”:63},{“html”:”函数柯理化”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”6e2cb5ea-036a-47c4-ac8e-5497b4abf02e”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;预先处理的思想</span><div>形成一个不被释放的闭包，把一些信息储存起来，以后基于作用域链，访问到事先储存的信息，然后进行相关的处理。</div>“,”id”:”de121d25-3528-4666-84c1-44fa43cc03e4”,”children”:[],”zIndex”:69},{“html”:”小知识点”,”id”:”8823ea03-34ee-4373-a13f-aaa02fdd9f42”,”children”:[{“html”:”命令式编程”,”id”:”6ba6485c-6b35-4cb8-90fd-643df71135f9”,”children”:[{“html”:”自己编写代码，管控运行的步骤和逻辑（自己可以灵活掌控执行步骤）”,”id”:”772eaa42-519d-477e-bfc2-669f4108e043”,”children”:[],”zIndex”:73}],”zIndex”:71},{“html”:”函数式编程”,”id”:”ee04ddc8-42f1-4a97-98a6-6006275cf5b3”,”children”:[{“html”:”具体实现的步骤已经被封装成方法，我们只需要调用方法获取结果即可，无需关注怎么实现的，用起来方便，代码量减少<div>弊端：灵活性差</div>“,”id”:”3c256491-3f2f-467e-9dea-de8ec44e6b82”,”children”:[],”zIndex”:74}],”zIndex”:72}],”zIndex”:70},{“html”:”currying”,”id”:”2c706054-c2cf-4a1b-8789-1b683fe2af8a”,”children”:[],”zIndex”:75},{“html”:”&lt;span style=&quot;font-weight:bold;&quot;&gt;compose</span>“,”id”:”65e45b73-c50e-4b6c-bc7e-3cb108c7662e”,”children”:[],”zIndex”:76}],”zIndex”:68}],”zIndex”:77},{“id”:”b98f60f5-dbe8-4268-84f4-155c3118e2b5”,”x”:2516.363393125918,”y”:-3481.224978713911,”html”:”数据类型转换”,”type”:”mindmap”,”children”:[{“html”:”其他类型转换为 Number”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”28fef53e-af7c-4747-bb67-d230b5282773”,”children”:[{“html”:”能用的办法”,”id”:”466f8305-e6c4-40da-8f93-9b658e6e28d5”,”children”:[{“html”:”parseInt/parseFloat([val])”,”layout”:{“quadrant”:1},”id”:”76e08162-00ef-4f04-a538-2dc3a55efb93”,”children”:[{“html”:”把要转换值先转换为字符串”,”id”:”1b8ab5a7-3a68-401c-b9ac-57d652886add”,”children”:[],”zIndex”:102},{“html”:”从字符串左侧的第一位开始查找有效数字字符，遇到非有效字符串则立即停止，最后把有效的数字字符串转为数字，如果没有则返回 NaN”,”id”:”564cda97-5817-4ade-b097-0b95e7498133”,”children”:[],”zIndex”:101}],”zIndex”:93},{“html”:”Number”,”layout”:{“quadrant”:1},”id”:”7ecf1da3-dbf0-41d4-b9c7-86badc9a62f1”,”children”:[{“html”:”只要出现非有效数字字符结果都是 NaN<div>Number(undefined) 是 NaN</div>“,”id”:”d3142c07-3700-4ea2-ab7d-80454189a4e9”,”children”:[],”zIndex”:99},{“html”:”对象转为数字，应该先 valueOf，没有原始值再 toString，最后再把字符串转为数字”,”id”:”2cf1b316-9527-4978-9eef-8de1450440db”,”children”:[],”zIndex”:100}],”zIndex”:94}],”zIndex”:92},{“html”:”隐式转换（游览器内部默认是先转换为 Number 再进行计算的）”,”id”:”624c0e8c-0710-4164-bf8b-92c448803fcc”,”children”:[{“html”:”isNaN([val])”,”id”:”48bd07bd-5a87-4d86-a940-27dee829fd48”,”children”:[],”zIndex”:96},{“html”:”数学运算”,”id”:”d73bf817-4c60-44af-9a70-4082d220eb0a”,”children”:[],”zIndex”:97},{“html”:”在==比较的时候（见== ：2.3）”,”id”:”7b0b5e99-cb8f-44f0-9f7b-29559c3b067f”,”children”:[],”zIndex”:98}],”zIndex”:95}],”zIndex”:91},{“html”:”其他类型转换为 Boolean”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”0db08cae-524b-453e-aa18-f86334d51f7a”,”children”:[{“html”:”只有“0、NaN、null、undefined、空字符串”五个值会变为布尔的 FALSE，其余都是 TRUE”,”id”:”98bd2b3d-fc29-4d68-8f0e-1daa67573970”,”children”:[],”zIndex”:79}],”zIndex”:78},{“html”:”其他类型转换为字符串”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”a0495c36-69de-4b76-a2f2-05735f90994b”,”children”:[{“html”:”1.一般都是直接“”包起来”,”id”:”6bbcb805-20b8-4881-b225-7f03b808ad19”,”children”:[],”zIndex”:89},{“html”:”2.只有{}普通对象 toString()是调取的&lt;span style=&quot;color:rgb(119, 195, 134);&quot;&gt;Object.prototype.toString()</span>，但它不是转换为字符串，而是&lt;span style=&quot;color:rgb(119, 195, 134);&quot;&gt;数据类型检测</span>，返回结果是[object Object]。（&lt;span style=&quot;color:rgb(119, 195, 134);&quot;&gt;其他对象也是可以调用的</span>）”,”id”:”29248173-b7d4-48f9-a477-c22f892f94a8”,”children”:[],”zIndex”:90}],”zIndex”:88},{“html”:”==”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”3a0ae834-99b4-4d65-b308-29a9f9d396e4”,”children”:[{“html”:”1.类型一样”,”id”:”0d83de72-b844-41cb-8ed4-b905b5e7ac6a”,”children”:[{“html”:”对象比较的是堆内存的地址”,”id”:”cb0f32b7-8ee0-4f53-844b-563ba4af1f8f”,”children”:[],”zIndex”:83},{“html”:”NaN == NaN  =&gt; false”,”id”:”0c07dbd7-8b9b-4f71-995d-e68cb0e8265b”,”children”:[],”zIndex”:84}],”zIndex”:81},{“html”:”2.类型不一样（会隐式转换为相同的数据类型）”,”id”:”783b255e-2264-4e1f-9135-26f9e717c368”,”children”:[{“html”:”1.null==undefined =&gt; true<div>但是换成===结果是 false（因为类型不一致）</div><div>剩下的 null/undefined 和其他任何数据类型值都不相等</div>“,”id”:”2014e91c-93da-4093-a4b2-06e6fb0392b7”,”children”:[],”zIndex”:85},{“html”:”2.字符串==对象   要把对象转换为字符串”,”id”:”0514b91b-c0e7-4b26-9999-578024efa867”,”children”:[],”zIndex”:86},{“html”:”3.剩下的如果==两边数据类型不一致，都是需要转换为 Number 再进行比较的”,”id”:”91ca760f-1084-41be-9a78-cfccef4a8e29”,”children”:[],”zIndex”:87}],”zIndex”:82}],”zIndex”:80}],”zIndex”:103},{“id”:”dd04bed1-67c3-41ca-b7ec-81e3e85752a0”,”x”:2014.1738538982459,”y”:-2910.0035004548354,”html”:”parseInt 的处理规则”,”type”:”mindmap”,”children”:[{“html”:”parseInt([value], [radix])”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”59868e0a-450b-4550-9d9c-b4102ebb61fe”,”children”:[],”zIndex”:104},{“html”:”radix 是一个进制，不写或者写 0 默认都按照 10 进制处理。<div>特殊情况：如果 value 是以 0x 开头，则默认值不是 10 而是 16</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”fa5efc41-dbc6-4d15-a0f5-12f0a671ac8a”,”children”:[],”zIndex”:105},{“html”:”radix 有取值范围：2 ～ 36。如果不在这个区间，则会返回 NaN。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”6de683ab-9dc0-4e95-a147-a740ce9985ab”,”children”:[],”zIndex”:106},{“html”:”作用：把[value]看作[radix]机制，最后把[radix]进制的值转换为十机制。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”1cc2600e-69b7-47ab-9364-dac8c9cf3299”,”children”:[],”zIndex”:107},{“html”:”执行过程：<div>1.从左向右开始查找[value]中的有效的[radix]进制值，遇到不是有效的立即停止；如果没有找到，则返回 NaN。</div><div>2.把查找到的结果转为数字，再把它作为[radix]进制转为十进制。</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”2899be55-c677-4828-9185-023cb9ffc7f4”,”children”:[],”zIndex”:110},{“html”:”小知识点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”ed6dfe5d-d14d-4e0e-b5a1-b3ad3dc15004”,”children”:[{“html”:”把一个任意进制的值转换为十进制值：<div>(每个位的数*进制^位权值)的和</div><div>位权值：个位从 0 开始，依次增 1；小数点后面的从-1 开始，依次减一。</div>“,”id”:”ada36261-f187-4582-854b-b1c80f6e5ecc”,”children”:[],”zIndex”:109}],”zIndex”:108}],”zIndex”:111},{“id”:”586fbcfd-1ba9-4b27-9e5f-05a2c4141ae1”,”x”:2867.8799493504434,”y”:-2914.512275969836,”html”:”变量提升的处理机制”,”type”:”mindmap”,”children”:[{“html”:”ES3+：在当前上下文中，JS 代码执行之前，浏览器会提前（词法解析的时候）把当前上下文中所有&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;带 var/function</span>关键字的进行提前的声明或者定义。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”bea45252-ed7b-4ef0-aa34-5c365b92a17f”,”children”:[],”zIndex”:112},{“html”:”带 var 声明的变量只提前声明不定义”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”80bb52ec-0274-4b57-bdb2-d8672450a41e”,”children”:[],”zIndex”:113},{“html”:”函数会提前声明和定义”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”3817f40f-3bdd-4100-8ada-24b38630b4d9”,”children”:[{“html”:”真实项目中建议用函数表达式创建函数，因为这样在变量提升阶段只会声明 function，更严谨。”,”id”:”b85b09ed-7429-4583-85d5-7ef6dc3f18e1”,”children”:[],”zIndex”:117},{“html”:”在使用函数表达式创建函数时，一般要把匿名函数具名化。<div>当函数执行，在形成的私有上下文中，会把这个具名化的名字作为变量，值就是这个函数来进行处理。这样做的好处是：&lt;span style=&quot;color:rgb(105, 177, 228);&quot;&gt;弥补了在严格模式下不能使用 argments.calle 调用当前函数。</span></div>“,”id”:”ad4c93ca-3165-4625-b3e4-685c8887deed”,”children”:[],”zIndex”:118}],”zIndex”:114},{“html”:”小知识点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”e1eff868-9732-417c-84e0-9fd855f74a84”,”children”:[{“html”:”1.基于“var 或 function”在“全局上下文”中声明的变量（全局变量）会映射到 GO（全局对象 window）上一份，作为它的属性；而且是同时修改的。”,”id”:”4ec71694-0351-4751-b574-34fe7b571446”,”children”:[],”zIndex”:116},{“html”:”<div>2.不论条件成立，都要进行变量提升<div>当条件中带有 var/function 时，</div></div><div>老版中会将函数提前声明并且定义</div><div>新版中只会将函数提前声明</div><div>var 也会提前声明不定义</div>“,”id”:”a599d7d9-4439-4a3b-b71d-2f76ed26c85c”,”children”:[],”zIndex”:119}],”zIndex”:115}],”zIndex”:120},{“id”:”1dca2046-8497-4f05-b115-81852f0b7fac”,”x”:3046.242779214603,”y”:-1647.7008922638222,”html”:”闭包”,”type”:”mindmap”,”children”:[{“html”:”1.函数运行的一种机制：形成一个不被释放的上下文”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”265c167d-a0dc-42c9-b4f6-5ec76d1bda90”,”children”:[],”zIndex”:121},{“html”:”2.函数执行会形成一个私有上下文 EC(FN)，如果上下文中的某些内容(一般指的是堆内存地址)被上下文以外的事物(例如：变量/事件绑定等)所占用，则当前上下文不能被出栈释放(浏览器的垃圾回收机制 GC 所决定的)”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”858dd510-bb77-4e40-891d-4543e5031ff9”,”children”:[],”zIndex”:122},{“html”:”特点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”af8477d5-4ebf-498f-87e7-9d4e574765e7”,”children”:[{“html”:”保护：保护私有上下文中的“私有变量”和外界互不影响”,”id”:”54f34d37-1785-4f9b-a05f-d4169e6ace5b”,”children”:[],”zIndex”:124},{“html”:”保存：上下文不被释放，那么上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用。”,”id”:”20380cab-e226-452f-aded-1f195727dcf5”,”children”:[],”zIndex”:125}],”zIndex”:123},{“html”:”弊端：如果大量使用闭包，会导致内存溢出或内存泄露。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”827aa6af-6e47-4ec9-a0d3-52764b48eaa3”,”children”:[],”zIndex”:126},{“html”:”应用场景”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”b46cbfda-ffd7-4ff0-8641-1e430f653486”,”children”:[{“html”:”1.循环事件绑定的 N 中解决办法”,”id”:”819a137a-9a3b-446f-b013-85fe69930b4a”,”children”:[{“html”:”1.利用闭包，创建私有上下文<div>性能不好</div>“,”id”:”153fdb2d-542e-4989-9b1f-d36498b940a3”,”children”:[{“html”:”自执行函数 function 包起来”,”id”:”8f6e67f1-0491-44f2-9188-a4e18e2721df”,”children”:[],”zIndex”:130},{“html”:”let”,”id”:”ce886cba-ba2c-4a85-9cd6-951884e9e0a7”,”children”:[],”zIndex”:131}],”zIndex”:129},{“html”:”2.自定义属性(与闭包无关)<div>性能好</div>“,”id”:”59bbd6b3-67f7-40dd-baa0-38bc1368d074”,”children”:[],”zIndex”:132},{“html”:”3.事件委托（它们都有一个共同的父元素，冒泡）<div>性能提升 40%～ 60%</div>“,”id”:”1c10e55e-cbc9-48b0-b865-d663b2f02159”,”children”:[],”zIndex”:133}],”zIndex”:128}],”zIndex”:127}],”zIndex”:134},{“id”:”6b5c2568-7f4e-458c-8a4e-4a6eb593dc1c”,”x”:1976.33793831011,”y”:-778.975022658044,”html”:”JS 中声明变量”,”type”:”mindmap”,”children”:[{“html”:”传统：var function”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”79f3c1d1-e2bb-4350-8adb-7dd486ce3000”,”children”:[{“html”:”带 var 的只是提前声明”,”id”:”44efc85a-7c90-4463-bb32-3e1cb5c1fec2”,”children”:[],”zIndex”:142},{“html”:”带 function 的是声明+定义”,”id”:”eff77c0d-9251-4126-ba0c-526ff0bd036d”,”children”:[],”zIndex”:143}],”zIndex”:135},{“html”:”ES6+”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”d0339732-669e-4979-a8eb-4e63b94a833e”,”children”:[{“html”:”ES5 - ES2011 <div>ES6 - ES2015 </div><div>ES2016 </div><div>ES2017 </div><div>…</div>“,”id”:”f7ebf72c-9b6a-4b39-a018-caaa30578fd9”,”children”:[],”zIndex”:138},{“html”:”let”,”id”:”8b58615c-51b7-481b-8b19-0fd6d0e99359”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;声明的变量可以改变引用指向</span>“,”id”:”d25f6d89-3223-48fb-871b-a0534862f5a8”,”children”:[],”zIndex”:139}],”zIndex”:137},{“html”:”const”,”id”:”4c97cef8-2c21-487f-a618-86b66e72d4b1”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;声明的变量不可以改变引用指向</span>，他声明的值叫常量”,”id”:”b75c0670-4aa5-401d-ba99-c433d751dd84”,”children”:[],”zIndex”:141}],”zIndex”:140}],”zIndex”:136},{“html”:”let VS var”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”9bdc1d9f-84f4-432a-bad3-ae0e855faf5a”,”children”:[{“html”:”1.var 存在变量提升，而 let 不存在”,”id”:”a54ea328-0408-4ead-8550-2e91fda0a894”,”children”:[],”zIndex”:145},{“html”:”&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;2.</span>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;【旧版】“全局上下文 EC(G)”中，基于 var/function 声明的变量，也相当于给 GO 全局对象(window)新增一个属性，并且任何一个发生值的改变，另一个也会跟着改变（映射机制）；</span><div>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;【新版】</span>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;“全局上下文 EC(G)”中，基于 var/function 声明的变量，只是给全局对象 GO 设置一个属性；</span>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;<br></span><div>&lt;span style=&quot;color:rgb(105, 177, 228);&quot;&gt;但是基于 lei 声明的变量，就是全局变量，和 GO 没有任何的关系。</span></div></div>“,”id”:”fa1140b4-9b3b-427a-979d-9e9468dd463a”,”children”:[{“html”:”没有基于任何关键词声明的变量，则相当于给全局对象设置一个属性”,”id”:”260a8569-e788-4e8e-bd3d-57769f47b5fc”,”children”:[],”zIndex”:147}],”zIndex”:146},{“html”:”3.在相同的上下文中，let 不允许重复声明，如果重复声明会报错(词法分析阶段)；而 var 可以重复声明，浏览器只按声明一次处理”,”id”:”ec9744ae-5847-4e74-944a-b2d9efc23767”,”children”:[],”zIndex”:148,”layout”:{“quadrant”:1}},{“html”:”&lt;span style=&quot;color:rgb(105, 177, 228); font-weight:bold;&quot;&gt;4.let/const/function 会产生块级私有上下文，而 var 是不会的</span>“,”id”:”a7f7fd3c-eb17-4bfc-96a8-dd4ac895b29a”,”children”:[],”zIndex”:153}],”zIndex”:144},{“html”:”小知识点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”99b5f488-cb43-482f-aeb7-1ca4971c736f”,”children”:[{“html”:”词法分析：浏览在执行代码之前，会先把代码解析为浏览器能识别的事物”,”id”:”c3395f6b-239b-4543-a913-e39d51a9047a”,”children”:[],”zIndex”:150},{“html”:”暂时性死区（浏览器暂存的 BUG）”,”id”:”1b8ab318-1a57-4931-80a9-ba43545b266b”,”children”:[{“html”:”1.基于 typeof 检测一个未被声明的变量，不会报错，结果是 undefined”,”id”:”e0e9bbe0-9a2a-461c-bb38-f344dbffc213”,”children”:[],”zIndex”:152}],”zIndex”:151},{“html”:”上下文 &amp; 作用域”,”id”:”259b605d-7f32-468f-af9b-dc230c4d71a3”,”children”:[{“html”:”全局上下文”,”id”:”60fe1681-c8d2-4032-8e05-146e49efa764”,”children”:[],”zIndex”:155},{“html”:”函数执行形成的“私有上下文””,”id”:”8ad7ba5d-dc97-4fe9-a512-3d7b7d43772a”,”children”:[],”zIndex”:156},{“html”:”块级作用域（块级私有上下文）”,”id”:”33fb2c1b-cc40-4c65-87b9-339e88247ca3”,”children”:[{“html”:”除了对象、函数等的大括号除外（例如：判断体、循环体、代码块…）都有可能会产生块级上下文”,”id”:”d7365bba-ac65-47d5-92f3-5fdf50471eee”,”children”:[],”zIndex”:158}],”zIndex”:157}],”zIndex”:154}],”zIndex”:149}],”zIndex”:159},{“id”:”2b6647d5-7501-40c7-b24a-2af42d4f1d80”,”x”:3224.4260039219885,”y”:-752.6815219819359,”html”:”块级上下文”,”type”:”mindmap”,”children”:[{“html”:”除函数/对象的大括号外，在其他的大括号中出现 let/const/function 则会单独形成块级私有上下文”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”2463084f-5d6f-4afc-81c9-48c143726c2f”,”children”:[],”zIndex”:160}],”zIndex”:161},{“id”:”97ab8408-d69f-4080-ac0f-3eaaa781ae45”,”x”:3223.5822818981683,”y”:-598.6400544426056,”html”:”函数形参默认值”,”type”:”mindmap”,”children”:[{“html”:”如果函数应用了形参默认值，并且在函数体中出现了基于 var/let/const 声明变量的方式，这样除了函数执行，会产生一个私有的上下文之外，还会把函数体及其中的代码当做一个全新的块级上下文。如果这个块级上下文中的变量和函数私有上下文中的变量一致了，则会在块级上下文初始化之前，会把形参变量的值同步给块级上下文中的变量”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”9c8f2b7e-56c2-47a1-b9df-e85c35da883e”,”children”:[],”zIndex”:162}],”zIndex”:163},{“id”:”d5954e00-aacc-43cc-9eb2-c6294ca7aa46”,”x”:2013.3631825544453,”y”:-4147.225387630226,”html”:”闭包剧本 🌟”,”type”:”mindmap”,”children”:[{“html”:”引言：就像人需要氧气才能生存，闭包也需要在特定的环境下才能存在，闭包携带了它自己的“氧气罐”（引用了当前作用域以外的其他作用域上下文），所以它才存活下来（使上下文不会消失）。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”fcdf01ae-8066-4dbe-a424-c00f59dc280a”,”children”:[],”zIndex”:175},{“html”:”基本介绍: ECStack、EC、VO、AO、GO、SCOPE、SCOPE-CHAIN、GC”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”60b7c46c-ca7f-4b3f-9396-2db05c8e1e5e”,”children”:[],”zIndex”:164},{“html”:”优缺点：保存和保护、性能消耗（内存泄漏）”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”cb29cf10-c1b0-487b-bb90-93af243dde80”,”children”:[],”zIndex”:165},{“html”:”实战应用”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”8587ed97-be45-46bc-bd35-8f9d9dbbe64d”,”children”:[{“html”:”项目实战应用：循环事件绑定(突出：事件委托)、let 和 var”,”id”:”69d08b2c-6ab1-4a9f-bade-bf8efb909bf0”,”children”:[],”zIndex”:167},{“html”:”插件组件应用：JS 高阶编程技巧(单例设计模式、惰性函数、柯理化函数、compose 组合函数)”,”id”:”efaa7f8c-3eeb-49f1-84bb-a88b621ba442”,”children”:[],”zIndex”:168},{“html”:”源码阅读应用：Lodash 源码(函数的防抖和节流)、JQ 的源码、redux、react-redux(高阶组件)…”,”id”:”6112fd30-eb39-4da2-8ee3-a4d4baee36b3”,”children”:[],”zIndex”:169},{“html”:”…”,”id”:”c0812e77-5a30-4ab8-b565-ebb7d6253ac9”,”children”:[],”zIndex”:170}],”zIndex”:166},{“html”:”自己的思想和理解(一句话概括)”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”5afc0a83-0a2b-4cdd-b605-a16141839cba”,”children”:[{“html”:”其实我觉得闭包这个东西还是很重要的”,”id”:”d7e2dffd-8111-4ecd-b022-83b31b0e2905”,”children”:[],”zIndex”:172}],”zIndex”:171},{“html”:”小技巧”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”89d878f9-c202-4d02-b648-3a3b62c6772b”,”children”:[{“html”:”担心自己表达能力：可以自己写一遍文章，详细的介绍闭包（面试的时候，给面试官看，它边看你边简单说一些）”,”id”:”9428a725-67c5-40f8-9f24-aba604e164b2”,”children”:[],”zIndex”:174}],”zIndex”:173}],”zIndex”:176,”tapered”:false},{“id”:”6c0e58ca-1a82-4e47-949e-087c354b99ad”,”x”:2894.570608794177,”y”:-4162.194456348563,”html”:”简述 let 和 var 的区别”,”type”:”mindmap”,”zIndex”:177}]},”viewportSetting”:{“zoom”:0.9529882937207227,”tlCanvasPoint”:[1970.3826987555492,-4590.259820030305,1],”width”:1040,”height”:898},”text”:”数据类型基本类型 numberstringundefinednullbooleansymbol 引用类型 objectarray…functionJS 代码执行 1.游览器会在内存中开辟一块栈内存，全局上下文（环境），也叫 ECStack。2.然后形成全局执行上下文 EC(G)（默认就是 window/global）供代码执行。创建函数 1.单独开辟一个堆内存（16 进制地址），函数堆内存中存储的是函数体中的“代码字符串”。2.创建函数的时候，就声明了它的作用域[scope]，也就是所在的上下文环境。3.把 16 进制的地址存放到栈中，供变量（函数名等）关联引用即可函数执行 1.形成一个全新的，私有的上下文 EC(…)2.当前私有的上下文中，有一个存放本上下文内声明的变量的地方 AO(…)私有变量对象 -&gt; 这里的变量都是当前上下文内的私有变量(当前上下文中声明的变量，形参变量)3.进栈执行 4.代码执行之前还要处理很多事情 1.初始化作用域链[scope-chain]: &lt;当前自己的上下文，上级上下文(创建函数时形成的作用域)&gt;当前函数的上级上下文是创建函数所在的上下文（作用域）后期函数内代码执行，遇到一个变量，我们首先看是否为自己上下文中的私有变量（看 AO 中有没有），如果是私有的变量，则当前变量的操作和外界环境中的变量互不干扰（没有直接关系）；如果不是自己的私有变量，则按照作用域链，查找是否为其上级上下文中的私有变量…直到找到 EC(G)全局上下文为止 作用域链查找机制 2.初始化 this…3.初始化 arguments…4.形参赋值形参都是私有变量（放到 AO 中的）如果不传递实参值，默认值是 undefined5.变量提升 5.代码自上而下执行 6.一般情况下， 函数进栈执行的上下文，进栈执行完成后，会默认出栈释放掉（私有上下文中存储的私有变量和一些值都会被释放掉） -&gt; 目的：为了优化内存空间，减少栈内存的消耗，提高页面或者计算机的处理速度…GC：游览器的垃圾回收机制（内存管理）谷歌：基于查找引用游览器的渲染引擎会在空闲的时候（定期一个时间），依次遍历所有的内存：栈/堆堆：当前内存如果被占用（指针关联地址），则不能释放；如果没有任何的事物占用这个堆，则游览器会自动把这个堆内存释放掉。栈：当前上下文中是否有内容（一般是堆内存）被上下文以外的事物所占用，如果被占用则无法释放（闭包），如果没有被占用则释放掉。EC(G)是加载页面的时候创建，只有关闭页面的时候才会被释放。主动释放：把占用的事物手动赋值为 null（其余的值也可以，但是 null 更好，null 不占空间的），可以实现内存的手动优化 this 函数的执行主体（不等价于执行上下文/作用域）：谁把这个函数执行的在游览器端运行 JS 代码，非函数中的 this 一般都是 window；研究 this 都是研究函数中的 this；有一个特殊的，就是 ES6+中“块级上下文”中的 this，是其所在上下文中的 this（理解为：块级上下文是没有自己 this 的）；想要分清楚函数执行的执行主体(this)，可以按照如下的规律来分析事件绑定当前元素本身普通函数执行看函数前面是否有点，点前面是谁 this 就是谁没有点就是 window/undefiend(严格模式)自执行函数中的 this 一般都是 window/undefined(严格模式)回调函数中的 this 一般也是 window/undefined(严格模式)，除非做过特殊处理括号包起来的函数执行：如果括号中只有一项，就相当于没有括号；如果括号中有很多项，this 就是最后一项      (obj.fn)() -&gt; obj     (a, b, obj.fn)() -&gt; obj 构造函数执行所属类的实例箭头函数执行它的上级上下文基于 call/apply/bind 强制改变 this 高阶编程技巧利用闭包的机制，实现出来的一些高阶编程方式高级单例设计模式早期的模块化设计思想闭包+单例一个对象就是一个单例模式基于闭包的“保护作用”，防止了全局变量污染惰性函数获取元素样式的小知识点 1.dom.style 只有获取元素的内联样式 2.getComputedStyle  IE6</del>8 不兼容获取经过浏览器计算的样式（返回样式对象）惰性思想：干一次可以搞定的，绝对不去做第二次函数柯理化预先处理的思想形成一个不被释放的闭包，把一些信息储存起来，以后基于作用域链，访问到事先储存的信息，然后进行相关的处理。小知识点命令式编程自己编写代码，管控运行的步骤和逻辑（自己可以灵活掌控执行步骤）函数式编程具体实现的步骤已经被封装成方法，我们只需要调用方法获取结果即可，无需关注怎么实现的，用起来方便，代码量减少弊端：灵活性差 curryingcompose 数据类型转换其他类型转换为 Number 能用的办法 parseInt/parseFloat([val])把要转换值先转换为字符串从字符串左侧的第一位开始查找有效数字字符，遇到非有效字符串则立即停止，最后把有效的数字字符串转为数字，如果没有则返回 NaNNumber 只要出现非有效数字字符结果都是 NaNNumber(undefined) 是 NaN 对象转为数字，应该先 valueOf，没有原始值再 toString，最后再把字符串转为数字隐式转换（游览器内部默认是先转换为 Number 再进行计算的）isNaN([val])数学运算在==比较的时候（见== ：2.3）其他类型转换为 Boolean 只有“0、NaN、null、undefined、空字符串”五个值会变为布尔的 FALSE，其余都是 TRUE 其他类型转换为字符串 1.一般都是直接“”包起来 2.只有{}普通对象 toString()是调取的 Object.prototype.toString()，但它不是转换为字符串，而是数据类型检测，返回结果是[object Object]。（其他对象也是可以调用的）==1.类型一样对象比较的是堆内存的地址 NaN == NaN  =&gt; false2.类型不一样（会隐式转换为相同的数据类型）1.null==undefined =&gt; true 但是换成===结果是 false（因为类型不一致）剩下的 null/undefined 和其他任何数据类型值都不相等 2.字符串==对象   要把对象转换为字符串 3.剩下的如果==两边数据类型不一致，都是需要转换为 Number 再进行比较的 parseInt 的处理规则 parseInt([value], [radix])radix 是一个进制，不写或者写 0 默认都按照 10 进制处理。特殊情况：如果 value 是以 0x 开头，则默认值不是 10 而是 16radix 有取值范围：2 ～ 36。如果不在这个区间，则会返回 NaN。作用：把[value]看作[radix]机制，最后把[radix]进制的值转换为十机制。执行过程：1.从左向右开始查找[value]中的有效的[radix]进制值，遇到不是有效的立即停止；如果没有找到，则返回 NaN。2.把查找到的结果转为数字，再把它作为[radix]进制转为十进制。小知识点把一个任意进制的值转换为十进制值：(每个位的数*进制^位权值)的和位权值：个位从 0 开始，依次增 1；小数点后面的从-1 开始，依次减一。变量提升的处理机制 ES3+：在当前上下文中，JS 代码执行之前，浏览器会提前（词法解析的时候）把当前上下文中所有带 var/function 关键字的进行提前的声明或者定义。带 var 声明的变量只提前声明不定义函数会提前声明和定义真实项目中建议用函数表达式创建函数，因为这样在变量提升阶段只会声明 function，更严谨。在使用函数表达式创建函数时，一般要把匿名函数具名化。当函数执行，在形成的私有上下文中，会把这个具名化的名字作为变量，值就是这个函数来进行处理。这样做的好处是：弥补了在严格模式下不能使用 argments.calle 调用当前函数。小知识点 1.基于“var 或 function”在“全局上下文”中声明的变量（全局变量）会映射到 GO（全局对象 window）上一份，作为它的属性；而且是同时修改的。2.不论条件成立，都要进行变量提升当条件中带有 var/function 时，老版中会将函数提前声明并且定义新版中只会将函数提前声明 var 也会提前声明不定义闭包 1.函数运行的一种机制：形成一个不被释放的上下文 2.函数执行会形成一个私有上下文 EC(FN)，如果上下文中的某些内容(一般指的是堆内存地址)被上下文以外的事物(例如：变量/事件绑定等)所占用，则当前上下文不能被出栈释放(浏览器的垃圾回收机制 GC 所决定的)特点保护：保护私有上下文中的“私有变量”和外界互不影响保存：上下文不被释放，那么上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用。弊端：如果大量使用闭包，会导致内存溢出或内存泄露。应用场景 1.循环事件绑定的 N 中解决办法 1.利用闭包，创建私有上下文性能不好自执行函数 function 包起来 let2.自定义属性(与闭包无关)性能好 3.事件委托（它们都有一个共同的父元素，冒泡）性能提升 40%～ 60%JS 中声明变量传统：var function 带 var 的只是提前声明带 function 的是声明+定义 ES6+ES5 - ES2011 ES6 - ES2015 ES2016 ES2017 …let 声明的变量可以改变引用指向 const 声明的变量不可以改变引用指向，他声明的值叫常量 let VS var1.var 存在变量提升，而 let 不存在 2.【旧版】“全局上下文 EC(G)”中，基于 var/function 声明的变量，也相当于给 GO 全局对象(window)新增一个属性，并且任何一个发生值的改变，另一个也会跟着改变（映射机制）；【新版】“全局上下文 EC(G)”中，基于 var/function 声明的变量，只是给全局对象 GO 设置一个属性；但是基于 lei 声明的变量，就是全局变量，和 GO 没有任何的关系。没有基于任何关键词声明的变量，则相当于给全局对象设置一个属性 3.在相同的上下文中，let 不允许重复声明，如果重复声明会报错(词法分析阶段)；而 var 可以重复声明，浏览器只按声明一次处理 4.let/const/function 会产生块级私有上下文，而 var 是不会的小知识点词法分析：浏览在执行代码之前，会先把代码解析为浏览器能识别的事物暂时性死区（浏览器暂存的 BUG）1.基于 typeof 检测一个未被声明的变量，不会报错，结果是 undefined 上下文 &amp; 作用域全局上下文函数执行形成的“私有上下文”块级作用域（块级私有上下文）除了对象、函数等的大括号除外（例如：判断体、循环体、代码块…）都有可能会产生块级上下文块级上下文除函数/对象的大括号外，在其他的大括号中出现 let/const/function 则会单独形成块级私有上下文函数形参默认值如果函数应用了形参默认值，并且在函数体中出现了基于 var/let/const 声明变量的方式，这样除了函数执行，会产生一个私有的上下文之外，还会把函数体及其中的代码当做一个全新的块级上下文。如果这个块级上下文中的变量和函数私有上下文中的变量一致了，则会在块级上下文初始化之前，会把形参变量的值同步给块级上下文中的变量闭包剧本 🌟 引言：就像人需要氧气才能生存，闭包也需要在特定的环境下才能存在，闭包携带了它自己的“氧气罐”（引用了当前作用域以外的其他作用域上下文），所以它才存活下来（使上下文不会消失）。基本介绍: ECStack、EC、VO、AO、GO、SCOPE、SCOPE-CHAIN、GC 优缺点：保存和保护、性能消耗（内存泄漏）实战应用项目实战应用：循环事件绑定(突出：事件委托)、let 和 var 插件组件应用：JS 高阶编程技巧(单例设计模式、惰性函数、柯理化函数、compose 组合函数)源码阅读应用：Lodash 源码(函数的防抖和节流)、JQ 的源码、redux、react-redux(高阶组件)……自己的思想和理解(一句话概括)其实我觉得闭包这个东西还是很重要的小技巧担心自己表达能力：可以自己写一遍文章，详细的介绍闭包（面试的时候，给面试官看，它边看你边简单说一些）简述 let 和 var 的区别”}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>未来的路</title>
      <link href="/2020/06/02/yuque/%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%B7%AF/"/>
      <url>/2020/06/02/yuque/%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><div class="story post-story"><ol><li>先达到 P6 再考虑其他岗位</li><li>根据自己的喜欢选择 P6 之后要做什么</li><li>先长高、再长胖、最后锻炼为型男。</li><li>读书、读书、读书、读书，目的：锻炼学习能力。</li><li>不要写中规中矩的简历，要按照一定的维度写。只要简历写的好，面试基本上都会过。</li><li>自我介绍不要打磕。</li><li>面试是场修行，是在任何地方都学不到的。</li><li>面试十家左右，即使不去。</li><li>以面养面，做好面试总结。</li><li>面试录音，写成文字稿，重新规划话术。</li><li>今日事今日毕。</li><li>把自己当作一个导演，把面试问答写成剧本，背下来！</li><li>携带自己的思想、见解、经验。</li><li>把每一次面试当做一次演讲。</li><li>任何事情都有三种解决办法，只要心态好。</li></ol></div><h2 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h2><div class="story post-story"><ol><li>不要说上家公司的坏话。</li></ol></div><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><div class="story post-story"><ol><li>温故而知新，可以为师矣a. 养成写笔记、写博客的习惯b. 经常复习之前的内容c. 养成项目总结的习惯</li><li>多练习：敲代码的数量和薪资成正比</li><li>多思考：学而不思则罔、思而不学则殆</li><li>纵向横向发展a. 知其然而知其所以然b. 研究源码c. 多参与开源和讨论d. 多接触一些非技术类的东西</li></ol></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
