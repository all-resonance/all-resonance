<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>All Resonance</title>
  
  <subtitle>夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远～</subtitle>
  <link href="https://resonance.fun/atom.xml" rel="self"/>
  
  <link href="https://resonance.fun/"/>
  <updated>2022-06-28T21:13:34.065Z</updated>
  <id>https://resonance.fun/</id>
  
  <author>
    <name>all-resonance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React之基础知识</title>
    <link href="https://resonance.fun/2022/04/06/yuque/React%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://resonance.fun/2022/04/06/yuque/React%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-06T05:57:26.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript之基础知识</title>
    <link href="https://resonance.fun/2022/04/01/yuque/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://resonance.fun/2022/04/01/yuque/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-01T09:53:57.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS-事件循环"><a href="#JS-事件循环" class="headerlink" title="JS 事件循环"></a>JS 事件循环</h2><div class="story post-story"><p>JavaScript 语言是一门<strong>单线程</strong>的<strong>非阻塞</strong>的脚本语言。</p><h3 id="为什么-JS-是一门单线程的语言？"><a href="#为什么-JS-是一门单线程的语言？" class="headerlink" title="为什么 JS 是一门单线程的语言？"></a>为什么 JS 是一门单线程的语言？</h3><p>因为在浏览器中，需要对各种的 DOM 操作。当 JS 是多线程的话，如果有两个线程同时对同一个 DOM 进行操作，一个是在这个 DOM 上绑定事件，另外一个是删除该 DOM，此时就会产生歧义。因此为了保证这种事情不会发生，所以 JS 以单线程来执行代码，保证了一致性。</p><h3 id="JS-非阻塞应该如何理解？"><a href="#JS-非阻塞应该如何理解？" class="headerlink" title="JS 非阻塞应该如何理解？"></a>JS 非阻塞应该如何理解？</h3><p>当 JS 代码从上往下执行，遇到需要进行一项异步任务的时候，主线程会挂起这个任务，继续往下执行代码，然后在异步任务返回结果的时候再根据一定规则去执行。</p><h3 id="非阻塞是如何实现的呢？"><a href="#非阻塞是如何实现的呢？" class="headerlink" title="非阻塞是如何实现的呢？"></a>非阻塞是如何实现的呢？</h3><p>非阻塞需要用到事件循环（event loop）</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;首次同步任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务（宏任务）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout 1&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Promise1&quot;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Promise then 1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;首次同步任务结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务（微任务）</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise2&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise then 2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>异步任务分类：宏任务（setTimeout），微任务（promise）。</li><li>所有同步任务都在主线程上执行，形成一个执行栈。</li><li>遇到异步任务放到任务表中，等事件执行完成（ajax 请求完成、setTimeout 设置时间到期），之后放入到任务队列。</li><li>当执行栈的同步任务执行完成之后，就会执行任务队列的第一个异步任务，其中把宏观任务和微观任务都执行完成后才进行下一次循环（先从微任务队列中取出微任务执行，微任务没有了再从宏任务队列中取出宏任务执行）。</li></ul></div><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><div class="story post-story"><p>深浅拷贝都是针对复杂类型数据才有的概念，基本类型数据不具备。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>两个引用类型指向同一个地址，改变一个，另一个也会随之改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123; <span class="attr">num</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> d = c;</span><br><span class="line">c.num = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;c:&quot;</span>, c, <span class="string">&quot;d:&quot;</span>, d);</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>复制后引用类型指向一个新的内存地址，两个对象改变互不影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123; <span class="attr">num</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(c));</span><br><span class="line">c.num = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;c:&quot;</span>, c, <span class="string">&quot;d:&quot;</span>, d);</span><br></pre></td></tr></table></figure><h3 id="连环问"><a href="#连环问" class="headerlink" title="连环问"></a>连环问</h3><h4 id="基本类型数据的赋值是浅拷贝还是深拷贝？"><a href="#基本类型数据的赋值是浅拷贝还是深拷贝？" class="headerlink" title="基本类型数据的赋值是浅拷贝还是深拷贝？"></a>基本类型数据的赋值是浅拷贝还是深拷贝？</h4><p>赋值既不是深拷贝也不是浅拷贝，只是跟深拷贝是类似</p><h4 id="数组的方法：concat、slice-是浅拷贝还是深拷贝？"><a href="#数组的方法：concat、slice-是浅拷贝还是深拷贝？" class="headerlink" title="数组的方法：concat、slice 是浅拷贝还是深拷贝？"></a>数组的方法：concat、slice 是浅拷贝还是深拷贝？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat、slice对一维数组来说是深拷贝，多维数组的话是浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> ab = a.concat(b);</span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ab);</span><br></pre></td></tr></table></figure></div><h2 id="关键字-new-的作用"><a href="#关键字-new-的作用" class="headerlink" title="关键字 new 的作用"></a>关键字 new 的作用</h2><div class="story post-story"><h3 id="当没使用-new-关键字，直接调用构造函数时"><a href="#当没使用-new-关键字，直接调用构造函数时" class="headerlink" title="当没使用 new 关键字，直接调用构造函数时"></a>当没使用 new 关键字，直接调用构造函数时</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数内部的this指向的是window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = obj.name;</span><br><span class="line">  <span class="built_in">this</span>.score = obj.score;</span><br><span class="line">  <span class="built_in">this</span>.grade = obj.grade;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = Student(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="attr">score</span>: <span class="number">88</span>,</span><br><span class="line">  <span class="attr">grade</span>: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(stu1); <span class="comment">// window 并且给window添加了属性</span></span><br></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol><li>创建一个新的空对象</li><li>将构造函数的作用域赋值给新对象(this 指向新对象)</li><li>执行构造函数代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this=&#123;&#125;;</span></span><br><span class="line">  <span class="built_in">this</span>.name = obj.name;</span><br><span class="line">  <span class="built_in">this</span>.score = obj.score;</span><br><span class="line">  <span class="built_in">this</span>.grade = obj.grade;</span><br><span class="line">  <span class="comment">// return this;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Student(&#123; <span class="attr">name</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">score</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">grade</span>: <span class="string">&quot;3&quot;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></div><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><div class="story post-story"><h3 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（<code>prototype</code>）</h3><p>是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;大钊&quot;</span>;</span><br><span class="line">Person.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">11</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name);</span><br><span class="line">person1.a();</span><br></pre></td></tr></table></figure><h4 id="函数对象才有prototype属性。"><a href="#函数对象才有prototype属性。" class="headerlink" title="函数对象才有prototype属性。"></a>函数对象才有<code>prototype</code>属性。</h4><h4 id="Object和Function是两大基类。"><a href="#Object和Function是两大基类。" class="headerlink" title="Object和Function是两大基类。"></a><code>Object</code>和<code>Function</code>是两大基类。</h4><ul><li><code>Object.__proto__ === Function.__proto__</code></li><li><code>Function.__proto__.__proto__ === Object.prototype</code></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>构造函数实例化出来的对象可以使用公共的属性或者方法</li></ul><h3 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h3><ul><li>js ⾥万物皆对象，所以⼀直访问<code>__proto__</code>属性就会产⽣⼀条链条</li><li>链条的尽头是 null  (Object.prototype.<code>__proto__</code>)</li><li>当 js 引擎查找对象的属性时，会先判断对象本身是否存在该属性</li><li>不存在的属性就会沿着原型链往上找</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Car.prototype.name = <span class="string">&quot;大钊&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>原型主要是解决继承问题</li><li>每个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向其原型对象，并从中继承方法和属性</li><li>同时原型对象也可能拥有原型，这样一层一层，最终指向 null（Object.proptotype.proto 指向的是 null）</li><li>上述的关系被称为原型链，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li></ul></div><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><div class="story post-story"><h3 id="一个计数器，这也是一个闭包"><a href="#一个计数器，这也是一个闭包" class="headerlink" title="一个计数器，这也是一个闭包"></a>一个计数器，这也是一个闭包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化计数器</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递增计数器的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调⽤三次 add()</span></span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br></pre></td></tr></table></figure><h3 id="典型闭包使用场景"><a href="#典型闭包使用场景" class="headerlink" title="典型闭包使用场景"></a>典型闭包使用场景</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">adds</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调⽤三次 add()</span></span><br><span class="line"><span class="keyword">const</span> xd = add();</span><br><span class="line">xd();</span><br><span class="line">xd();</span><br><span class="line">xd();</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>闭包是当前函数上下文引用了其他上下文中的变量，导致函数上下文不能出栈。</li><li>被引用的变量所在上下文在垃圾回收机制中不会被回收</li><li>闭包具有保护保存的作用</li></ul></div><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a><strong>执行上下文</strong></h2><div class="story post-story"><p>JS 代码被解析和执行时存在的环境（ECMAscript 中定义的抽象概念）。</p><h3 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h3><p>声明在全局下的变量和函数所处的环境</p><h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><p>函数每次被调用都会创建新的执行上下文，可以存在任意数量的函数执行上下文</p><h3 id="eval函数执行上下文"><a href="#eval函数执行上下文" class="headerlink" title="eval函数执行上下文"></a><code>eval</code>函数执行上下文</h3><p>运行在 eval 函数中的执行上下文（用不到不做讨论）</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li>创建变量对象：初始化参数、提升函数声明和变量声明<ul><li>源代码</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码执行</span></span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="string">&quot;你好世界！&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>编译后的代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line">hello = <span class="string">&quot;你好世界！&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><ul><li>进栈、代码自上而下执行<ul><li>变量赋值</li><li>确定<code>this</code>指向</li></ul></li></ul><h4 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h4><ul><li>执行上下文出栈，js 自动执行垃圾回收机制。</li></ul></div><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><div class="story post-story"><p>可访问变量，对象，函数的集合。创建函数的时候就声明了它的<code>[[scope]]</code>(作用域)</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>全局变量定义在函数外部，具有全局作用域。</p><h3 id="函数作用域（局部作用域）"><a href="#函数作用域（局部作用域）" class="headerlink" title="函数作用域（局部作用域）"></a>函数作用域（局部作用域）</h3><p>局部变量定义在函数内部，具有局部作用域。</p><h3 id="块级作用域（ES6-的let、const）"><a href="#块级作用域（ES6-的let、const）" class="headerlink" title="块级作用域（ES6 的let、const）"></a>块级作用域（ES6 的<code>let</code>、<code>const</code>）</h3><p>在 <code>&#123;&#125;</code> 中使用<code>ES6</code>的<code>let</code>、<code>const</code>方式声明，具有块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;a函数变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&quot;b函数变量&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;全局变量&quot;</span>;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure><h4 id="执行上下文和作用域有什么区别？"><a href="#执行上下文和作用域有什么区别？" class="headerlink" title="执行上下文和作用域有什么区别？"></a>执行上下文和作用域有什么区别？</h4><ul><li>函数定义时，作用域就已经确认了，每次函数调用时与变量的访问有关， 并且每次调用都是独立的</li><li>而执行上下文主要是关键字<code>this</code>的值，这个是由函数运行时决定的，简单来说就是谁调用此函数，<code>this</code>就指向谁。</li></ul></div><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a><code>call</code>/<code>apply</code>/<code>bind</code></h2><div class="story post-story"><p>三个方法都是改变 this 指向的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="string">&quot;18&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">  <span class="attr">fun</span>: <span class="function"><span class="keyword">function</span> (<span class="params">sex, hobby</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">&quot;名字:&quot;</span> +</span><br><span class="line">        <span class="built_in">this</span>.name +</span><br><span class="line">        <span class="string">&quot; 年龄:&quot;</span> +</span><br><span class="line">        <span class="built_in">this</span>.age +</span><br><span class="line">        <span class="string">&quot; 性别:&quot;</span> +</span><br><span class="line">        sex +</span><br><span class="line">        <span class="string">&quot; 爱好:&quot;</span> +</span><br><span class="line">        hobby</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&quot;19&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.fun.call(obj2, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;敲代码&quot;</span>); <span class="comment">// 名字:王五 年龄:19 性别:男 爱好:敲代码</span></span><br><span class="line">obj1.fun.apply(obj2, [<span class="string">&quot;男&quot;</span>, <span class="string">&quot;敲代码&quot;</span>]); <span class="comment">// 名字:王五 年龄:19 性别:男 爱好:敲代码</span></span><br><span class="line">obj1.fun.bind(obj2, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;敲代码&quot;</span>)(); <span class="comment">// 名字:王五 年龄:19 性别:男 爱好:敲代码</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>整理中…</p></div><h2 id="JS-回调地狱"><a href="#JS-回调地狱" class="headerlink" title="JS 回调地狱"></a>JS 回调地狱</h2><div class="story post-story"><p>为了实现某些逻辑会写出层层嵌套的回调函数，嵌套过多会影响代码的可读性和逻辑，当某个请求失败时难以定位问题，这情况被称为回调地狱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  axios.get(<span class="string">&quot;./mock/data_a.json&quot;</span>).then(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1.data.code);</span><br><span class="line">    axios.get(<span class="string">&quot;./mock/data_b.json&quot;</span>).then(<span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res2.data.code);</span><br><span class="line">      axios.get(<span class="string">&quot;./mock/data_c.json&quot;</span>).then(<span class="function">(<span class="params">res3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res3.data.code);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="通过promise解决"><a href="#通过promise解决" class="headerlink" title="通过promise解决"></a>通过<code>promise</code>解决</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData1</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.get(url).then(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res1.data.code &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        resolve(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_a.json&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_b.json&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_c.json&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all / Promise.race"></a><code>Promise.all</code> / <code>Promise.race</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData1</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.get(url).then(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// if (res1.data.code &lt;= 1) &#123;</span></span><br><span class="line">      resolve(res1.data.code);</span><br><span class="line">      <span class="comment">// &#125; else &#123;</span></span><br><span class="line">      <span class="comment">//   reject(&quot;失败&quot;);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_a.json&quot;</span>),</span><br><span class="line">  <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_b.json&quot;</span>),</span><br><span class="line">  <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_c.json&quot;</span>),</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="async-await解决promise链式调用不够优雅的问题"><a href="#async-await解决promise链式调用不够优雅的问题" class="headerlink" title="async/await解决promise链式调用不够优雅的问题"></a><code>async</code>/<code>await</code>解决<code>promise</code>链式调用不够优雅的问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getData2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_a.json&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_b.json&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">await</span> <span class="built_in">this</span>.getData1(<span class="string">&quot;./mock/data_c.json&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res1, res2, res3);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err:&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise原理"><a href="#promise原理" class="headerlink" title="promise原理"></a><code>promise</code>原理</h3><p>整理中…</p></div><h2 id="ES6-语法"><a href="#ES6-语法" class="headerlink" title="ES6 语法"></a>ES6 语法</h2><div class="story post-story"><h3 id="let-const"><a href="#let-const" class="headerlink" title="let /const"></a><code>let </code>/<code>const</code></h3><ul><li><code>let</code>、<code>const </code><ul><li><code>let</code>/<code>const</code>声明的变量只有在当前作用域有效<code>&#123;&#125;</code></li><li>不存在变量提升</li><li>不允许重复声明</li></ul></li><li><code>const </code><ul><li>声明的常量不可以改变</li><li>声明的常量必须赋值</li><li>声明了一个对象，仅仅保证地址不变</li></ul></li></ul><ol><li>声明的变量不需要改变，那么使用 const</li><li>声明的变量需要改变，那么用 let</li><li>暂时性死区：在声明变量前，使用该变量</li></ol><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串````"></a>模板字符串````</h3><p>它为 JavaScript 提供了简单的字符串插值（模板字面量）功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="string">&quot;18&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;大家好，我是&quot;</span> + name + <span class="string">&quot;今年&quot;</span> + age);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`大家好, 我是<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="built_in">console</span>.log(fun1(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fun2(<span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">//小明,18</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符..."></a>扩展运算符<code>...</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>); <span class="comment">//1 2 3 4 5</span></span><br></pre></td></tr></table></figure></div><h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><div class="story post-story"><p>整理中…</p></div><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><div class="story post-story"><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">drive</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.singleInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Car(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> benchi = Car.singleInstance(<span class="string">&quot;benchi&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> baoma = Car.singleInstance(<span class="string">&quot;baoma&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  (obj.brand = name),</span><br><span class="line">    (obj.color = age),</span><br><span class="line">    (obj.sayHelllo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;你好，世界&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = createCar(<span class="string">&quot;宝马&quot;</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> car2 = createCar(<span class="string">&quot;奔驰&quot;</span>, <span class="string">&quot;黑色&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>整理中…</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>整理中…</p></div><h2 id="Http-协议"><a href="#Http-协议" class="headerlink" title="Http 协议"></a>Http 协议</h2><div class="story post-story"><h3 id="CS-架构"><a href="#CS-架构" class="headerlink" title="CS 架构"></a>CS 架构</h3><p>客户机-服务器模式，即 Client-Server(C/S)结构但是缺少通用性，系统维护、升级需要重新设计和开发，增加了维护和管理的难度。</p><h3 id="BS-架构"><a href="#BS-架构" class="headerlink" title="BS 架构"></a>BS 架构</h3><p>B/S 架构即浏览器和服务器架构模式，是 WEB 兴起后的一种网络架构模式 WEB 浏览器是客户端最主要的应用软件统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。</p><h3 id="URL（统⼀资源定位符，获取服务器资源的一种）"><a href="#URL（统⼀资源定位符，获取服务器资源的一种）" class="headerlink" title="URL（统⼀资源定位符，获取服务器资源的一种）"></a>URL（统⼀资源定位符，获取服务器资源的一种）</h3><p>标准格式: <code>协议://服务器IP:端⼝/路径1/路径N?key1=value1&amp;key2=value2</code></p><ul><li>协议：不同的协议有不同的解析⽅式</li><li>服务器 ip: ⽹络中存在⽆数的主机,要访问的哪⼀台, 通过公⽹ ip 区分</li><li>端⼝: ⼀台主机上运⾏着很多的进程，为了区分不同进程，⼀个端⼝对应⼀个进程，http 默认的端⼝是 80</li><li>路径: 资源 N 多种，为了更进⼀步区分资源所在的路径（后端接⼝，⼀般称为 “接⼝路径”，“接⼝”）</li></ul><h3 id="Http-超文本传输协议"><a href="#Http-超文本传输协议" class="headerlink" title="Http 超文本传输协议"></a>Http 超文本传输协议</h3><p>即超⽂本传送协议，是 Web 联⽹的基础，也是⼿机 PC 联⽹常⽤的协议之⼀，HTTP 协议是建⽴在 TCP 协议之上的⼀种应⽤HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器响应请求，从建⽴连接到关闭连接的过程称为“⼀次连接”HTTP 请求-HTTP 响应</p><h3 id="响应码："><a href="#响应码：" class="headerlink" title="响应码："></a>响应码：</h3><ul><li>2xx: 成功 200 OK，请求正常</li><li>3xx: 重定向</li><li>4xx: 客户端错误404 Not Found 服务器⽆法找到被请求的⻚⾯</li><li>5xx: 服务器错误 503 Service Unavailable，服务器挂了或者不可⽤</li></ul><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><ul><li><code>http0.9 -&gt; http1.0 -&gt; http1.1 -&gt; http2.0</code></li><li>优化协议，增加更多功能</li></ul><h3 id="http-和-https-协议的主要区别"><a href="#http-和-https-协议的主要区别" class="headerlink" title="http 和 https 协议的主要区别"></a>http 和 https 协议的主要区别</h3><ul><li>https 协议需要 CA 证书，费用较高；http 协议不需要</li><li>http 协议是超文本传输协议，信息是明文传输的，https 则是具有安全性的 SSL 加密传输协议</li><li>使用的连接方式不同，端口也不同，http 协议端口是 80，https 协议端口是 443</li><li>http 协议连接很简单，是无状态的；https 协议是有 SSL 和 TLS 协议构建的可进行加密传输、身份认证的网络协议，比 http 更加安全</li></ul><h3 id="https-优点"><a href="#https-优点" class="headerlink" title="https 优点"></a>https 优点</h3><ul><li>https 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>https 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性</li><li>https 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</li></ul></div><h2 id="超文本传输协议-Http-消息体拆分"><a href="#超文本传输协议-Http-消息体拆分" class="headerlink" title="超文本传输协议 Http 消息体拆分"></a>超文本传输协议 Http 消息体拆分</h2><div class="story post-story"><h3 id="Http-请求消息结构-（请求的报文）"><a href="#Http-请求消息结构-（请求的报文）" class="headerlink" title="Http 请求消息结构 （请求的报文）"></a>Http 请求消息结构 （请求的报文）</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><ul><li>请求方法</li><li>URL 地址</li><li>协议名</li></ul><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><ul><li>报文头包含若干个属性 格式为“属性名:属性值”，</li><li>服务端据此获取客户端的基本信息</li></ul><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><ul><li>请求的参数，可以是 json 对象，也可以是前端表单生成的<code>key=value&amp;key=value</code>的字符串</li></ul><h3 id="Http-响应消息结构（响应的报文）"><a href="#Http-响应消息结构（响应的报文）" class="headerlink" title="Http 响应消息结构（响应的报文）"></a>Http 响应消息结构（响应的报文）</h3><h4 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h4><ul><li>报文协议及版本、状态码</li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><ul><li>报文头包含若干个属性 格式为“属性名:属性值”</li></ul><h4 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h4><ul><li>响应报文体，我们需要的内容，多种形式比如 html、json、图片、视频文件等</li></ul></div><h2 id="Http-常见响应状态码-HttpCode"><a href="#Http-常见响应状态码-HttpCode" class="headerlink" title="Http 常见响应状态码 HttpCode"></a>Http 常见响应状态码 HttpCode</h2><div class="story post-story"><p>浏览器向服务器请求时，服务端响应的消息头里面有状态码，表示请求结果的状态。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h4><ul><li>100 收到请求，需要请求者继续执行操作，比较少用</li><li>101 切换请求的协议</li></ul><h4 id="2XX-请求成功，常用的-200"><a href="#2XX-请求成功，常用的-200" class="headerlink" title="2XX: 请求成功，常用的 200"></a>2XX: 请求成功，常用的 200</h4><h4 id="3XX-重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的-URL-地址，这个地址可以从响应的-Location-首部中获取；"><a href="#3XX-重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的-URL-地址，这个地址可以从响应的-Location-首部中获取；" class="headerlink" title="3XX: 重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取；"></a>3XX: 重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取；</h4><ul><li>好处：网站改版、域名迁移等，多个域名指向同个主站导流</li><li>301：永久性跳转，比如域名过期，换个域名</li><li>302：临时性跳转 304：数据已经在客户端缓存，不需要请求更多的数据</li></ul><h4 id="4XX-客服端出错，请求包含语法错误或者无法完成请求"><a href="#4XX-客服端出错，请求包含语法错误或者无法完成请求" class="headerlink" title="4XX: 客服端出错，请求包含语法错误或者无法完成请求"></a>4XX: 客服端出错，请求包含语法错误或者无法完成请求</h4><ul><li>400: 请求出错，比如语法协议（比如参数错误）</li><li>403: 没权限访问</li><li>404: 找不到这个路径对应的接口或者文件</li><li>405: 不允许此方法进行提交，Method not allowed，比如接口一定要 POST 方式，而你是用了 GET</li></ul><h4 id="5XX-服务端出错，服务器在处理请求的过程中发生了错误"><a href="#5XX-服务端出错，服务器在处理请求的过程中发生了错误" class="headerlink" title="5XX: 服务端出错，服务器在处理请求的过程中发生了错误"></a>5XX: 服务端出错，服务器在处理请求的过程中发生了错误</h4><ul><li>500: 服务器内部报错了，完成不了这次请求</li><li>503: 服务器宕机</li></ul></div><h2 id="http-常见请求头"><a href="#http-常见请求头" class="headerlink" title="http 常见请求头"></a>http 常见请求头</h2><div class="story post-story"><p>http 请求分为三部分：请求行，请求头， 请求体</p><h3 id="请求头-1"><a href="#请求头-1" class="headerlink" title="请求头"></a>请求头</h3><ul><li>报文头包含若干个属性 格式为“属性名:属性值”，</li><li>服务端据此获取客户端的基本信息</li></ul><h3 id="常见的请求头"><a href="#常见的请求头" class="headerlink" title="常见的请求头"></a>常见的请求头</h3><ul><li>Accept： 浏览器支持的 MIME 媒体类型, 比如 text/html,application/json,image/webp,<em>/</em> 等</li><li>Accept-Encoding: 浏览器发给服务器，声明浏览器支持的编码类型，gzip, deflate</li><li>Accept-Language: 客户端接受的语言格式，比如 zh-CN</li><li>Connection: keep-alive，开启 HTTP 持久连接，复用传输通道</li><li>Host：服务器的域名</li><li>Origin：告诉服务器请求从哪里发起的，仅包括协议和域名 CORS 跨域请求中可以看到 response 有对应的 header，Access-Control-Allow-Origin</li><li>Referer：告诉服务器请求的原始资源的 URI，其用于所有类型的请求，并且包括：协议+域名+查询参数；很多抢购服务会用这个做限制，必须通过某个入口进来才有效</li><li>User-Agent: 服务器通过这个请求头判断用户的软件的应用类型、操作系统、软件开发商以及版本号、浏览器内核信息等；风控系统、反作弊系统、反爬虫系统等基本会采集这类信息做参考</li><li>Cookie: 表示服务端给客户端传的 http 请求状态,也是多个 key=value 形式组合，比如登录后的令牌等</li><li>Content-Type：HTTP 请求提交的内容类型，一般只有 post 提交时才需要设置，浏览器把 form 数据封装到请求体中（key=value 形式），然后发送到服务器，比如文件上传，表单提交等</li></ul></div><h2 id="Http-响应头"><a href="#Http-响应头" class="headerlink" title="Http 响应头"></a>Http 响应头</h2><div class="story post-story"><p>报文头包含若干个属性 格式为“属性名:属性值”。</p><h3 id="常见的响应头"><a href="#常见的响应头" class="headerlink" title="常见的响应头"></a>常见的响应头</h3><ul><li>Allow: 服务器支持哪些请求方法</li><li>Content-Length: 响应体的字节长度</li><li>Content-Type: 响应体的 MIME 类型</li><li>Content-Encoding: 设置数据使用的编码类型</li><li>Date: 设置消息发送的日期和时间</li><li>Expires: 设置响应体的过期时间,一个 GMT 时间，表示该缓存的有效时间</li><li>cache-control: Expires 的作用一致，都是指明当前资源的有效期, 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据,优先级高于 Expires,控制粒度更细，如 max-age=3600，即一个小时</li><li>Location：表示客户端应当到哪里去获取资源，一般同时设置状态代码为 3xx</li><li>Server: 服务器名称</li><li>Transfer-Encoding：chunked 表示输出的内容长度不能确定，静态网页一般没有，基本出现在动态网页里面</li><li>Access-Control-Allow-Origin: 定哪些站点可以参与跨站资源共享</li></ul></div><h2 id="浏览器网络请求链路"><a href="#浏览器网络请求链路" class="headerlink" title="浏览器网络请求链路"></a>浏览器网络请求链路</h2><div class="story post-story"><p>常见问题：你知道浏览器输入 url 后经历了哪些流程？整理中…</p></div><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><div class="story post-story"><p>思路：先确认前端性能影响最大的问题。</p><h3 id="网络连接速度"><a href="#网络连接速度" class="headerlink" title="网络连接速度"></a>网络连接速度</h3><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><h4 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefecth&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://xdclass.net&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: keep-alive</span><br></pre></td></tr></table></figure><h3 id="网络请求数量"><a href="#网络请求数量" class="headerlink" title="网络请求数量"></a>网络请求数量</h3><h4 id="文件合并（webpack）"><a href="#文件合并（webpack）" class="headerlink" title="文件合并（webpack）"></a>文件合并（webpack）</h4><h4 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h4><ul><li>雪碧图</li><li>base64</li></ul><h4 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h4><h3 id="资源文件的体积"><a href="#资源文件的体积" class="headerlink" title="资源文件的体积"></a>资源文件的体积</h3><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><h4 id="开启-gzip"><a href="#开启-gzip" class="headerlink" title="开启 gzip"></a>开启 gzip</h4><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><h4 id="加载位置"><a href="#加载位置" class="headerlink" title="加载位置"></a>加载位置</h4><ul><li>css 文件放在 head 中</li><li>js 文件放在 body 结束标签前</li></ul><h4 id="加载时机"><a href="#加载时机" class="headerlink" title="加载时机"></a>加载时机</h4><ul><li>异步 script 标签加载，设置 defer、async</li></ul><h3 id="webpack-优化"><a href="#webpack-优化" class="headerlink" title="webpack 优化"></a>webpack 优化</h3><h4 id="打包公共代码"><a href="#打包公共代码" class="headerlink" title="打包公共代码"></a>打包公共代码</h4><h4 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h4><h4 id="长缓存优化"><a href="#长缓存优化" class="headerlink" title="长缓存优化"></a>长缓存优化</h4><ul><li>chunkhash</li><li>contenthash</li></ul></div><h2 id="CDN-内容分发网络"><a href="#CDN-内容分发网络" class="headerlink" title="CDN 内容分发网络"></a>CDN 内容分发网络</h2><div class="story post-story"><p>CDN（内容分发网络）是通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将资源文件（音乐、图片、视频、应用程序）发送给用户，来提供高性能、低成本的网络内容传递给用户，提高请求的速度。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>将数据快速可靠的从源服务站传递到用户端</li><li>通过 CDN，用户可以不直接从源站获取，选择一个较优的服务器获取数据，做到快速访问，减少源站负载压力</li><li>其他作用<ul><li>监控</li><li>统计分析</li><li>用量查询</li><li>刷新预热</li><li>日志分析</li></ul></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="未使用-CDN-缓存资源"><a href="#未使用-CDN-缓存资源" class="headerlink" title="未使用 CDN 缓存资源"></a>未使用 CDN 缓存资源</h4><ul><li>浏览器通过 DNS 对域名进行解析，得到域名对应的 IP 地址</li><li>浏览器根据得到的 IP 地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ul><h4 id="使用-CDN-缓存资源"><a href="#使用-CDN-缓存资源" class="headerlink" title="使用 CDN 缓存资源"></a>使用 CDN 缓存资源</h4><ul><li>用户发起域名的请求，DNS 服务器将域名解析交给 CDN</li><li>CDN 将负载均衡的 ip 地址返回给用户</li><li>请求地址，负载均衡设备选择一台最优的缓存服务器（边缘节点服务器）提供访问<ul><li>根据用户的 ip 地址，距离用户最近的服务器</li><li>根据 URL 携带的内容，选择有所需内容的服务器</li><li>选择负载最小的服务器</li></ul></li><li>用户发出请求，缓存服务器返回数据</li><li>如果缓存服务器没有缓存用户的请求内容，则会向上一级缓存服务器请求，直到访问网站的源服务器</li></ul><h3 id="回源率（拓展知识点）"><a href="#回源率（拓展知识点）" class="headerlink" title="回源率（拓展知识点）"></a>回源率（拓展知识点）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回源率 =（CDN没缓存 + 缓存过期 + 不可缓存的请求）/ 全部的请求</span><br></pre></td></tr></table></figure><p>回源率越低代表请求的性能越好。</p></div><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><div class="story post-story"><p>懒加载也叫做延迟加载、按需加载，在非首屏展示的组件或者数据可以使用懒加载。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>减小接口请求个数，页面的渲染负担</li><li>提高首页的展示速度，提升用户体验</li><li>防止加载过多图片而影响其他资源文件的加载</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="通过-import-方法引入组件"><a href="#通过-import-方法引入组件" class="headerlink" title="通过 import() 方法引入组件"></a>通过 import() 方法引入组件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(./test.js).then(<span class="function">(<span class="params">&#123;fun&#125;</span>)=&gt;</span>&#123;fun()&#125;)</span><br><span class="line"></span><br><span class="line">()=&gt;<span class="keyword">import</span>(<span class="string">&#x27;./Test&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="通过监听用户的滚动事件触发来展示非首屏的图片"><a href="#通过监听用户的滚动事件触发来展示非首屏的图片" class="headerlink" title="通过监听用户的滚动事件触发来展示非首屏的图片"></a>通过监听用户的滚动事件触发来展示非首屏的图片</h4><h3 id="懒加载和预加载的区别"><a href="#懒加载和预加载的区别" class="headerlink" title="懒加载和预加载的区别"></a>懒加载和预加载的区别</h3><ul><li>懒加载也叫延迟加载，指的是在网页中延迟加载图片的时机，当用户需要访问时，再去加载，可以提高网站的首屏加载速度，提升用户的体验</li><li>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源，通过预加载能够减少用户的等待时间，提高用户的体验</li></ul><h3 id="非首屏的内容延时渲染实现"><a href="#非首屏的内容延时渲染实现" class="headerlink" title="非首屏的内容延时渲染实现"></a>非首屏的内容延时渲染实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个异步的函数，当用户滑动时则不延时</span></span><br><span class="line"><span class="keyword">const</span> delayMS = <span class="function">(<span class="params">ms</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 如果用户开始滑动，则取消延期</span></span><br><span class="line">  <span class="keyword">const</span> onTouchPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">&quot;touchstart&quot;</span>, handler);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;touchstart&quot;</span>, handler);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([p, onTouchPromise]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line">delayMS(<span class="number">2000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">333</span>); <span class="comment">// 控制非首屏dom节点的渲染</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><div class="story post-story"><h3 id="如何对项目图片进行优化。"><a href="#如何对项目图片进行优化。" class="headerlink" title="如何对项目图片进行优化。"></a>如何对项目图片进行优化。</h3><h4 id="图片可以使用-CDN-加载，通过-CDN-地址获取"><a href="#图片可以使用-CDN-加载，通过-CDN-地址获取" class="headerlink" title="图片可以使用  CDN 加载，通过 CDN 地址获取"></a>图片可以使用  CDN 加载，通过 CDN 地址获取</h4><h4 id="图片比较小的使用-webpack-压缩成-base64-格式，减小项目文件体积"><a href="#图片比较小的使用-webpack-压缩成-base64-格式，减小项目文件体积" class="headerlink" title="图片比较小的使用 webpack 压缩成 base64 格式，减小项目文件体积"></a>图片比较小的使用 webpack 压缩成 base64 格式，减小项目文件体积</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.(png|gif|jpe?g)$/i</span>,</span><br><span class="line">  type: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">  <span class="attr">parser</span>: &#123;</span><br><span class="line">    <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">      <span class="attr">maxSize</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">generator</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;images/[name][ext]&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="icon-尽量使用-svg-图片和字体图片，减小项目文件体积"><a href="#icon-尽量使用-svg-图片和字体图片，减小项目文件体积" class="headerlink" title="icon 尽量使用 svg 图片和字体图片，减小项目文件体积"></a>icon 尽量使用 svg 图片和字体图片，减小项目文件体积</h4></div><h2 id="webpack-优化-1"><a href="#webpack-优化-1" class="headerlink" title="webpack 优化"></a>webpack 优化</h2><div class="story post-story"><h3 id="webpack-抽离公共文件"><a href="#webpack-抽离公共文件" class="headerlink" title="webpack 抽离公共文件"></a>webpack 抽离公共文件</h3><p>将多个页面重复引入的模块抽离成公共的模块，避免重复打包，减少包体积。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><div class="story post-story"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin =</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> BundleAnalyzerPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS-事件循环&quot;&gt;&lt;a href=&quot;#JS-事件循环&quot; class=&quot;headerlink&quot; title=&quot;JS 事件循环&quot;&gt;&lt;/a&gt;JS 事件循环&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;JavaScript 语言是一门&lt;str</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://resonance.fun/categories/JavaScript/"/>
    
    
    <category term="JavaScript基础" scheme="https://resonance.fun/tags/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之基础知识</title>
    <link href="https://resonance.fun/2022/04/01/yuque/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://resonance.fun/2022/04/01/yuque/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-01T08:21:09.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-选择器以及优先级"><a href="#CSS-选择器以及优先级" class="headerlink" title="CSS 选择器以及优先级"></a>CSS 选择器以及优先级</h2><div class="story post-story"><h3 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h3><ul><li>最近的祖先样式⽐其他祖先样式优先级高</li><li><code>直接样式</code>⽐<code>祖先样式</code>优先级⾼</li><li>选择器优先级</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内联样式 &gt; id选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</span><br></pre></td></tr></table></figure><ul><li>组合选择符<ul><li>分类<ul><li>后代选择符：<code>.a .b&#123;&#125;</code></li><li>子级选择符：<code>.a &gt; .b&#123;&#125;</code></li><li>相邻选择符：<code>.a + .b &#123;&#125;</code></li></ul></li><li>选择符优先级<ol><li> 计算 id 选择器的个数（a）</li><li> 计算类选择器、属性选择器、伪类选择器的个数（b）</li><li> 计算标签选择器、伪元素选择器的个数（c）</li></ol><ul><li>对⽐ a、b、c 的个数，相等则⽐较下⼀个</li><li>若都相等，则按照“就近原则”⽐较</li></ul></li></ul></li><li>属性后⾯加<code>!important</code> 拥有最⾼优先级，若两个样式都有此设置，则对⽐选择器优先级</li></ul></div><h2 id="标准的-CSS-盒子模型以及低版本盒子模型异同"><a href="#标准的-CSS-盒子模型以及低版本盒子模型异同" class="headerlink" title="标准的 CSS 盒子模型以及低版本盒子模型异同"></a>标准的 CSS 盒子模型以及低版本盒子模型异同</h2><div class="story post-story"><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>由内容 <code>content</code> + 内边距 <code>padding</code> + 边框 <code>border</code> + 外边距 <code>margin</code> 构成，盒⼦的宽⾼由 <code>content</code> + <code>padding</code> + <code>border</code> 决定，但是不同的盒⼦模型的计算依据不⼀样，分为：标准盒模型（w3c）和 怪异盒模型（IE）</p><h4 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h4><p>宽⾼包含 <code>content</code> + <code>padding</code> + <code>border</code></p><h4 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h4><p>宽⾼只包含 <code>content</code></p><h4 id="盒模型设置"><a href="#盒模型设置" class="headerlink" title="盒模型设置"></a>盒模型设置</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box // 标准盒模型</span><br><span class="line">box-sizing: border-box // 怪异盒模型</span><br></pre></td></tr></table></figure></div><h2 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h2><div class="story post-story"><p>BFC：块级格式化上下文（Block Formatting Context）</p><h3 id="什么是块级格式化上下文"><a href="#什么是块级格式化上下文" class="headerlink" title="什么是块级格式化上下文"></a>什么是块级格式化上下文</h3><ul><li>BFC 就是块级格式化上下⽂</li><li>是页面盒模型布局中的⼀种 CSS 渲染模式，相当于⼀个独⽴的容器，里面的元素和外部的元素相互不影响</li></ul><h3 id="BFC-的特性"><a href="#BFC-的特性" class="headerlink" title="BFC 的特性"></a>BFC 的特性</h3><ul><li>内部的盒⼦会按照垂直⽅向⼀个个排列</li><li>同⼀个 BFC 下的相邻块级元素会发生外边距折叠，创建新的 BFC 包含其中⼀个元素可以避免（解决外边距重叠）</li><li>设置了 BFC 的区域不会和浮动元素重叠（解决浮动元素覆盖）</li><li>当 BFC 中有浮动元素时，该浮动元素的高度也会被计算其中（解决⾼度塌陷）</li></ul><h3 id="如何触发-BFC"><a href="#如何触发-BFC" class="headerlink" title="如何触发 BFC"></a>如何触发 BFC</h3><ul><li>设置 float 浮动</li><li>overflow 的值是 hidden、auto 或者 scroll，⽽不是 visible</li><li>position 的值为 absolute 或 fixed</li><li>display 的值为 table | inline-block | flex | grid</li></ul></div><h2 id="CSS-实现三栏布局的几种方式"><a href="#CSS-实现三栏布局的几种方式" class="headerlink" title="CSS 实现三栏布局的几种方式"></a>CSS 实现三栏布局的几种方式</h2><div class="story post-story"><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><ul><li>⽅案⼀： flex 布局</li><li>⽅案⼆： 浮动+margin</li><li>⽅案三： 浮动+BFC</li></ul></div><h2 id="CSS-的预处理器"><a href="#CSS-的预处理器" class="headerlink" title="CSS 的预处理器"></a>CSS 的预处理器</h2><div class="story post-story"><h3 id="什么是预处理器？"><a href="#什么是预处理器？" class="headerlink" title="什么是预处理器？"></a>什么是预处理器？</h3><ul><li>定义了专⻔的编程语言，增加了编程的特性，生成 CSS ⽂件</li><li>CSS 代码更加简洁、适应性更强、可读性更佳，更易于代码的维护等</li></ul><h3 id="常见的-css-预处理器"><a href="#常见的-css-预处理器" class="headerlink" title="常见的 css 预处理器"></a>常见的 css 预处理器</h3><ul><li>less</li><li>sass</li><li>stylus</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>三种预处理器的使⽤语法都基本⼀致</li><li>变量、嵌套、运算符、颜⾊函数、导⼊、继承等</li><li>stylus 的写法会特别点，⽐如：不需要加括号</li></ul><h3 id="预处理器的能力"><a href="#预处理器的能力" class="headerlink" title="预处理器的能力"></a>预处理器的能力</h3><ul><li>嵌套反映层级和约束</li><li>变量和计算减少重复代码</li><li>extend 和 mixin 代码片段</li><li>循环适用于复杂有规律的样式</li><li>import css 文件模块化</li></ul></div><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><div class="story post-story"><h3 id="利用-flex-弹性盒子"><a href="#利用-flex-弹性盒子" class="headerlink" title="利用 flex 弹性盒子"></a>利用 flex 弹性盒子</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:flex</span><br><span class="line">  justify-content:center;</span><br><span class="line">  <span class="attribute">align-items</span>:center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用-margin-与定位"><a href="#利用-margin-与定位" class="headerlink" title="利用 margin 与定位"></a>利用 margin 与定位</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用-position-定位实现"><a href="#利用-position-定位实现" class="headerlink" title="利用 position 定位实现"></a>利用 position 定位实现</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>); // 未知宽高</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>; // 已知宽高</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>; // 已知宽高</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="CSS-移动端的适配"><a href="#CSS-移动端的适配" class="headerlink" title="CSS 移动端的适配"></a>CSS 移动端的适配</h2><div class="story post-story"><h3 id="第一步设置页面视口"><a href="#第一步设置页面视口" class="headerlink" title="第一步设置页面视口"></a>第一步设置页面视口</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第二步配置-rem-单位"><a href="#第二步配置-rem-单位" class="headerlink" title="第二步配置 rem 单位"></a>第二步配置 rem 单位</h3><h4 id="安装-postcss-pxtorem，自动将-px-转换成-rem-单位的插件"><a href="#安装-postcss-pxtorem，自动将-px-转换成-rem-单位的插件" class="headerlink" title="安装 postcss-pxtorem，自动将 px 转换成 rem 单位的插件"></a>安装 postcss-pxtorem，自动将 px 转换成 rem 单位的插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install postcss-pxtorem@5.1.1 -S</span><br></pre></td></tr></table></figure><h4 id="安装-amfe-flexible，自动检测当前设备屏幕宽度-serveWidth，设置-html-里面的-font-szie-为-serveWidth-10"><a href="#安装-amfe-flexible，自动检测当前设备屏幕宽度-serveWidth，设置-html-里面的-font-szie-为-serveWidth-10" class="headerlink" title="安装 amfe-flexible，自动检测当前设备屏幕宽度 serveWidth，设置 html 里面的 font-szie 为 serveWidth/10"></a>安装 amfe-flexible，自动检测当前设备屏幕宽度 serveWidth，设置 html 里面的 font-szie 为 serveWidth/10</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install amfe-flexible -S</span><br></pre></td></tr></table></figure><h4 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">loaderOptions</span>: &#123;</span><br><span class="line">      <span class="attr">postcss</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">&quot;postcss-pxtorem&quot;</span>)(&#123; <span class="attr">rootValue</span>: <span class="number">37.5</span> &#125;), <span class="comment">// 假设设计图尺寸375</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;amfe-flexible&quot;</span>;</span><br></pre></td></tr></table></figure></div><h2 id="剖析重绘和重排"><a href="#剖析重绘和重排" class="headerlink" title="剖析重绘和重排"></a>剖析重绘和重排</h2><div class="story post-story"><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><ul><li>当元素的外观、背景、颜色等改变，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观叫做重绘</li></ul><h3 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h3><ul><li>当渲染树一部分或者全部因为大小或者边距而改变，需要渲染树重新计算的过程叫做重排</li><li>重绘不一定需要重排，重排必然导致重绘</li></ul><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><ul><li>在元素的显示隐藏上尽量用 opacity 替代 visibility（重绘）</li><li>元素定位时使用 transform 代替 top、left（重排）</li><li>尽量不使用 table 布局，因为一个小的改动会造成整个 table 重新布局（重排）</li><li>减少直接操作 DOM 元素（重排）</li><li>为元素添加类，样式都在类中改变（重绘）</li><li>分离读写操作，连续写读会导致直接重绘</li></ul></div><h2 id="剖析-flex-布局"><a href="#剖析-flex-布局" class="headerlink" title="剖析 flex 布局"></a>剖析 flex 布局</h2><div class="story post-story"><p>flex 布局强大，能够实现多种布局方案，兼容性好，而且使用简单</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置父元素 */</span></span><br><span class="line"><span class="attribute">display</span>:flex</span><br><span class="line"></span><br><span class="line">/* 定义水平方向对齐方式 */</span><br><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义垂直方向对齐方式 */</span></span><br><span class="line"><span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义多个轴线（多行/多列）对齐方式 */</span></span><br><span class="line"><span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置子项目 */</span></span><br><span class="line"><span class="comment">/* flex: 1 等价于以下设置 */</span></span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 */</span></span><br><span class="line"><span class="attribute">flex-shrink</span>: <span class="number">1</span>; <span class="comment">/* 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。*/</span></span><br><span class="line"><span class="attribute">flex-basis</span>: <span class="number">0%</span>; <span class="comment">/* 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 */</span></span><br></pre></td></tr></table></figure><h3 id="注意事项（坑）"><a href="#注意事项（坑）" class="headerlink" title="注意事项（坑）"></a>注意事项（坑）</h3><ul><li>父元素设置了 flex 布局，默认会给每个子元素开启缩小属性（flex-shrink:1;）</li><li>当空间不够时，其他的元素会被挤压至隐藏</li><li>设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS-选择器以及优先级&quot;&gt;&lt;a href=&quot;#CSS-选择器以及优先级&quot; class=&quot;headerlink&quot; title=&quot;CSS 选择器以及优先级&quot;&gt;&lt;/a&gt;CSS 选择器以及优先级&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;h3</summary>
      
    
    
    
    <category term="CSS" scheme="https://resonance.fun/categories/CSS/"/>
    
    
    <category term="CSS基础" scheme="https://resonance.fun/tags/CSS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML之基础知识</title>
    <link href="https://resonance.fun/2022/04/01/yuque/HTML%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://resonance.fun/2022/04/01/yuque/HTML%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-01T03:33:15.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><div class="story post-story"><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p><code>src</code>用于替换当前元素，<code>href</code>用于在当前文档和引用资源之间确立联系。<code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，<code>img</code>图片和<code>frame</code>等元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。</p><h3 id="href"><a href="#href" class="headerlink" title="href"></a>href</h3><p><code>href</code>是<code>Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;common.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用<code>link</code>方式来加载<code>css</code>，而不是使用<code>@import</code>方式。</p></div><h2 id="link-标签和-script-标签的引⽤位置"><a href="#link-标签和-script-标签的引⽤位置" class="headerlink" title="link 标签和 script 标签的引⽤位置"></a>link 标签和 script 标签的引⽤位置</h2><div class="story post-story"><p>常见问题： 为什么引⽤ CSS 的 link 标签放在头部，引⽤ JS 的 script 标签放在 body 结束标签之前？</p><h3 id="link-标签放在-head-标签中"><a href="#link-标签放在-head-标签中" class="headerlink" title="link 标签放在 head 标签中"></a>link 标签放在 head 标签中</h3><ul><li>⽤户访问⽹站时，代码是从上往下解析的，正常展示⻚⾯内容的样式，提⾼⽤户体验</li><li>放在 html 结构底部时，加载⻚⾯会出现 html 结构混乱的情况</li></ul><h3 id="script-标签放在-body-结束标签之前"><a href="#script-标签放在-body-结束标签之前" class="headerlink" title="script 标签放在 body 结束标签之前"></a>script 标签放在 body 结束标签之前</h3><ul><li>JS 脚本在下载和执⾏期间会阻⽌ html 解析</li><li>把 script 标签放在底部，保证 html 和 css ⾸先完成解析之后再加载 JS 脚本</li><li>script 标签加上 defer 属性时，可以放在 head 标签中 （async）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="提高网站搜索权重"><a href="#提高网站搜索权重" class="headerlink" title="提高网站搜索权重"></a>提高网站搜索权重</h2><div class="story post-story"><p>SEO 优化、HTML 语义化</p><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><ul><li>设置⽹站的 title 标题标签，如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>在这里写入标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置⽹站的 description 描述标签，如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;小程序提供了一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者在微信中开发具有原生 APP 体验的服务。&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置⽹站的 keywords 关键词标签，如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;Shilin的备忘录,html/css/JavaScript,前端工程师,Vue,React,Node.js&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML-语义化"><a href="#HTML-语义化" class="headerlink" title="HTML 语义化"></a>HTML 语义化</h3><ul><li>使⽤正确的标签引⽤正确的内容</li><li>增强可读性，结构更加清晰，便于对浏览器、搜索引擎解析</li><li>搜索引擎的爬⾍也依赖于 HTML 标记来确定上下⽂和各个关键字的权重，利于 SEO</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header、footer、a、p、ul、ol、li、h1、h2、h3...</span><br></pre></td></tr></table></figure></div><h2 id="设置移动端视口大小"><a href="#设置移动端视口大小" class="headerlink" title="设置移动端视口大小"></a>设置移动端视口大小</h2><div class="story post-story"><p>常见问题：如何在不同移动设备的屏幕下正常展示网页的内容？</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>手机浏览器会把页面放⼊到⼀个虚拟的视⼝（viewpoint）中，但 viewport ⼜不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的视口（viewport）比屏幕宽，会把网页挤到⼀个很小的窗口。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>设置 viewport 的宽度</td></tr><tr><td>height</td><td>设置 viewport 的高度</td></tr><tr><td>initial-scale</td><td>设置页面的初始缩放值</td></tr><tr><td>minimum-scale</td><td>允许用户的最⼩缩放值</td></tr><tr><td>maximum-scale</td><td>允许用户的最⼤缩放值</td></tr><tr><td>user-scalable</td><td>是否允许用户进行缩放，no 代表不允许，yes 代表允许</td></tr></tbody></table></div><h2 id="DOM、BOM-的区别与使用"><a href="#DOM、BOM-的区别与使用" class="headerlink" title="DOM、BOM 的区别与使用"></a>DOM、BOM 的区别与使用</h2><div class="story post-story"><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>DOM 就是⽂档对象模型，是⼀个抽象的概念</li><li>定义了访问和操作 HTML ⽂档的⽅法和属性</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>查找节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;xd&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>改变元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;xd&quot;</span>).innerHTML = <span class="string">&quot;&lt;h1&gt;xdclass.net&lt;/h1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>创建元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">&quot;h1&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li>BOM 就是浏览器对象模型</li><li>内置对象定义操作浏览器的⽅法</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ul><li>window</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">&quot;你好，世界&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>screen</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.screen.width);</span><br></pre></td></tr></table></figure><ul><li>location</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.href;</span><br></pre></td></tr></table></figure><ul><li>localStorage</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.localStorage.setItem(key, value);</span><br></pre></td></tr></table></figure><ul><li>history</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.go(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;src-和-href-的区别&quot;&gt;&lt;a href=&quot;#src-和-href-的区别&quot; class=&quot;headerlink&quot; title=&quot;src 和 href 的区别&quot;&gt;&lt;/a&gt;src 和 href 的区别&lt;/h2&gt;&lt;div class=&quot;story post-st</summary>
      
    
    
    
    <category term="HTML" scheme="https://resonance.fun/categories/HTML/"/>
    
    
    <category term="HTML基础" scheme="https://resonance.fun/tags/HTML%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="https://resonance.fun/2022/03/13/yuque/React/"/>
    <id>https://resonance.fun/2022/03/13/yuque/React/</id>
    <published>2022-03-13T13:51:37.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>change logReact 做了两件事：渲染 UI 和响应事件</p><p>性能提升React 虚拟 dom 的数据结构时间复杂度是 O(n^3)，链表的数据结构时间复杂度是 O(n)，所以 React16.0 之后使用链表的数据结构。因为 React16.0 之前的虚拟 dom 更新采用的是循环和递归，由于是线性的主线程会被一直占用，复杂的业务场景会出现卡顿。</p><p>Fiber利用浏览器空闲时间执行，不会长时间占用主线程</p><ul><li>requestIdleCallback 浏览器 API，可暂停当前任务利用浏览器空闲时间执行优先级更高的任务。</li></ul><p>将对比更新 dom 的操作碎片化碎片化的任务，可以根据需要被暂停</p><p>生命周期React 生命周期在 React16.0 版本加入了 Fiber 时发生了变化，您想听哪个？</p><ul><li>初始化：constructor 设置 props 和 state</li><li>挂载：componentWillMount –&gt; render –&gt; componentDidMount</li><li>更新：<ul><li>props 更新：componentWillReceiveProps –&gt; shouldComponentUpdate –&gt; componentWillUpdate –&gt; render –&gt; componentDidUpdate</li><li>state 更新：suouldComponentUpdate –&gt; componentWillUpdate –&gt; render –&gt; componentDidUpdate</li></ul></li><li>卸载：componentWillUnmount</li></ul><p>面试复盘，录音，值得录音的面试</p><p>React diff 算法策略</p><ul><li><p>针对树结构(tree diff)：对 UI 层的 DOM 节点跨层级的操作进行忽略。(数量少)</p><pre><code>  type变化，比如div变成了p  key变化</code></pre></li><li><p>针对组件结构( component diff)：拥有相同类的两个组件生成相似的树形结构，拥有不同类的两个组件会生成不同的属性结构。</p></li><li><p>针对元素结构(element-diff)：对于同一层级的一组节点，使用具有唯一性的 id 区分(key 属性)</p></li></ul><p>Fiber 算法</p><ul><li>通过 state 计算出新的 Fiber 节点</li><li>对比节点的 tag 和 key 确定节点操作(修改，删除，新增，移动)</li><li>effectTag 标记 Fiber 对象</li><li>收集所有标记的 Fiber 对象，形成 effectList</li><li>commit 阶段一次性处理所有变化的节点</li></ul><p>答题留有一定的空间，不要一次全部答完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;change log
React 做了两件事：渲染 UI 和响应事件&lt;/p&gt;
&lt;p&gt;性能提升
React 虚拟 dom 的数据结构时间复杂度是 O(n^3)，链表的数据结构时间复杂度是 O(n)，所以 React16.0 之后使用链表的数据结构。
因为 React16.0 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用方法之数据类型</title>
    <link href="https://resonance.fun/2022/03/10/yuque/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://resonance.fun/2022/03/10/yuque/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-03-10T02:55:27.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/^\[Object (.+)\]$/</span>;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span></span><br><span class="line">    ? reg.test(<span class="built_in">Object</span>.prototype.toString(obj))[<span class="number">1</span>].toLowerCase()</span><br><span class="line">    : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto, Ctor;</span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="built_in">Object</span>.prototype.toString.call(obj) !== <span class="string">&quot;[object Object]&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">  <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  Ctor =</span><br><span class="line">    <span class="built_in">Object</span>.prototype.hasOwnProperty.call(proto, <span class="string">&quot;constructor&quot;</span>) &amp;&amp;</span><br><span class="line">    proto.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> Ctor === <span class="string">&quot;function&quot;</span> &amp;&amp; Ctor === <span class="built_in">Object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span> || <span class="regexp">/^(object|function)$/</span>.test(<span class="keyword">typeof</span> obj)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">    keys = keys.concat(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</span><br><span class="line">  <span class="keyword">return</span> keys.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>防抖和节流实现原理</title>
    <link href="https://resonance.fun/2022/03/10/yuque/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://resonance.fun/2022/03/10/yuque/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-10T02:32:19.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>在用户频繁的进行某项操作时，只识别一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearTimer</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> timer !== <span class="literal">null</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;func必须是一个函数&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait !== <span class="string">&quot;number&quot;</span>) wait = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    timer = clearTimer(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      clearTimer(timer);</span><br><span class="line">      func.call(<span class="built_in">this</span>, ...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持自定义边界</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, flag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;func必须是一个函数&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&quot;boolean&quot;</span>) flag = wait;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait !== <span class="string">&quot;number&quot;</span>) wait = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> flag !== <span class="string">&quot;boolean&quot;</span>) flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> beforeRun = !timer &amp;&amp; flag;</span><br><span class="line">    timer = clearTimer(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timer = clearTimer(timer);</span><br><span class="line">      !flag &amp;&amp; func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">    beforeRun &amp;&amp; unc.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>在用户频繁的进行某项操作时，降低默认触发的频率</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearTimer</span>(<span class="params">timer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> timer !== <span class="string">&quot;null&quot;</span>) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> TypeErrot(<span class="string">&quot;func必须是一个函数&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> wait !== <span class="string">&quot;number&quot;</span>) wait = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>,</span><br><span class="line">    previousTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> remaining = wait - (now - previousTime);</span><br><span class="line">    <span class="comment">// 间隔超过或者等于300</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      previousTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      timer = clearTimer(timer);</span><br><span class="line">      func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有到达间隔时间，并且之前没有设置过定时器，如果之前设置过定时器就不管了</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        previousTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        timer = clearTimer(timer);</span><br><span class="line">        func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h1&gt;&lt;p&gt;在用户频繁的进行某项操作时，只识别一次&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript之数据类型</title>
    <link href="https://resonance.fun/2022/03/10/yuque/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://resonance.fun/2022/03/10/yuque/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-03-10T01:44:19.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS-中的数据类型被分为两大类："><a href="#JS-中的数据类型被分为两大类：" class="headerlink" title="JS 中的数据类型被分为两大类："></a>JS 中的数据类型被分为两大类：</h2><div class="story post-story"><h4 id="原始值类型（值类型-基本数据类型）"><a href="#原始值类型（值类型-基本数据类型）" class="headerlink" title="原始值类型（值类型/基本数据类型）"></a>原始值类型（值类型/基本数据类型）</h4><ol><li>number 数字</li><li>string 字符串</li><li>boolean 布尔</li><li>null 空对象指针</li><li>undefined 未定义</li><li>symbol 唯一值</li><li>bigint 大数</li></ol><h4 id="对象类型（引用数据类型）"><a href="#对象类型（引用数据类型）" class="headerlink" title="对象类型（引用数据类型）"></a>对象类型（引用数据类型）</h4><ol><li>标准普通对象 <code>Object</code></li><li>标准特殊对象 <code>Array</code>、<code>RegExp</code>、<code>Date</code>、<code>Math</code>、<code>Error</code>……</li><li>非标准特殊对象 <code>Number</code>、<code>String</code>、<code>Boolean</code></li><li>可调用/执行对象（函数） <code>Function</code></li></ol></div><h2 id="数据类型检测的方式（4-种）"><a href="#数据类型检测的方式（4-种）" class="headerlink" title="数据类型检测的方式（4 种）"></a>数据类型检测的方式（4 种）</h2><div class="story post-story"><ol><li><code>typeof [value]</code> 返回值是字符串，字符串中包含所属的类型<ol><li>typeof 检测对象类型，除函数被识别’function’，其余都是’object’（不能细分对象）</li><li>基于 typeof 检测一个未被声明的变量，不会报错，结果是’undefined’</li><li><code>typeof null -&gt; &#39;object&#39;</code> typeof 检测 null 结果是’object’的原因是：如果是以’000’开始的二进制，则被识别为对象(null 存储的二进制都是 0，符合以’000’开始)；然后再去看对象是否实现了[[call]]，实现了则为函数(返回’function’)，没实现就是对象(返回’object’)</li></ol></li><li><code>Object.prototype.toString.call([value])</code></li><li><code>[value] instanceof [constructor]</code></li><li><code>[value].constructor</code></li></ol><p>其他检测固定类型的方法：<code>Array.isArray([value])</code>、<code>isNaN([value])</code> ……检测是否为对象：<code>val !== null &amp;&amp; /^(object|function)$/i.test(typeof val)</code>0.1 + 0.2 != 0.3 计算机是二进制形式存储数据的，十进制浮点数在转换为二进制时，由于计算机存储位数限制，有可能出现精度丢失。运算保证精度，实现思路：把小数变成整数(乘以系数)运算，运算后的结果再除以系数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> coefficent = <span class="function"><span class="keyword">function</span> <span class="title">coefficent</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num = <span class="built_in">String</span>(num);</span><br><span class="line">  <span class="keyword">const</span> [, char = <span class="string">&quot;&quot;</span>] = num.split(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">    len = char.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">10</span>, len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  n = <span class="built_in">Number</span>(n);</span><br><span class="line">  m = <span class="built_in">Number</span>(m);</span><br><span class="line">  <span class="keyword">let</span> coeffic = <span class="built_in">Math</span>.max(coefficient(n), coefficent(m));</span><br><span class="line">  <span class="keyword">return</span> (n * coeffic + m * coeffic) / coeffic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><div class="story post-story"><p>一般将其他数据类型转换为<code>Number</code>、<code>String</code>、<code>Boolean</code></p><h4 id="把其他类型值转换为Number"><a href="#把其他类型值转换为Number" class="headerlink" title="把其他类型值转换为Number"></a>把其他类型值转换为<code>Number</code></h4><ol><li><code>Number([value])</code></li><li><code>parseInt([val],[radix])</code>、<code>parseFloat([val])</code></li></ol><h4 id="把其他类型值转换为String"><a href="#把其他类型值转换为String" class="headerlink" title="把其他类型值转换为String"></a>把其他类型值转换为<code>String</code></h4><ol><li><code>[value].toString()</code></li><li><code>String([value])</code></li></ol><h4 id="把其他类型值转换为Boolean"><a href="#把其他类型值转换为Boolean" class="headerlink" title="把其他类型值转换为Boolean"></a>把其他类型值转换为<code>Boolean</code></h4><p>转换规则：除了“0/NaN/空字符串/null/undefined”五个值是 false，其余的都是 true出现情况：</p><ol><li><code>Boolean([val])</code>或者<code>!/!!</code></li><li><code>条件判断</code></li></ol></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS-中的数据类型被分为两大类：&quot;&gt;&lt;a href=&quot;#JS-中的数据类型被分为两大类：&quot; class=&quot;headerlink&quot; title=&quot;JS 中的数据类型被分为两大类：&quot;&gt;&lt;/a&gt;JS 中的数据类型被分为两大类：&lt;/h2&gt;&lt;div class=&quot;story</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络通信原理</title>
    <link href="https://resonance.fun/2021/07/25/yuque/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://resonance.fun/2021/07/25/yuque/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-25T12:03:21.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>网络通信中有 tcp/ip、ftp、arp、http 等这些协议或模型，他们本质上解决的问题其实是主机与主机之间的网络通信的问题。</p><h2 id="主机通信的必要条件"><a href="#主机通信的必要条件" class="headerlink" title="主机通信的必要条件"></a>主机通信的必要条件</h2><div class="story post-story"><ol><li>主机之间需要有传输介质例如网线、光纤、蓝牙、Wifi 等。</li><li>主机上必须要有网卡设备主要完成信号的调制和解调。无论我们使用哪种编程语言，计算机都不能直接识别，因为在计算机的世界中，一切都是以二机制的形式存在。A 主机将封装好的二进制数据，通过网卡转换为电信号（调制），再通过传输介质发送给 B 主机；B 主机接收到信号后，通过网卡将电信号转换为二进制（解调），再由 B 主机自己的通信体系对数据进行拆包、解包，最终在我们的应用程序里获取到 A 主机发送过来的数据。</li><li>主机之间需要协商网络速率A、B 主机由于网卡的网络速率不同，所以在通信之间需要协商网络速率，让他们保持一致。</li></ol></div><h2 id="网络通讯方式"><a href="#网络通讯方式" class="headerlink" title="网络通讯方式"></a>网络通讯方式</h2><div class="story post-story"><ol><li>交换机通信</li><li>路由器通信</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1429353/1627260256341-6939a46a-da3f-4e29-9414-0e07d4e12319.png#clientId=u06388d18-a111-4&from=paste&height=1366&id=u0e464cc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2732&originWidth=2048&originalType=binary%E2%88%B6=1&size=369092&status=done&style=stroke&taskId=ufcd07110-e9be-4895-b5e3-fba7584ccf8&width=1024" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/1429353/1627260256341-6939a46a-da3f-4e29-9414-0e07d4e12319.png#clientId=u06388d18-a111-4&from=paste&height=1366&id=u0e464cc1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2732&originWidth=2048&originalType=binary%E2%88%B6=1&size=369092&status=done&style=stroke&taskId=ufcd07110-e9be-4895-b5e3-fba7584ccf8&width=1024" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"></p></div><h2 id="网络层次模型"><a href="#网络层次模型" class="headerlink" title="网络层次模型"></a>网络层次模型</h2><div class="story post-story"><p>为了兼容不同厂商生产的不同品牌的设备，需要一个组织对它们制定一个模型，这个模型就是七层网络模型 OSI。这个模型分别有物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><ol><li>物理层：各种物理设备和标准</li><li>数据链路层：确定目标主机</li><li>网络层：确定目标网络</li><li>传输层：控制数据传输可靠性</li><li>会话层：控制网络连接建立与终止</li><li>表示层：数据加密、转换、压缩</li><li>应用层：用户与网络的接口</li></ol><p>数据从 A 主机发送到 B 主机时，先根据层次从高到低的进行封装，到了 B 主机后，会根据层次从低到高一层一层的解包数据，最后在应用层中拿到 A 主机发送过来的原始数据。tcp/ip 模型：</p><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>应用层</li></ol></div><h2 id="数据封装与解封装"><a href="#数据封装与解封装" class="headerlink" title="数据封装与解封装"></a>数据封装与解封装</h2><div class="story post-story"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络通信中有 tcp/ip、ftp、arp、http 等这些协议或模型，他们本质上解决的问题其实是主机与主机之间的网络通信的问题。&lt;/p&gt;
&lt;h2 id=&quot;主机通信的必要条件&quot;&gt;&lt;a href=&quot;#主机通信的必要条件&quot; class=&quot;headerlink&quot; title=&quot;主</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>知识汇总</title>
    <link href="https://resonance.fun/2021/06/29/yuque/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://resonance.fun/2021/06/29/yuque/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2021-06-29T16:21:19.000Z</published>
    <updated>2022-06-28T21:13:34.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS-的模块化方案"><a href="#JS-的模块化方案" class="headerlink" title="JS 的模块化方案"></a>JS 的模块化方案</h2><div class="story post-story"><p>在浏览器端，有 AMD，通过 require.js 库实现，具有异步按需加载和兼容性好的特点。有 ES Module，它是一种新特性，通过 import、export 实现导入和导出，它的兼容性不太好。在 NodeJS 端，有 CommonJS 方案，它是同步加载的</p></div><h2 id="JS-小数点计算为什么会丢失精度"><a href="#JS-小数点计算为什么会丢失精度" class="headerlink" title="JS 小数点计算为什么会丢失精度"></a>JS 小数点计算为什么会丢失精度</h2><div class="story post-story"><h2 id="JS-如何精确浮点计算"><a href="#JS-如何精确浮点计算" class="headerlink" title="JS 如何精确浮点计算"></a>JS 如何精确浮点计算</h2><p>例如：如何实现 0.1+0.2=0.3</p></div><h2 id="JS-如何进行大数计算"><a href="#JS-如何进行大数计算" class="headerlink" title="JS 如何进行大数计算"></a>JS 如何进行大数计算</h2><div class="story post-story"><p>Int 类型超出最大安全数的计算</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS-的模块化方案&quot;&gt;&lt;a href=&quot;#JS-的模块化方案&quot; class=&quot;headerlink&quot; title=&quot;JS 的模块化方案&quot;&gt;&lt;/a&gt;JS 的模块化方案&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;在浏览器端，
有 AMD</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webpack核心原理</title>
    <link href="https://resonance.fun/2021/06/27/yuque/Webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>https://resonance.fun/2021/06/27/yuque/Webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-27T03:49:50.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>对于<code>Webpack</code>来说，它本质上就是一个模块打包器，正是由于有了<code>Loader</code>和<code>Plugin</code>，才让<code>Webpack</code>有了其他各种各样的功能。</p><h2 id="Webpack-打包后的文件"><a href="#Webpack-打包后的文件" class="headerlink" title="Webpack 打包后的文件"></a>Webpack 打包后的文件</h2><div class="story post-story"><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo &amp;&amp; cd demo</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack webpack-cli html-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="comment">// devtool: &#x27;none&#x27;, // webpack5中不用配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;built.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="运行打包"><a href="#运行打包" class="headerlink" title="运行打包"></a>运行打包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn webpack</span><br></pre></td></tr></table></figure><p><code>Webpack4</code>打包结果：在<code>Webpack4</code>中，<code>Webpack</code>打包后的文件只是一个<code>IIFE</code>，这个函数的参数是一个“模块定义”的对象。键名是当前被加载文件的文件路径和文件名拼接而来的，键值是一个函数(和<code>NodeJS</code>中的模块加载有些类似)，这个函数会在将来的某个时机被调用，同时会接收到一定的参数，利用这些参数就可以实现模块的加载操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(</span><br><span class="line">      <span class="string">&quot;const test = __webpack_require__(/*! ./test */ \&quot;./src/test.js\&quot;)\nconsole.log(&#x27;hello wlord!&#x27;)\nconsole.log(test)\n\nmodule.exports = &#x27;Index Export&#x27;\n\n//# sourceURL=webpack:///./src/index.js?&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;./src/test.js&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(</span><br><span class="line">      <span class="string">&quot;console.log(11111)\n\n\nmodule.exports = &#x27;Test Exports&#x27;\n\n//# sourceURL=webpack:///./src/test.js?&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Webpack5</code>打包结果：而在<code>Webpack5</code>中，模块定义对象被放到函数内部了，函数参数是空的，代码相比<code>Webpack4</code>更少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">    <span class="string">&quot;./src/index.js&quot;</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      __unused_webpack_exports,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_require__</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(</span><br><span class="line">        <span class="string">&quot;const test = __webpack_require__(/*! ./test */ \&quot;./src/test.js\&quot;)\nconsole.log(&#x27;hello wlord!&#x27;)\nconsole.log(test)\n\nmodule.exports = &#x27;Index Export&#x27;\n\n//# sourceURL=webpack://01/./src/index.js?&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./src/test.js&quot;</span>: <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(</span><br><span class="line">        <span class="string">&quot;console.log(11111)\n\n\nmodule.exports = &#x27;Test Exports&#x27;\n\n//# sourceURL=webpack://01/./src/test.js?&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">    <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">      <span class="comment">// no module.id needed</span></span><br><span class="line">      <span class="comment">// no module.loaded needed</span></span><br><span class="line">      <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// startup</span></span><br><span class="line">  <span class="comment">// Load entry module and return exports</span></span><br><span class="line">  <span class="comment">// This entry module is referenced by other modules so it can&#x27;t be inlined</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_exports__ = __webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们可以看到打包后是一个<code>IIFE</code>(自执行函数)，而这是为了产生一个闭包。</p></div><h2 id="单文件打包执行流程解析"><a href="#单文件打包执行流程解析" class="headerlink" title="单文件打包执行流程解析"></a>单文件打包执行流程解析</h2><div class="story post-story"><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1624954520614-a2d77776-1d40-42f2-8a94-fe74ab2a5ce0.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1624954520614-a2d77776-1d40-42f2-8a94-fe74ab2a5ce0.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="Webpack-打包主流程分析"><a href="#Webpack-打包主流程分析" class="headerlink" title="Webpack 打包主流程分析"></a>Webpack 打包主流程分析</h2><div class="story post-story"><p>编写调试代码，新建<code>debug.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(options);</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    stats.toJson(&#123;</span><br><span class="line">      <span class="attr">entries</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">assets</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打开<code>VS Code</code>调试模式，将断点定到第四行，接下来就开始分析它的主要流程：<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1625118006345-c39ec915-6b29-46c3-90dd-0e76dc54b3ad.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1625118006345-c39ec915-6b29-46c3-90dd-0e76dc54b3ad.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于&lt;code&gt;Webpack&lt;/code&gt;来说，它本质上就是一个模块打包器，正是由于有了&lt;code&gt;Loader&lt;/code&gt;和&lt;code&gt;Plugin&lt;/code&gt;，才让&lt;code&gt;Webpack&lt;/code&gt;有了其他各种各样的功能。&lt;/p&gt;
&lt;h2 id=&quot;Webpa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://resonance.fun/2021/06/07/yuque/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://resonance.fun/2021/06/07/yuque/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-06-07T01:49:08.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>在没有 Node 的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是 Node，如果说 Ajax 给前端能力范围带来了一次革命，那么 Node 也同样给前端工程化带来一次伟大的革命！</p><h2 id="工程化概述"><a href="#工程化概述" class="headerlink" title="工程化概述"></a>工程化概述</h2><div class="story post-story"><p>前端工程化是指遵循一定标准和规范，通过工具去提升效率，他是一种降低成本的手段。</p><p>当下前端功能不断提高，业务复杂日益复杂。因此，在我们没有工程化之前，我们不得不面对一些问题：</p><ul><li>想要使用 ES6+新特性，但是兼容有问题</li><li>想要使用 Less/Sass/PostCSS 增强 CSS 的编程性，但是运行环境不能直接支持。</li><li>想要使用模块化的方式提高项目的可维护性，但是运行环境不能直接支持。</li><li>部署上线前需要<strong>手动</strong>压缩代码及资源文件，部署过程需要<strong>手动</strong>上传代码到服务器。</li><li>多人协作开发，无法硬性统一大家的代码风格，从仓库中 pull 的代码质量无法保证。</li><li>部分功能开发时需要等待后端服务接口提前完成</li></ul><h3 id="工程化主要解决的问题"><a href="#工程化主要解决的问题" class="headerlink" title="工程化主要解决的问题"></a>工程化主要解决的问题</h3><ul><li>传统语言或语法的弊端</li><li>无法使用模块化/组件化</li><li>重复的机械式工作</li><li>代码风格统一、质量保证</li><li>依赖后端服务接口支持</li><li>整体依赖后端项目</li></ul><h3 id="一个项目过程中工程化的表现"><a href="#一个项目过程中工程化的表现" class="headerlink" title="一个项目过程中工程化的表现"></a>一个项目过程中工程化的表现</h3><p>一切以提高效率、降低成本、质量保证为目的的手段都属于工程化。一切重复的工作都应该被自动化，例如：创建项目一&gt;编码一&gt;预览/测试一&gt;提交一&gt;部署</p><h3 id="工程化不等工具"><a href="#工程化不等工具" class="headerlink" title="工程化不等工具"></a>工程化不等工具</h3><p>工具不是工程化的核心，工程化的核心是对项目整体的规划、架构。而工具只是帮助我们去实现和落地的一种手段，例如文件的组织结构，源代码的开发范式(语法、规范、标准)一些成熟的工程化集成有：create-react-app、vue-cli、angular-cli、gatsby-cli</p><p>工程化的一切都应该归功于 Node.js，它让整个前端进行了一次工业革命，可以说，没有 Node.js 就没有现在的前端。因为几乎所有的工程化工具都是用 Node.js 来编写的。但是，面对各种技术工具和新鲜名词，我们不必盲目追求，因为所有的工具都应该是为了解决问题而存在的。</p><p>从一个项目的开发过程开始，我们来了解前端工程化具体实现：</p></div><h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><div class="story post-story"><p>自动帮助我们创建项目基础结构，并且提供项目规范和约定。看似很普通的需求，背后却隐藏了一定的哲学。因为除了创建文件，它更重要的是还给开发者<strong>提供了一套规范和约定</strong>。比如在开发类似项目时，他们都有以下特征：</p><ul><li>相同的组织结构</li><li>相同的开发范式</li><li>相同的模块依赖</li><li>相同的工具配置</li><li>相同的基础代码</li></ul><p>这导致我们在创建新项目时，有大量的重复工作要做，所以脚手架工具就是用来解决这一类问题的。我们可以通过脚手架快速搭建项目基础骨架，然后基于这个项目骨架来开发项目。由于前端技术选型比较多样，另外也没有一个统一的标准，所以前端方向的脚手架不会集成在某个 IDE 中，它都是以一个独立的工具存在。</p><h3 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h3><p>是一个用于创建现代化 web 应用的脚手架工具。不同于<code>vue-cli</code>这样的工具，它更像一个脚手架的运行平台，我们可以通过<code>Yeoman</code>搭配不同的<code>generator</code>去创建任何类型的项目。也就是说，我们可以创建自己的<code>generator</code>，从而定制属于我们自己的前端的前端脚手架。</p><p>但是它的优点也是它的缺点，在专注于基于框架开发项目的人的眼中，它过于通用化，不够专注。所以他们更愿意使用<code>vue-cli</code>这种专注于某个框架的脚手架。</p><h3 id="Yeoman-基本使用"><a href="#Yeoman-基本使用" class="headerlink" title="Yeoman 基本使用"></a>Yeoman 基本使用</h3><h4 id="安装Yeoman"><a href="#安装Yeoman" class="headerlink" title="安装Yeoman"></a>安装<code>Yeoman</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add yo</span><br></pre></td></tr></table></figure><p>Yeoman 是搭配特定的 generator 才能使用的，所以还需要安装 generator</p><h4 id="安装对应的generator"><a href="#安装对应的generator" class="headerlink" title="安装对应的generator"></a>安装对应的<code>generator</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add generator-node</span><br></pre></td></tr></table></figure><h4 id="通过yo运行generator"><a href="#通过yo运行generator" class="headerlink" title="通过yo运行generator"></a>通过<code>yo</code>运行<code>generator</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo node</span><br></pre></td></tr></table></figure><p>然后根据提示输入项目的相关信息，完成后会自动生成项目。</p><h3 id="Sub-Generator"><a href="#Sub-Generator" class="headerlink" title="Sub Generator"></a>Sub Generator</h3><p>有时候我们并不想安转完整的项目，仅仅只是想在原有的项目基础之上去增加部分文件。</p><p>例如我们想运行<code>generator-node</code>子集下面的 cli 命令，创建一个 cli 应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo node:cli</span><br></pre></td></tr></table></figure></div><h2 id="自定义-Generator"><a href="#自定义-Generator" class="headerlink" title="自定义 Generator"></a>自定义 Generator</h2><div class="story post-story"><p>虽然市面上也有很多<code>generator</code>，但是他们并不包含我们自己项目的一些公用的依赖或者业务代码。所以，我们仍然有必要自己编写一个专属的<code>generator</code>。</p><h3 id="创建-Generator-模块"><a href="#创建-Generator-模块" class="headerlink" title="创建 Generator 模块"></a>创建 Generator 模块</h3><p>generator 本质上就是一个 npm 模块。不同于其他模块，yeoman 的 ganerator 模块名称必须是 generator-<name>的格式命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir generator</span><br><span class="line">cd generator</span><br><span class="line">yarn init</span><br><span class="line">yarn add yeoman-generator</span><br></pre></td></tr></table></figure><p>上述命令完成后，接下来我们打开项目，然后在项目根目录创建<code>generators/app/index.js</code>文件这个文件会作为<code>Generator</code>的核心入口它需要导出一个继承自<code>Yeoman Generator</code>的类Yeoman Generator 在工作时会自动调用我们在此类中定义的一些生命周期方法我们在这些方法中可以调用父类提供的一些工具方法实现一些功能，例如文件写入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Genetator = <span class="built_in">require</span>(<span class="string">&quot;yeoman-generator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="built_in">this</span>.fs.write(<span class="built_in">this</span>.destinationPath(<span class="string">&quot;temp.txt&quot;</span>), <span class="built_in">Math</span>.random().toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们把这个模块，挂载到本地全局上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure><p>接着就可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo simple  // simple 是上面创建项目定义的项目名称</span><br></pre></td></tr></table></figure><h3 id="根据模板创建文件"><a href="#根据模板创建文件" class="headerlink" title="根据模板创建文件"></a>根据模板创建文件</h3><p>很多时候我们需要自动去创建的文件有很多，而且文件的内容也相对复杂，在这样的情况下，我们可以用模板来创建文件，因为这样更加便捷。在 app 目录下创建<code>templates/foo.txt</code>文件，模板文件支持 ejs 模板引擎的模板语法，比如我们可以使用模板标记<code>&lt;%= title %&gt;</code>动态输出内容，也可以做一些判断、循环的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Genetator = <span class="built_in">require</span>(<span class="string">&quot;yeoman-generator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="built_in">this</span>.templatePath(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = &#123; <span class="attr">title</span>: <span class="string">&quot;Hello xsl~&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tmpl, output, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对于手动创建每一个文件，通过模板创建大大提升了效率，特别是文件比较多比较复杂的情况下。</p><h3 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a>接收用户输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="title">prompting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Yeoman 在询问用户环节会自动调用此方法</span></span><br><span class="line">   <span class="comment">//  在此方法中可以调用父类的prompt() 方法发出对用户的命令行询问</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.prompt([&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;input&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">      <span class="attr">message</span>:<span class="string">&quot;Your project name&quot;</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="built_in">this</span>.appname, <span class="comment">// appname为项目生成目录名称</span></span><br><span class="line">   &#125;]).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.answers = answers</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">writing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="built_in">this</span>.fs.copyTpl(tmpl, output, <span class="built_in">this</span>.answers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Plop"><a href="#Plop" class="headerlink" title="Plop"></a>Plop</h2><div class="story post-story"><p>一个小而美的脚手架工具。主要创建项目中特定类型文件的小工具，它类似于 Yeoman 中的 Sub Generator。不过它一般不会独立运行，它用来集成在项目当中，去创建同类型的项目文件。在一个项目当中使用 Plop，需要以下几个步骤：</p><ol><li>将 Plop 模块作为项目开发依赖安装</li><li>在项目根目录下创建一个 plopfile.js 文件</li><li>在 plopfile.js 文件中定义脚手架任务</li><li>编写用于生成特定类型文件的模板</li><li>通过 Plop 提供的 CLI 运行脚手架任务</li></ol></div><h2 id="脚手架工作原理"><a href="#脚手架工作原理" class="headerlink" title="脚手架工作原理"></a>脚手架工作原理</h2><div class="story post-story"><p>脚手架启动后，会先询问用户一些问题，然后根据这些问题的答案，结合一些模版文件去自动生成项目结构。</p></div><h2 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h2><div class="story post-story"><blockquote><p>一切重复工作本应该自动化。自动化：让机器代替手工；构建：将 A 转换为 B。</p></blockquote><p>将开发环境的源代码自动化构建为生产环境可运行的代码。一般我们把这个转换的过程称为自动化构建工作流，它的作用是尽可能脱离运行环境兼容带来的问题，在开发环境阶段使用一些提高效率的语法、规范和标准。</p><p>自动化构建将那些不被支持的『特性』，转换为能够直接运行的代码，我们在开发过程中就可以尽情使用提高效率的代码了。</p></div><h2 id="NPM-Scripts-自动构建工作流"><a href="#NPM-Scripts-自动构建工作流" class="headerlink" title="NPM Scripts 自动构建工作流"></a>NPM Scripts 自动构建工作流</h2><div class="story post-story"><p>可以在 package.json 中定义一些与项目相关的构建命令，它是实现自动化构建工作流的最简方式。在启动 serve 之前构建项目：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;preserve&quot;</span>: <span class="string">&quot;yarn build&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync .&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时执行多个任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add npm-run-all</span><br></pre></td></tr></table></figure><p>然后在 scripts 中添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;build&quot;</span>: <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync .&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;run-p build serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听文件变化并重新编译，监听文件变化并自动热更新：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;build&quot;</span>: <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync . --files \“css/*.css\&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;run-p build serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="常见的自动化构建工具"><a href="#常见的自动化构建工具" class="headerlink" title="常见的自动化构建工具"></a>常见的自动化构建工具</h2><div class="story post-story"><blockquote><p>严格意义上来说，Webpack 属于模块化打包工具，所以不归类在此处</p></blockquote><h3 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h3><p>最早的前端构建系统，生态完善。因为它基于临时文件编译的，它在构建过程会对磁盘进行读写操作，所以构建速度会比较慢。例如它在工作时，上个插件将构建结果存储到一个临时文件中，下一个插件又会基于这个临时文件读取内容。如果处理的环节越多，那么对磁盘读写的次数也就会越多，也会更加耗时。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>对于文件读写都是在内存中完成的，所以相对于磁盘读写操作，它的速度更快。同时他也支持多个任务同时执行。它的使用方式比 Grunt 更简单，生态也很完善，是目前前端构建最流行的系统。</p><h3 id="FIS"><a href="#FIS" class="headerlink" title="FIS"></a>FIS</h3><p>百度前端开源内部的构建系统，它把我们在项目中常见的需求都集成在内部了。例如资源加载、模块化开发、代码部署、性能优化。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在没有 Node 的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是 Node，如果说 Ajax 给前端能力范围带来了一次革命，那么 Node 也同样给前端工程化带来一次伟大的革命</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS性能优化</title>
    <link href="https://resonance.fun/2021/05/26/yuque/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://resonance.fun/2021/05/26/yuque/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-26T13:16:12.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><div class="story post-story"><p>内存为什么需要管理？如果我们在写代码的过程中，不够了解内存的管理机制，写出不容易被察觉的内存问题性代码，就会给程序带来意想不到的 BUG。</p><ul><li>内存：由可读写单元组成，表示一片可操作空间</li><li>管理：人为的去操作一片空间的申请、使用和释放。</li><li>内存管理: 开发者主动申请空间、使用空间、释放空间。</li><li>管理流程:申请一使用一释放</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请空间（由于JavaScript没有提供相关api，我们只能通过JS执行引擎，遇到变量定义的时候，自动去申请空间）</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 使用空间</span></span><br><span class="line">obj.name = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><h2 id="JS-中的垃圾回收"><a href="#JS-中的垃圾回收" class="headerlink" title="JS 中的垃圾回收"></a>JS 中的垃圾回收</h2><div class="story post-story"><p>对象在什么情况下会被视为垃圾？</p><ul><li>JS 中的垃圾回收是自动的</li><li>当对象不再被引用时，被视为垃圾</li><li>对象不能从根(全局执行上下文)上访问到时是垃圾</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> ali = obj;</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// &#123;name: 11&#125; 被ali引用，不是一个垃圾</span></span><br></pre></td></tr></table></figure></div><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><div class="story post-story"><p>GC：垃圾回收机制；它可以找到内存中的垃圾、并释放和回收空间。那么什么样的东西可以被当作垃圾呢？</p><ul><li>程序中不再使用的对象</li><li>程序中能再访问的对象</li></ul><p>GC 算法：算法就是工作时查找和回收所遵循的规则。常见的 GC 算法有：</p><ul><li><p>引用计数</p><p>判断对象的引用来决定是不是垃圾</p></li><li><p>标记清除</p><p>给活动对象添加标记，来判断他是不是垃圾</p></li><li><p>标记整理</p><p>类似标记清除</p></li><li><p>分代回收</p></li></ul></div><h2 id="引用计数算法实现原理"><a href="#引用计数算法实现原理" class="headerlink" title="引用计数算法实现原理"></a>引用计数算法实现原理</h2><div class="story post-story"><p>核心思想：内部通过一个计数器来维护当前对象的引用数，从而判断当前对象的引用数是否为 0，来决定它是不是一个垃圾对象。当这个对象的引用为 0 的时候，GC 就开始工作，将其所在的对象空间进行回收和释放，然后再使用。</p><p>当某个对象的引用关系发生改变时，引用计数器就会主动去修改当前对象所对应的引用数值。当引用为 0 时，GC 就会将其所在的空间回收。引用关系发生改变：假设我们的代码里面有一个对象空间，如果有一个变量名指向它，这时就把对象空间的引用加 1，如果又有一个变量指向它，那就再加 1；如果是减少的情况，例如取消引用，那就减 1。为 0 时，GC 就会立即将其回收。</p><h3 id="引用计数算法的优缺点"><a href="#引用计数算法的优缺点" class="headerlink" title="引用计数算法的优缺点"></a>引用计数算法的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>发现垃圾时立即回收</li></ul><p>如果引用为 0 就会立即进行回收、释放</p><ul><li>最大限度减少程序暂停</li></ul><p>由于引用计数算法会时刻监控着那么引用为 0 的对象，如果在栈满时，会以最快的速度释放空间。程序就不会因为栈满而停止运行了。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法回收循环引用的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 在全局上下文中，没有使用到这两个对象了，他们已经可以被回收了</span></span><br><span class="line">  <span class="comment">// 但是由于这两个对象相互循环引用，在使用引用计数算法时，他仍然还是有引用并且不为0，因此GC无法对其回收。</span></span><br><span class="line">  obj1.name = obj2;</span><br><span class="line">  obj2.name = obj1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 当函数执行完毕，会释放里面的空间</span></span><br></pre></td></tr></table></figure><ul><li>时间开销大</li></ul><p>需要时刻监控对象是否修改，如果有很多的对象需要修改，需要的时间就会更久一点</p></div><h2 id="标记清除算法实现原理"><a href="#标记清除算法实现原理" class="headerlink" title="标记清除算法实现原理"></a>标记清除算法实现原理</h2><div class="story post-story"><blockquote><p>标记清除算法相较于引用计数算法，他能解决更多的问题，因此它在 V8 中被大量使用。</p></blockquote><p>核心思想：将整个垃圾回收操作分为两个阶段；第一个阶段，遍历所有对象，然后找到这些活动的对象(可达对象)并进行标记，如果不可达就不会标记并且会在第二个阶段被回收掉。第二个阶段，再次遍历所有对象，然后把那些没有被标记的对象进行清除操作，并把第一阶段中设置的标记抹掉，便于下次 GC 还能够正常工作。最后就可以把相应的垃圾进行回收，然后再把回收的空间交给空闲链表进行维护，下次程序执行就可以向空闲链表申请空间进行使用。</p><h3 id="标记清除算法的优缺点"><a href="#标记清除算法的优缺点" class="headerlink" title="标记清除算法的优缺点"></a>标记清除算法的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>解决了引用计数算法中对象循环引用无法回收的问题</li></ul><p>标记清除算法会递归遍历所有对象，然后将可达对象进行标记；如果两个对象相互循环引用，一旦对象不可达，它始终也能清除标记，GC 也能正常回收。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>不会立即回收对象</p><pre><code> 当遍历对象的时候，即使发现了不可达对象，它也不会立即去进行回收，只有等到最后才会去回收，而且其实这个时候程序是停止工作的。</code></pre></li><li><p>空间碎片化</p></li></ul><p>回收后的空闲地址有可能不是连续的，使用空间时很容易造成空间上的浪费。</p></div><h2 id="标记整理算法实现原理"><a href="#标记整理算法实现原理" class="headerlink" title="标记整理算法实现原理"></a>标记整理算法实现原理</h2><div class="story post-story"><blockquote><p>和标记清除算法一样，标记整理算法在 V8 也被频繁使用</p></blockquote><p>标记整理算法其实可以看做是标记清除算法的增强版，因为它们在第一个阶段是相同的，都会先遍历所有对象，然后对当前活动对象(可达对象)进行标记操作。</p><p>但是不同的是，标记清除算法是直接对没有标记的进行清除，而标记整理算法会在清除之前进行整理操作，移动对象的位置，并让他们在地址上产生连续。</p><p>这样连续的可用空间，能够最大化的让程序使用到内存释放出来的空闲空间，避免空间碎片化造成空间浪费。</p><h3 id="标记整理算法优缺点"><a href="#标记整理算法优缺点" class="headerlink" title="标记整理算法优缺点"></a>标记整理算法优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>减少碎片化空间</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>不会立即回收垃圾对象</p></div><h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><div class="story post-story"><p>V8 是一款主流的 JavaScript 执行引擎。V8 之所以有优越的性能，是因为它优秀的内存管理机制以及 V8 采用的即时编译机制。V8 内存的上限设定：64 位 1.5G 32 位 800M</p><h3 id="V8-垃圾回收策略"><a href="#V8-垃圾回收策略" class="headerlink" title="V8 垃圾回收策略"></a>V8 垃圾回收策略</h3><p>采用分代回收的思想，把内存空间按照一定的规则分为两类，<strong>新生代</strong>存储区和<strong>老生代</strong>存储区。针对不同代采用最高效的 GC 算法，从而对不同的对象进行回收操作。<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1622989590392-e6acf015-001d-47af-a104-21ed4ab67419.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1622989590392-e6acf015-001d-47af-a104-21ed4ab67419.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="V8-中常用的-GC-算法"><a href="#V8-中常用的-GC-算法" class="headerlink" title="V8 中常用的 GC 算法"></a>V8 中常用的 GC 算法</h3><ul><li>分代回收</li><li>空间复制</li><li>标记清除</li><li>标记整理</li><li>标记增量</li></ul><h3 id="V8-如何回收新生代对象"><a href="#V8-如何回收新生代对象" class="headerlink" title="V8 如何回收新生代对象"></a>V8 如何回收新生代对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1429353/1622954154226-5f921e40-e7a4-4868-9956-afae918bd89f.png#crop=0&crop=0&crop=1&crop=1&height=89&id=ubca4cc3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=831&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12542&status=done&style=shadow&title=&width=749" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/1429353/1622954154226-5f921e40-e7a4-4868-9956-afae918bd89f.png#crop=0&crop=0&crop=1&crop=1&height=89&id=ubca4cc3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=831&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12542&status=done&style=shadow&title=&width=749" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png">如图所示，V8 内部将空间分为了两部分，左侧(From To)小空间专门用于存储新生代对象，在 64 位操作系统中，它的大小为 32M，32 位系统中，它的大小是 16M；<strong>新生代指的是存活时间较短的对象</strong>。比如局部作用域(函数)中定义的变量，当函数执行完，函数出栈时函数中的变量就会被回收。那么，V8 是如何完成新生代对象回收的呢？</p><h4 id="新生代对象回收实现"><a href="#新生代对象回收实现" class="headerlink" title="新生代对象回收实现"></a>新生代对象回收实现</h4><p>回收过程采用复制算法+标记整理算法。首先它会将左侧的小空间也会分成两个部分(From、To)，而且这两个空间是相同大小的。其中我们将 From 称为使用空间，将 To 称为空闲空间。当程序要申请空间时，它会将新申请的活动对象存储于 From 空间，这个时候 To 空间是空闲的没有使用。当 From 使用到一定程度后就会触发 GC 操作，它将 From 空间中的活动对象进行标记，然后对空间整理为连续的，便于后续不会产生碎片化空间，这些操作完成后再将这些活动对象拷贝至 To 空间，From 空间里的对象就有一份备份，这就意味着可以对它进行回收，因为活动对象都在 To 空间里有所体现，所以会直接把 From 空间中的对象进行回收。</p><h4 id="回收细节"><a href="#回收细节" class="headerlink" title="回收细节"></a>回收细节</h4><p>如果我们在拷贝时，发现某一个变量对象所指向的空间，在我们老生代存储区也存在，这个时候就会发生<strong>晋升</strong>的现象。这里的晋升指的就是将新生代的对象移动至老生代中进行存储。判断是否晋升的条件有以下几个：</p><ul><li>经过一轮 GC 还存活的新生代对象需要晋升</li></ul><p>如果新生代中的对象经过一轮 GC 还存活的，我们就可以把它拷贝至老生代存储区进行存储操作。</p><ul><li>在拷贝的过程中，发现 To 空间的使用率超过 25%，也需要把这次的活动对象都移动至老生代存储区中进行存储。</li></ul><p>To 空间的使用率如果超过了限制，那么新进来的对象空间好像就存放不进去了，所以在这里有 25%的限制操作。</p><h3 id="V8-如何回收老生代对象"><a href="#V8-如何回收老生代对象" class="headerlink" title="V8 如何回收老生代对象"></a>V8 如何回收老生代对象</h3><p>如上图所示，老生代对象存放在右侧老生代区域。同样针对于老生代存储区也有大小限制，64 位的操作系统为 1.4G，32 位的操作系统为 700M。老生代对象就是指存活时间较长的对象，例如在全局上下文中存放的变量、闭包中存放的变量数据等。</p><h3 id="老生代对象回收实现"><a href="#老生代对象回收实现" class="headerlink" title="老生代对象回收实现"></a>老生代对象回收实现</h3><p>主要采用标记清除、标记整理、增量标记算法。其实首先使用的是标记清除算法完成垃圾空间的释放和回收，因为它执行的速度是比较快的。当把新生代区域中的内容往老生代存储区域中移动(也就是晋升)的时候，而且老生代的空间又不足以存放所移过来的这些对象，就会触发标记整理，把之前的碎片空间进行整理回收，让我们有更多的空间进行使用。最后会采用增量标记算法对回收效率进行提升。</p><h4 id="新老代细节对比"><a href="#新老代细节对比" class="headerlink" title="新老代细节对比"></a>新老代细节对比</h4><p>新生代区域垃圾回收使用空间换时间，因为他采用的是复制算法，这也就意味着每时每刻都会有空闲的空间存在。但是新生代存储区本身的存储就很小，那么优化出来的空间就更小，所以相对于它带来的时间效率上的提升是微不足道的。老生代区域垃圾回收不适合复制算法，因为他的空间很大，复制很多对象时也会非常消耗时间。</p></div><h2 id="标记增量如何优化垃圾回收"><a href="#标记增量如何优化垃圾回收" class="headerlink" title="标记增量如何优化垃圾回收"></a>标记增量如何优化垃圾回收</h2><div class="story post-story"><p>当垃圾回收机制工作的时候，是会阻塞我们的程序运行的，程序执行完成后，会暂停下来进行回收操作。标记增量其实就是将一整段的垃圾回收操作拆分成多个小步骤组合着去完成，从而替换掉我们之前一口气去做完的垃圾回收操作。这样做的好处是可以让程序和垃圾回收机制交替着去执行，而不是执行程序时不能进行垃圾回收，垃圾回收时不能执行程序，这样带来的时间消耗也是非常合理的。而且 GC 执行的效率非常快，给用户带来的体验也更加友好了。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;p&gt;内存为什么需要管理？
如果我们在写代码的过程中，不够了解内存的管</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES新特性与TypeScript</title>
    <link href="https://resonance.fun/2021/05/26/yuque/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript/"/>
    <id>https://resonance.fun/2021/05/26/yuque/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript/</id>
    <published>2021-05-26T07:47:31.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>我们常说 ECMAScript 是一种脚本语言，通常我们把 ECMAScript 看做是一种标准化规范，而实际上是 JavaScript 是 ECMAScript 的扩展语言。</p><p>在浏览器环境中，JavaScript 等于 ECMAScript 加上 WEB API(DOM+BOM)</p><p>在 NodeJs 环境中，JavaScript 等于 ECMAScript 加上 Node APIS(fs、net、etc.)</p><p>所以，JavaScript 语言本身指的就是 ECMAScript。</p><p>由于 ES5.1 以后的版本相较于之前有了很大的改动，有很多人就习惯简称它们为 ES6，其实他的准确简称应该是 ES2015。</p><h2 id="ES2015-let-与块级作用域"><a href="#ES2015-let-与块级作用域" class="headerlink" title="ES2015 let 与块级作用域"></a>ES2015 let 与块级作用域</h2><div class="story post-story"><p>var 会被变量提升，let 不会有这个问题</p></div><h2 id="ES2015-const"><a href="#ES2015-const" class="headerlink" title="ES2015 const"></a>ES2015 const</h2><div class="story post-story"><p>const 声明的常量不能再次修改引用的内存地址。</p></div><h2 id="ES2015-数组的解构"><a href="#ES2015-数组的解构" class="headerlink" title="ES2015 数组的解构"></a>ES2015 数组的解构</h2><div class="story post-story"><p>const [a.b] = [100, 200]可以根据位置提取对应的值</p></div><h2 id="ES2015-对象的解构"><a href="#ES2015-对象的解构" class="headerlink" title="ES2015 对象的解构"></a>ES2015 对象的解构</h2><div class="story post-story"><p>const {a} = {a:200}和数组不同的是，它需要指定解构的属性名</p></div><h2 id="ES2015-模板字符串"><a href="#ES2015-模板字符串" class="headerlink" title="ES2015 模板字符串"></a>ES2015 模板字符串</h2><div class="story post-story"><p>和传统的字符串相比，支持多行字符串，还可以使用插值表达式拼接内容，而不用像传统字符串用+号拼接，更便捷。</p></div><h2 id="ES2015-带标签的模板字符串"><a href="#ES2015-带标签的模板字符串" class="headerlink" title="ES2015 带标签的模板字符串"></a>ES2015 带标签的模板字符串</h2><div class="story post-story"><p>const str = console.log’hello wolrd’模板字符串前面可以带上一个函数，这个函数中可以接收到所有表达式出现的值。</p></div><h2 id="ES2015-字符串的扩展方法"><a href="#ES2015-字符串的扩展方法" class="headerlink" title="ES2015 字符串的扩展方法"></a>ES2015 字符串的扩展方法</h2><div class="story post-story"><p>startWithendWithincludes</p></div><h2 id="ES-2015-参数默认值"><a href="#ES-2015-参数默认值" class="headerlink" title="ES 2015 参数默认值"></a>ES 2015 参数默认值</h2><div class="story post-story"><p>function fn(a = 100){}可以在形参后面加上=值一定要将需要添加默认值的形参放在最后，不然可能导致参数默认值无法正常工作。比如:function fn(a=100,b){}fn(100) //我想要形参 a 有一个默认值，但是我可能只会传这一个参数，a 的参数默认值就不能正常工作。因为参数是依次传递的，可选的参数应该放在后面，保证必传的参数能够优先传递。</p></div><h2 id="ES2015-剩余参数"><a href="#ES2015-剩余参数" class="headerlink" title="ES2015 剩余参数"></a>ES2015 剩余参数</h2><div class="story post-story"><p>arguments…args</p></div><h2 id="ES2015-展开数组"><a href="#ES2015-展开数组" class="headerlink" title="ES2015 展开数组"></a>ES2015 展开数组</h2><div class="story post-story"><p>console.log(…[100,200,300])</p></div><h2 id="ES2015-箭头函数与-this"><a href="#ES2015-箭头函数与-this" class="headerlink" title="ES2015 箭头函数与 this"></a>ES2015 箭头函数与 this</h2><div class="story post-story"><p>在箭头函数中没有 this，它的 this 指向它的上级作用域。</p></div><h2 id="ES2015-对象字面量的增强"><a href="#ES2015-对象字面量的增强" class="headerlink" title="ES2015 对象字面量的增强"></a>ES2015 对象字面量的增强</h2><div class="story post-story"><p>对象中可以省略属性名对应的值，前提是属性名和字面量名称相同。</p></div><h2 id="ES2015-Object-assign"><a href="#ES2015-Object-assign" class="headerlink" title="ES2015 Object.assign"></a>ES2015 Object.assign</h2><div class="story post-story"><p>var obj3=Object.assign(obj1, obj2)用 obj2 覆盖 obj1 对象，返回的 obj3 它其实就是 obj1</p></div><h2 id="ES2015-Object-is"><a href="#ES2015-Object-is" class="headerlink" title="ES2015 Object.is"></a>ES2015 Object.is</h2><div class="story post-story"><p>==只比较值，不比较类型，会自动类型转换===比较值和类型，严格模式NaN ===NaN //falseObject.is(NaN,NaN)//true</p></div><h2 id="ES2015-Proxy"><a href="#ES2015-Proxy" class="headerlink" title="ES2015 Proxy"></a>ES2015 Proxy</h2><div class="story post-story"><p>可以对对象的属性改动进行检测和拦截</p></div><h2 id="ES2015-Proxy-对比-Object-defineProperty"><a href="#ES2015-Proxy-对比-Object-defineProperty" class="headerlink" title="ES2015 Proxy 对比 Object.defineProperty"></a>ES2015 Proxy 对比 Object.defineProperty</h2><div class="story post-story"><p>Proxy 功能更强大一些。proxy 能够检测 defineProperty 检测不到的行为，比如属性删除，方法调用可以对数组检测Proxy 是一种非侵入式的方式进行代理，不用对原来的对象做任何改动，而 Object.definePropery 则需要我们对原对象做一些特有的改动。</p></div><h2 id="ES2015-Reflect"><a href="#ES2015-Reflect" class="headerlink" title="ES2015 Reflect"></a>ES2015 Reflect</h2><div class="story post-story"><p>Reflect.getReflect.set提供了一套对对象操作的 api以前的操作方式可能会被废弃掉</p></div><h2 id="ES2015-Promise"><a href="#ES2015-Promise" class="headerlink" title="ES2015 Promise"></a>ES2015 Promise</h2><div class="story post-story"><p>异步编程解决方案</p></div><h2 id="ES2015-class"><a href="#ES2015-class" class="headerlink" title="ES2015 class"></a>ES2015 class</h2><div class="story post-story"><h2 id="es2015-静态方法"><a href="#es2015-静态方法" class="headerlink" title="es2015 静态方法"></a>es2015 静态方法</h2><h2 id="es2015-类的继承"><a href="#es2015-类的继承" class="headerlink" title="es2015 类的继承"></a>es2015 类的继承</h2><p>super</p></div><h2 id="ES2015-Set"><a href="#ES2015-Set" class="headerlink" title="ES2015 Set"></a>ES2015 Set</h2><div class="story post-story"><p>不重复的数组 常用来去重</p></div><h2 id="ES2015-Map"><a href="#ES2015-Map" class="headerlink" title="ES2015 Map"></a>ES2015 Map</h2><div class="story post-story"><p>let obj ={a:100}let o = new Map()o.set(obj, 666) //它的键就是 obj 对象本身严格的键值对集合，它的键可以是任意类型。</p></div><h2 id="ES2015-Symbol"><a href="#ES2015-Symbol" class="headerlink" title="ES2015 Symbol"></a>ES2015 Symbol</h2><div class="story post-story"><p>Symbol 表示独一无二的值，他可以作为对象的键( key)。</p><h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h4><p>内部维护了一个全局的注册表，提供了字符串和 Symbol 的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此Symbol.for(&quot;aa&quot;) = Symbol. for(&quot;aa&quot;) // true</span></span><br><span class="line"><span class="comment">// 如果传入的不是字符串，会自动转换为字符串。</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="literal">true</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot; true&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Symbol-用途"><a href="#Symbol-用途" class="headerlink" title="Symbol 用途"></a>Symbol 用途</h4><ol><li>我们在使用第三方模块时，想要对其扩展，由于我们不知道内部具体定义的哪些属性，在这种情况下，去为其扩展属性，就会很大可能发生冲突的问题。那么使用<code>Symbol</code>作为属性就不会出现这种问题。</li><li>可以为对象添加私有属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  [name]: <span class="string">&quot;xsl&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 只能通过这种方式访问</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.[name])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而当我们在外部使用时，由于不知道内部的唯一键是什么，因此只能通过实例间接访问，而无法在外部直接访问。</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>. log(obj.say)</span><br></pre></td></tr></table></figure><ol start="3"><li> <code>Symbol</code>提供了很多内置常量，用于作为内部方法的标识。这些标识符可以让自定义对象实现 JS 当中内置的接口。比如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol.iterator</span></span><br><span class="line"><span class="comment">// Symbol.hasInstance</span></span><br><span class="line"><span class="comment">// Symbol.toStringTag</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;XObject&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">// [ object XObject]</span></span><br></pre></td></tr></table></figure><p>对象的<code>Symbol</code>属性无法通过<code>for in</code>和<code>Object.keys</code>获取，<code>JSON.stringify</code>时<code>Symbol</code>的属性也会被忽略掉。<strong>可以使用</strong><code>**Object.getOwnPropertySymbols**</code><strong>获取对象的所有</strong><code>**Symbol**</code><strong>类型的属性。</strong></p></div><h2 id="ES2015-for-of"><a href="#ES2015-for-of" class="headerlink" title="ES2015 for of"></a>ES2015 for of</h2><div class="story post-story"><p>使用 for of 可以遍历所有数据类型默认可以对数组遍历需要实现统一的 Iterable 接口，数组默认内部已经实现了。</p></div><h2 id="ES2015-Iterable"><a href="#ES2015-Iterable" class="headerlink" title="ES2015 Iterable"></a>ES2015 Iterable</h2><div class="story post-story"><h2 id="ES2016-概述"><a href="#ES2016-概述" class="headerlink" title="ES2016 概述"></a>ES2016 概述</h2><h2 id="ES2017-概述"><a href="#ES2017-概述" class="headerlink" title="ES2017 概述"></a>ES2017 概述</h2><p>允许在参数和数组字面量后边加上小逗号</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们常说 ECMAScript 是一种脚本语言，通常我们把 ECMAScript 看做是一种标准化规范，而实际上是 JavaScript 是 ECMAScript 的扩展语言。&lt;/p&gt;
&lt;p&gt;在浏览器环境中，JavaScript 等于 ECMAScript 加上 WEB A</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://resonance.fun/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://resonance.fun/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的异步编程</title>
    <link href="https://resonance.fun/2021/05/25/yuque/Javascript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://resonance.fun/2021/05/25/yuque/Javascript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-25T09:49:59.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>javascript 被设计为单线程的，因为如果是多线程的话，在多个并行任务中去操作 DOM 会发生意想不到的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;javascript 被设计为单线程的，因为如果是多线程的话，在多个并行任务中去操作 DOM 会发生意想不到的内容。&lt;/p&gt;

</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>说透函数式编程</title>
    <link href="https://resonance.fun/2021/05/22/yuque/%E8%AF%B4%E9%80%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://resonance.fun/2021/05/22/yuque/%E8%AF%B4%E9%80%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-22T13:18:37.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>说到函数式编程，不得不提到数学里的函数，例如数学公式 x=f(y)就很好的描述了 x 和 y 的映射关系，其实，函数式编程正来源于此。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><div class="story post-story"><p>函数式编程(Function Programming FP)，FP 是编程范式之一。函数式编程是一个很古老的概念，它和面向对象等概念是并列的，我们可以认为它是一种如何编写代码的“方法论”。函数式编程的思维方式是把现实世界的事物和事物之间的联系抽象到程序世界，在程序中对运算过程进行抽象，具体的做法是，根据输入某种运算获得相应的输出，因为程序开发过程中会涉及很多有输入和输出的函数。有一点需要注意的是，函数式编程中的函数指的不是程序中的函数，而是数学中的函数，即不同数据之间的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数学中的函数</span></span><br><span class="line">y = sin(x); <span class="comment">// 描述x和y之间的映射关系</span></span><br></pre></td></tr></table></figure><p>由此可见在函数式编程的中，对于相同的输入，函数的输出是恒定的，也就是没有副作用的纯函数；没有副作用的意思是它的输出不会因为外部变量的变化而发生变化。</p><p>上面说它是一种“方法论”，那么我们为什么要使用这种“方法论”呢？要想弄清楚这个问题，我们可以从使用函数式编程有什么好处来作为切入口。</p></div><h2 id="使用函数式编程的好处"><a href="#使用函数式编程的好处" class="headerlink" title="使用函数式编程的好处"></a>使用函数式编程的好处</h2><div class="story post-story"><ul><li>函数式编程可以抛弃 this，不再向面向对象那样经常用到 this</li><li>打包过程中可以更好的利用 tree shaking 过滤无用代码</li><li>方便测试和并行处理</li></ul><p>了解了它的好处，下面来介绍常见的函数式编程都有哪些？不过在此之前，我们先来了解一下函数是一等公民的概念，因为它是后续高阶函数、柯里化等的基础。</p></div><h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><div class="story post-story"><p>在 JavaScript 中函数就是一个普通的对象(可以通过 new Function()创建)，我们可以把函数存储到变量、数组、对象中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 new Function(‘alert(1)’)来构造一个新的函数。总结来说，函数是一等公民，它有以下特点：</p><ul><li>函数可以存储在变量中</li><li>函数可以作为参数</li><li>函数可以作为返回值</li></ul></div><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><div class="story post-story"><p>高阶函数(Higher-order-function)的定义是：可以把函数作为参数传递给另一个函数；可以把函数作为另一个函数的返回结果。我们为什么要使用高阶函数呢？</p><h3 id="使用高阶函数的意义-好处"><a href="#使用高阶函数的意义-好处" class="headerlink" title="使用高阶函数的意义/好处"></a>使用高阶函数的意义/好处</h3><ul><li>使函数抽象化，可以帮我们屏蔽实现细节，每次在调用函数时，我们只需要关注想要的目标。</li><li>对通用问题进行抽象，方便重复调用</li><li>使代码更加简洁</li></ul></div><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><div class="story post-story"><p>闭包(Closure)的定义是：函数和周围的状态(词法环境)的引用捆绑在一起形成闭包。换句话说就是，闭包的形成是因为函数引用了当前作用域以外的其他作用域中的变量。</p><p>深入函数执行机制，函数执行会形成一个执行栈，当执行栈中的内容被执行完成之后，会被游览器垃圾回收机制移除。但如果堆上的作用域成员被外部引用，是不会被移除的，因此内部函数依然可以访问外部函数中的成员。这就是闭包的本质。</p><h3 id="使用闭包的好处"><a href="#使用闭包的好处" class="headerlink" title="使用闭包的好处"></a>使用闭包的好处</h3><p>延长了外部函数中的变量的作用范围。</p></div><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><div class="story post-story"><p>纯函数的概念其实很简单：“相同的输入永远会得到相同的输出”。也就是我们重复调用同一个函数，函数的返回值是和函数的参数一一对应的。我们可以把纯函数理解为数学中的函数，比如数学中常见的数学公式：y=f(x)，它描述了数据与数据之间(x 和 y)的映射关系。纯函数的特点就是不会保留中间的计算结果，比如无法访问函数内部的运算中间结果，因为它不会对计算结果做数据持久化，并且变量是不可变的，所以纯函数是无状态的。</p><h3 id="使用纯函数的好处"><a href="#使用纯函数的好处" class="headerlink" title="使用纯函数的好处"></a>使用纯函数的好处</h3><ul><li>可缓存：由于纯函数相同的输入始终有相同的输出，我们就可以把函数的结果<strong>缓存</strong>起来，避免重复调用，提高性能。</li><li>方便测试</li><li>方便并行处理：在多线程环境下，避免并行操作共享的内存数据引发的意外情况。</li></ul></div><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><div class="story post-story"><p>副作用会让一个函数变得不纯，纯函数根据相同的输入返回相同的输出，如果一个函数依赖于外部的状态就无法保证函数输出相同，就会带来副作用。副作用可能的来源：配置文件、数据库、获取用户的输入等。所有的外部交互都有可能导致副作用，副作用也使得方法通用性下降不适合可扩展性和通用性，同时副作用会给程序中带来安全隐患和不确定性，但是副作用不可能完全禁止，我们应该尽可能控制他们在可控的范围内发生。</p></div><h2 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h2><div class="story post-story"><p>当一个函数有多个参数的时候，先传一部分参数并调用它，这部分参数以后永远不变。然后返回一个新的函数接收剩余的参数，最后返回结果。柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数。因此，柯里化是一种对函数参数的<strong>缓存</strong>。</p><h3 id="柯里化的好处"><a href="#柯里化的好处" class="headerlink" title="柯里化的好处"></a>柯里化的好处</h3><ul><li>让函数变得灵活，让函数的粒度变得更小</li><li>可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能。</li></ul><h3 id="通用柯里化函数"><a href="#通用柯里化函数" class="headerlink" title="通用柯里化函数"></a>通用柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">iner</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length !== args.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> iner(args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fn.apply(fn, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="函数组合-compose"><a href="#函数组合-compose" class="headerlink" title="函数组合(compose)"></a>函数组合(compose)</h2><div class="story post-story"><p>纯函数和柯里化函数很容易写出洋葱代码，这是我们不希望看到的。而函数组合可以让我们把细粒度的函数重新组合生成一个新的函数。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">ret, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn(ret);</span><br><span class="line">    &#125;, value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数组合需要满足<strong>结合律</strong>，假如有三个函数 a、b、c，我们可以先把 a、b 函数组合，然后再组合 c；也可以先把 b、c 组合，然后再组合 a，结果是一样的。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说到函数式编程，不得不提到数学里的函数，例如数学公式 x=f(y)就很好的描述了 x 和 y 的映射关系，其实，函数式编程正来源于此。&lt;/p&gt;
&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何提升开发与设计表单类页面时的效率</title>
    <link href="https://resonance.fun/2021/03/06/yuque/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%8D%95%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87/"/>
    <id>https://resonance.fun/2021/03/06/yuque/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%8D%95%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87/</id>
    <published>2021-03-06T11:22:40.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>可视化表单   编辑器   代码生成   表单设计</p><table><thead><tr><th align="center">版本</th><th align="center">作者</th><th align="center">更新日期</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">1.0</td><td align="center">feline</td><td align="center">2021/3/8</td><td align="left">拖拽方式组合控件</td></tr><tr><td align="center">2.0</td><td align="center">feline</td><td align="center">2021/3/16</td><td align="left">1.重新布局，设计区域扩大很多(核心不变)</td></tr><tr><td align="center">2.控件拖拽时，页面展示辅助线</td><td align="center"></td><td align="center"></td><td align="left"></td></tr></tbody></table><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><div class="story post-story"><p>开发者要开发表单类业务时，由于表单类型多而且复杂，要将这些表单控件一一组合，未免费时费力。而表单通常都是一些固定的组合，那么能不能在编码之间通过某种方式生成出来呢？此时，我想到如果有一款可视化的编辑器产品能够通过拖拽方式组装页面，同时通过设置面板给所有/单个控件设置统一属性，最后不仅能直观的看到页面效果，还能一键复制代码，一定会带来很大的效率提升！同时也可以用于产品原型的制作。</p><p><a href="https://resonances.gitee.io/react-visual-editor/">点此进入预览版</a> | <a href="https://gitee.com/resonances/react-visual-editor/tree/master/docs/imgs">效果图</a></p></div><h2 id="利益相关方"><a href="#利益相关方" class="headerlink" title="利益相关方**"></a>利益相关方**</h2><div class="story post-story"><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1617853708633-c4bf2a5c-fe21-4c9f-9931-5d9383eedded.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1617853708633-c4bf2a5c-fe21-4c9f-9931-5d9383eedded.jpeg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><div class="story post-story"><ol><li>用例开始</li><li>用户打开页面</li><li>页面提示可以点击左侧按钮展开控件面板</li><li>用户点击左侧菜单按钮</li><li>左侧区域出现控件面板</li><li>用户点选某个控件</li><li>控件被自动添加到页面中间的设计区域</li><li>系统提示可以对控件进行设置属性</li><li>用户右击控件</li><li>弹出菜单选项</li><li>用户选择“设置属性”</li><li>右侧区域出现属性面板</li><li>用户直接选择系统预设的不同属性</li><li>系统提示可以点击运行按钮查看生成的页面与代码</li><li>用户点击运行按钮</li><li>系统自动生成代码成功</li><li>系统展示生成完成的代码与效果页面</li><li>用户将代码复制</li><li>用例结束</li></ol></div><h2 id="扩展流程"><a href="#扩展流程" class="headerlink" title="扩展流程"></a>扩展流程</h2><div class="story post-story"><p>11a. 用户选择“复制这个”11a1. 系统自动添加一个相同的控件11b. 用户选择“删除这个”11b1. 系统自动将此控件删除16a. 系统自动生成代码失败16a1. 系统提示：运行错误16a2. 执行用例 1</p></div><h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><div class="story post-story"><ul><li><input checked="" disabled="" type="checkbox"> 布局设置流程打通</li></ul><p>目前可以对全部或部分组件进行布局设置了。</p><ul><li><input disabled="" type="checkbox"> 支持用户自定义请求 options</li><li><input disabled="" type="checkbox"> 支持用户自定义表单提交方法</li></ul><p>比如请求某个接口</p><ul><li><input disabled="" type="checkbox"> 生成的代码提取公共部分并抽离</li><li><input disabled="" type="checkbox"> 快捷键支持</li></ul><p>使用快捷键来快速实现某个功能比如：复制、剪切、删除、打开面板</p><ul><li><input disabled="" type="checkbox"> 生成后的页面可以转为 HTML 并下载、预览</li><li><input disabled="" type="checkbox"> 支持绘制元素</li></ul><p>不仅限于表单，也可以绘制图标、方块、等多种元素</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可视化表单   编辑器   代码生成   表单设计&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;版本&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作者&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;更新日期&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>思维导图之面向对象</title>
    <link href="https://resonance.fun/2020/11/13/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://resonance.fun/2020/11/13/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-11-13T11:59:16.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>{“format”:”lakemind”,”type”:”Mind”,”version”:”1.0”,”diagramData”:{“head”:{“version”:”2.0.0”},”body”:[{“id”:”init”,”type”:”mindmap”,”html”:”new 执行的原理”,”zIndex”:4,”children”:[{“html”:”1.创建一个实例对象：<div>&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;实例.<strong>proto</strong> = 类.prototype 或 Object.create(类.prototype)</span></div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”85ce6913-dcd3-425e-b6ef-aee7f0886c4c”,”children”:[],”zIndex”:0},{“html”:”2.把函数执行，并让函数中的 this 指向实例对象”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”96200052-d822-404c-afd7-60f20c8d1271”,”children”:[],”zIndex”:1},{“html”:”3.处理返回值”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”0f9642a7-e861-4100-b45a-a696688e9b18”,”children”:[{“html”:”如果函数有返回值并且返回值是引用数据类型，则返回函数的返回值；<div>否则返回创建的实例对象</div>“,”id”:”18ffee2e-f3b7-4655-a51e-48db60913134”,”children”:[],”zIndex”:3}],”zIndex”:2}],”x”:-131,”y”:-132},{“id”:”09c49c10-bffa-4053-9219-878620a2f3da”,”x”:-131,”y”:12.5,”html”:”Object.create”,”type”:”mindmap”,”children”:[{“html”:”创建一个对象，并让这个对象的<strong>proto</strong>指向传入的对象的 prototype”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”632b4468-6098-473e-a033-ff06f23c64d4”,”children”:[],”zIndex”:5},{“html”:”Object.create(null) ： 创建一个空对象，并且取消对象的<strong>proto</strong>属性”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”ecc00729-f2c3-4e30-ae83-8cad91c2940b”,”children”:[],”zIndex”:6}],”zIndex”:7},{“id”:”6f913443-31ef-4424-8346-2fbd3e3e7562”,”x”:-129,”y”:193.75,”html”:”函数的多种角色”,”type”:”mindmap”,”children”:[{“html”:”1.作为函数(第一角色)”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”5b137287-648e-4d2f-89dd-40cbd6afaae4”,”children”:[{“html”:”1.普通函数”,”id”:”072d4913-a4f0-40a6-8561-8210526bea47”,”children”:[],”zIndex”:10},{“html”:”2.构造函数<div>类/原型和原型链</div>“,”id”:”84e94270-1b3b-4e13-a291-b4cf8a3ca6bc”,”children”:[],”zIndex”:11}],”zIndex”:8},{“html”:”2.作为对象”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”6ded07ac-ef75-4e5e-99ba-a36f9f0f3eac”,”children”:[{“html”:”键值对”,”id”:”2f854a27-ddad-4b7f-9ede-fdd5b2111375”,”children”:[],”zIndex”:12}],”zIndex”:9},{“html”:”注意点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”8fc86a61-a0ca-4bad-8e37-b4d38e836230”,”children”:[{“html”:”函数是一等公民(数据类型归类)”,”id”:”208cd520-48dc-43f9-aa06-a34737c26868”,”children”:[],”zIndex”:14},{“html”:”三种角色之间没有必然的联系”,”id”:”8f50d9ef-5f0d-4ff8-9f44-9f3d5c20a456”,”children”:[],”zIndex”:15}],”zIndex”:13}],”zIndex”:16},{“id”:”49af2de2-9361-4cf1-827d-b6ba949e6770”,”x”:-131.81879728408808,”y”:379.9729407979514,”html”:”Function 和 Object 是两大基类”,”type”:”mindmap”,”children”:[{“html”:”Object.<strong>proto</strong> === Function.<strong>proto</strong>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”16dcc1fa-0869-4148-9270-77f5d4de94b4”,”children”:[],”zIndex”:17},{“html”:”Function.<strong>proto</strong>.<strong>proto</strong> === Object.prototype”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”d75ff7bb-2648-4432-b8b3-1afbf6833718”,”children”:[],”zIndex”:18}],”zIndex”:19},{“id”:”ec75acf4-2122-41c1-b6b2-84158d399c25”,”x”:-134.13175384962597,”y”:590.4962846636315,”html”:”不具备 prototype 的函数”,”type”:”mindmap”,”children”:[{“html”:”1.箭头函数”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”bcb15d2f-4314-4d9f-9401-660b15079d4a”,”children”:[],”zIndex”:20},{“html”:”2.let obj = {<div>    fn(){} //  这种写法不具备</div><div>}</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”4c3b78ce-c64f-4cac-8334-bc1b3c40b10a”,”children”:[],”zIndex”:21},{“html”:”3.Function.prototype”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”b2766f89-bd1e-4b4d-b7b0-fb08bd673bc1”,”children”:[],”zIndex”:22},{“html”:”特点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”b1846653-a45f-4c2d-9e0b-aecffe27d33e”,”children”:[{“html”:”不能被 new 执行（不是构造函数）”,”id”:”951a3597-2619-443f-a5e4-cab71e21f7a5”,”children”:[],”zIndex”:24}],”zIndex”:23}],”zIndex”:25},{“id”:”47ef0862-265f-414a-b645-e73dbd35b629”,”x”:-136.16110284270343,”y”:929.2477717010211,”html”:”检测数据类型的方法”,”type”:”mindmap”,”children”:[{“html”:”1.typeof”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”95131760-5b3e-4ba0-b475-c2dc831c229d”,”children”:[{“html”:”按照二进制存储的值进行检测的”,”id”:”d0b02dae-57b1-4455-a679-6ebda4f0e5be”,”children”:[],”zIndex”:30},{“html”:”缺点”,”id”:”0bf9936e-0805-40bf-95d8-af27e9d301f9”,”children”:[{“html”:”bug: typeof null 等于 object”,”id”:”250fb09b-964e-4f76-b30e-9423697b0b0e”,”children”:[],”zIndex”:37,”height”:null},{“html”:”不能细分具体的引用数据类型”,”id”:”b433a4d1-f5a7-4be8-87a8-d4d68f031ee9”,”children”:[],”zIndex”:32}],”zIndex”:31}],”zIndex”:26},{“html”:”2.Object.prototype.toString”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”b46509c1-89a3-4d9c-82fe-a83b38f51c53”,”children”:[],”zIndex”:27},{“html”:”3.contructor”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”d07e6c2d-6b29-4c1c-b480-f3860bcdf761”,”children”:[{“html”:”当前实例是否是当前类的实例(只找一级)”,”id”:”592ec3fe-508d-43b7-9a15-e07c73b5cdb3”,”children”:[],”zIndex”:36}],”zIndex”:28},{“html”:”4.instance of”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”22a2252a-98ab-4861-9bdd-8618dfee7a24”,”children”:[{“html”:”原理”,”id”:”3d5ef254-8fe2-4489-9259-8d0c7020adae”,”children”:[{“html”:”static 构造函数<a href="%E5%AE%9E%E4%BE%8B">Symbol.hasInstance</a>“,”id”:”32acc5d3-94f0-4995-8770-d45be84e6788”,”children”:[],”zIndex”:34},{“html”:”当前构造函数的原型 prototype 是否出现在，当前实例所在的原型链上<strong>proto</strong>“,”id”:”6cab9c06-2191-4c40-8a72-b1af716add11”,”children”:[],”zIndex”:35}],”zIndex”:33}],”zIndex”:29}],”zIndex”:38}]},”viewportSetting”:{“zoom”:1.0506695938270962,”tlCanvasPoint”:[-147.65729938911286,646.4696602662399,1],”width”:1366,”height”:898},”text”:”new 执行的原理 1.创建一个实例对象：实例.<strong>proto</strong> = 类.prototype 或 Object.create(类.prototype)2.把函数执行，并让函数中的 this 指向实例对象 3.处理返回值如果函数有返回值并且返回值是引用数据类型，则返回函数的返回值；否则返回创建的实例对象 Object.create 创建一个对象，并让这个对象的<strong>proto</strong>指向传入的对象的 prototypeObject.create(null) ： 创建一个空对象，并且取消对象的<strong>proto</strong>属性函数的多种角色 1.作为函数(第一角色)1.普通函数 2.构造函数类/原型和原型链 2.作为对象键值对注意点函数是一等公民(数据类型归类)三种角色之间没有必然的联系 Function 和 Object 是两大基类 Object.<strong>proto</strong> === Function.<strong>proto</strong>Function.<strong>proto</strong>.<strong>proto</strong> === Object.prototype 不具备 prototype 的函数 1.箭头函数 2.let obj = {    fn(){} //  这种写法不具备}3.Function.prototype 特点不能被 new 执行（不是构造函数）检测数据类型的方法 1.typeof 按照二进制存储的值进行检测的缺点 bug: typeof null 等于 object 不能细分具体的引用数据类型 2.Object.prototype.toString3.contructor 当前实例是否是当前类的实例(只找一级)4.instance of 原理 static 构造函数<a href="%E5%AE%9E%E4%BE%8B">Symbol.hasInstance</a>当前构造函数的原型 prototype 是否出现在，当前实例所在的原型链上<strong>proto</strong>“}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;{“format”:”lakemind”,”type”:”Mind”,”version”:”1.0”,”diagramData”:{“head”:{“version”:”2.0.0”},”body”:[{“id”:”init”,”type”:”mindmap”,”html”</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>思维导图之作用域和闭包</title>
    <link href="https://resonance.fun/2020/10/29/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>https://resonance.fun/2020/10/29/yuque/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</id>
    <published>2020-10-29T05:24:13.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<p>{“format”:”lakemind”,”type”:”Mind”,”version”:”1.0”,”diagramData”:{“head”:{“version”:”2.0.0”},”body”:[{“id”:”init”,”type”:”mindmap”,”html”:”数据类型”,”children”:[{“html”:”基本类型”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”f1b51e22-5556-41c2-8bdf-f900a8c5cf6f”,”children”:[{“html”:”number”,”id”:”3c85803e-2ab1-47d3-93e4-34e924d6d361”,”children”:[],”zIndex”:2},{“html”:”string”,”id”:”0714922a-cb2e-4e85-ba85-d73c7bafc728”,”children”:[],”zIndex”:3},{“html”:”undefined”,”id”:”42f4fa35-8257-402a-ae08-12ea56d761ee”,”children”:[],”zIndex”:4},{“html”:”null”,”id”:”bee1c28d-be83-4edf-af03-08b8dd29d91e”,”children”:[],”zIndex”:5},{“html”:”boolean”,”id”:”c5ae2d7f-12b8-4379-a4ea-7679e6f99b6f”,”children”:[],”zIndex”:9},{“html”:”symbol”,”id”:”b326de10-646c-48e5-985e-32744066f033”,”children”:[],”zIndex”:6}],”zIndex”:0},{“html”:”引用类型”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”1a581807-35a4-47d7-bfe1-cf8f93e51df8”,”children”:[{“html”:”object”,”id”:”aae01172-12c8-4c6a-8da9-dae7ff8f1997”,”children”:[{“html”:”array”,”id”:”abdcf0cb-edc5-40ce-913c-86c1b24bceec”,”children”:[],”zIndex”:10},{“html”:”…”,”id”:”6d40973b-4f4b-4c09-90b8-c7046fbdbf13”,”children”:[],”zIndex”:11}],”zIndex”:7},{“html”:”function”,”id”:”f5803c67-eec6-4f23-82b7-0a3da47141e8”,”children”:[],”zIndex”:8}],”zIndex”:1}],”zIndex”:12,”x”:2024.4623834304057,”y”:-3472.70048927316,”border”:{“shape”:”rect”,”stroke”:”transparent”}},{“id”:”fc99eff4-03ef-4955-9ac3-c3dd0fc2e483”,”x”:2003.6096233018084,”y”:-2194.5299924160363,”html”:”JS 代码执行”,”type”:”mindmap”,”children”:[{“html”:”1.游览器会在内存中开辟一块栈内存，全局上下文（环境），也叫 ECStack。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”733f2abd-2dc1-4e82-a9cc-25b7be0d2ef7”,”children”:[{“html”:”&lt;div style=&quot;text-align:center;&quot;&gt;</div>“,”id”:”a40eafd0-87de-4158-b9c7-9f35fdb611c3”,”children”:[{“html”:”&lt;div style=&quot;text-align:center;&quot;&gt;</div>“,”id”:”a78d3f71-b03d-4d09-82f2-5bbf0bd07162”,”children”:[],”zIndex”:16,”image”:{“src”:”<a href="https://cdn.nlark.com/yuque/0/2020/png/1429353/1604060996415-32302ab3-f32b-4e45-9ead-6ac9698e07ab.png&quot;,&quot;naturalWidth&quot;:700,&quot;naturalHeight&quot;:504,&quot;width&quot;:283,&quot;height&quot;:203.76000000000002%7D,&quot;width&quot;:299,&quot;height&quot;:216%7D],&quot;zIndex&quot;:15,&quot;image&quot;:%7B&quot;src&quot;:&quot;https://cdn.nlark.com/yuque/0/2020/png/1429353/1604059782703-5690a93e-e8c8-4593-95d1-e68ab4bee13b.png&quot;,&quot;naturalWidth&quot;:589,&quot;naturalHeight&quot;:479,&quot;width&quot;:206,&quot;height&quot;:167.52801358234296%7D,&quot;border&quot;:%7B&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;%7D,&quot;width&quot;:222,&quot;height&quot;:187.52801358234296%7D],&quot;zIndex&quot;:13,&quot;border&quot;:%7B&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;%7D%7D,%7B&quot;html&quot;:&quot;2.%E7%84%B6%E5%90%8E%E5%BD%A2%E6%88%90%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87EC(G)%EF%BC%88%E9%BB%98%E8%AE%A4%E5%B0%B1%E6%98%AFwindow/global%EF%BC%89%E4%BE%9B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E3%80%82&quot;,&quot;layout&quot;:%7B&quot;quadrant&quot;:1%7D,&quot;treeEdge&quot;:%7B&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;cde0a14e-ccf0-40d0-8e05-0ccb4d1868f4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:14}],&quot;zIndex&quot;:17},{&quot;id&quot;:&quot;129c5c0c-ad88-4e63-9320-a350ee1f58df&quot;,&quot;x&quot;:3374.297353377579,&quot;y&quot;:-2207.5561578019106,&quot;html&quot;:&quot;%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[{&quot;html&quot;:&quot;1.%E5%8D%95%E7%8B%AC%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%8816%E8%BF%9B%E5%88%B6%E5%9C%B0%E5%9D%80%EF%BC%89%EF%BC%8C%E5%87%BD%E6%95%B0%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E4%BD%93%E4%B8%AD%E7%9A%84%E2%80%9C%E4%BB%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9D%E3%80%82&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;5859bc97-b0cc-4727-809e-482555f526ce&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:18},{&quot;html&quot;:&quot;2.%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%B1%E5%A3%B0%E6%98%8E%E4%BA%86%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F[scope]%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%89%80%E5%9C%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83%E3%80%82&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;a151950e-08f2-436f-ba60-896f20e404f9&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:19},{&quot;html&quot;:&quot;3.%E6%8A%8A16%E8%BF%9B%E5%88%B6%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AD%98%E6%94%BE%E5%88%B0%E6%A0%88%E4%B8%AD%EF%BC%8C%E4%BE%9B%E5%8F%98%E9%87%8F%EF%BC%88%E5%87%BD%E6%95%B0%E5%90%8D%E7%AD%89%EF%BC%89%E5%85%B3%E8%81%94%E5%BC%95%E7%94%A8%E5%8D%B3%E5%8F%AF&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#69B1E4&quot;},&quot;id&quot;:&quot;6596c13c-9913-405a-b5d5-efa629c25397&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:20},{&quot;html&quot;:&quot;">https://cdn.nlark.com/yuque/0/2020/png/1429353/1604060996415-32302ab3-f32b-4e45-9ead-6ac9698e07ab.png&quot;,&quot;naturalWidth&quot;:700,&quot;naturalHeight&quot;:504,&quot;width&quot;:283,&quot;height&quot;:203.76000000000002},&quot;width&quot;:299,&quot;height&quot;:216}],&quot;zIndex&quot;:15,&quot;image&quot;:{&quot;src&quot;:&quot;https://cdn.nlark.com/yuque/0/2020/png/1429353/1604059782703-5690a93e-e8c8-4593-95d1-e68ab4bee13b.png&quot;,&quot;naturalWidth&quot;:589,&quot;naturalHeight&quot;:479,&quot;width&quot;:206,&quot;height&quot;:167.52801358234296},&quot;border&quot;:{&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;},&quot;width&quot;:222,&quot;height&quot;:187.52801358234296}],&quot;zIndex&quot;:13,&quot;border&quot;:{&quot;shape&quot;:&quot;line&quot;,&quot;stroke&quot;:&quot;transparent&quot;}},{&quot;html&quot;:&quot;2.然后形成全局执行上下文EC(G)（默认就是window/global）供代码执行。&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;cde0a14e-ccf0-40d0-8e05-0ccb4d1868f4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:14}],&quot;zIndex&quot;:17},{&quot;id&quot;:&quot;129c5c0c-ad88-4e63-9320-a350ee1f58df&quot;,&quot;x&quot;:3374.297353377579,&quot;y&quot;:-2207.5561578019106,&quot;html&quot;:&quot;创建函数&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[{&quot;html&quot;:&quot;1.单独开辟一个堆内存（16进制地址），函数堆内存中存储的是函数体中的“代码字符串”。&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;5859bc97-b0cc-4727-809e-482555f526ce&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:18},{&quot;html&quot;:&quot;2.创建函数的时候，就声明了它的作用域[scope]，也就是所在的上下文环境。&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#E48484&quot;},&quot;id&quot;:&quot;a151950e-08f2-436f-ba60-896f20e404f9&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:19},{&quot;html&quot;:&quot;3.把16进制的地址存放到栈中，供变量（函数名等）关联引用即可&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#69B1E4&quot;},&quot;id&quot;:&quot;6596c13c-9913-405a-b5d5-efa629c25397&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:20},{&quot;html&quot;:&quot;</a>&lt;div style=&quot;text-align:center;&quot;&gt;</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”14419622-89b2-404d-96bb-6122e3cd7723”,”children”:[],”zIndex”:21,”image”:{“src”:”<a href="https://cdn.nlark.com/yuque/0/2020/png/1429353/1604062395688-a40f493f-f76f-4dcd-83e0-a3eddcbbc1f0.png&quot;,&quot;naturalWidth&quot;:463,&quot;naturalHeight&quot;:281,&quot;width&quot;:463,&quot;height&quot;:281%7D%7D],&quot;zIndex&quot;:22%7D,%7B&quot;id&quot;:&quot;ea92f014-dfb7-4bc5-9fec-3e2a2d3219a6&quot;,&quot;x&quot;:1991.010600069691,&quot;y&quot;:-1629.5675587544767,&quot;html&quot;:&quot;%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[%7B&quot;html&quot;:&quot;1.%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%85%A8%E6%96%B0%E7%9A%84%EF%BC%8C%E7%A7%81%E6%9C%89%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87EC(...)&quot;,&quot;layout&quot;:%7B&quot;quadrant&quot;:1%7D,&quot;treeEdge&quot;:%7B&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;27859533-85ab-45c2-9635-0fa167fe12d4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:23},{&quot;html&quot;:&quot;2.%E5%BD%93%E5%89%8D%E7%A7%81%E6%9C%89%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%98%E6%94%BE%E6%9C%AC%E4%B8%8A%E4%B8%8B%E6%96%87%E5%86%85%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E6%96%B9AO(...)">https://cdn.nlark.com/yuque/0/2020/png/1429353/1604062395688-a40f493f-f76f-4dcd-83e0-a3eddcbbc1f0.png&quot;,&quot;naturalWidth&quot;:463,&quot;naturalHeight&quot;:281,&quot;width&quot;:463,&quot;height&quot;:281}}],&quot;zIndex&quot;:22},{&quot;id&quot;:&quot;ea92f014-dfb7-4bc5-9fec-3e2a2d3219a6&quot;,&quot;x&quot;:1991.010600069691,&quot;y&quot;:-1629.5675587544767,&quot;html&quot;:&quot;函数执行&quot;,&quot;type&quot;:&quot;mindmap&quot;,&quot;children&quot;:[{&quot;html&quot;:&quot;1.形成一个全新的，私有的上下文EC(...)&quot;,&quot;layout&quot;:{&quot;quadrant&quot;:1},&quot;treeEdge&quot;:{&quot;stroke&quot;:&quot;#A287E1&quot;},&quot;id&quot;:&quot;27859533-85ab-45c2-9635-0fa167fe12d4&quot;,&quot;children&quot;:[],&quot;zIndex&quot;:23},{&quot;html&quot;:&quot;2.当前私有的上下文中，有一个存放本上下文内声明的变量的地方AO(...)</a><div>私有变量对象 -&gt; 这里的变量都是当前上下文内的私有变量(当前上下文中声明的变量，形参变量)</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”aeb76700-4daf-41bf-ad15-bd81f116a967”,”children”:[],”zIndex”:24},{“html”:”3.进栈执行”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”dba0e235-fbce-41f5-a599-f92fc2cdd99b”,”children”:[],”zIndex”:25},{“html”:”4.代码执行之前还要处理很多事情”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”3d19547f-97dd-4f3d-9e85-a27c668ace9e”,”children”:[{“html”:”1.初始化作用域链[scope-chain]: <div>&lt;当前自己的上下文，上级上下文(创建函数时形成的作用域)&gt;</div><div>&lt;span style=&quot;color:rgb(89, 89, 89);&quot;&gt;当前函数的上级上下文是创建函数所在的上下文（作用域）</span></div><div>&lt;span style=&quot;color:rgb(251, 50, 0);&quot;&gt;后期函数内代码执行，遇到一个变量，我们首先看是否为自己上下文中的私有变量（看 AO 中有没有），如果是私有的变量，则当前变量的操作和外界环境中的变量互不干扰（没有直接关系）；如果不是自己的私有变量，则按照作用域链，查找是否为其上级上下文中的私有变量…直到找到 EC(G)全局上下文为止 作用域链查找机制</span></div>“,”id”:”3192a6da-bc0c-4b2f-bd6a-60b80bf1e611”,”children”:[],”zIndex”:27},{“html”:”2.初始化 this…”,”id”:”fc880192-ab33-4a87-94e1-7496dea6d304”,”children”:[],”zIndex”:28},{“html”:”3.初始化 arguments…”,”id”:”af0e886b-2f8c-4fd8-9ff5-cdbb6b38ce37”,”children”:[],”zIndex”:29},{“html”:”4.形参赋值<div>形参都是私有变量（放到 AO 中的）</div><div>如果不传递实参值，默认值是 undefined</div>“,”id”:”356f8dcf-856c-469f-937d-feaebdc14b5b”,”children”:[],”zIndex”:30},{“html”:”5.变量提升”,”id”:”ede4a7ea-4ca1-40e4-82fa-fe18dad5266d”,”children”:[],”zIndex”:31}],”zIndex”:26},{“html”:”5.代码自上而下执行”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”97df9f13-b220-47dd-b944-78332dd062f7”,”children”:[],”zIndex”:32},{“html”:”6.一般情况下， 函数进栈执行的上下文，进栈执行完成后，会默认出栈释放掉（私有上下文中存储的私有变量和一些值都会被释放掉） -&gt; 目的：为了优化内存空间，减少栈内存的消耗，提高页面或者计算机的处理速度…”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”499021f1-ad43-47cf-b4fc-d7067ad68161”,”children”:[],”zIndex”:33}],”zIndex”:34},{“id”:”bbea95d2-e3d3-4e69-8a4c-86d3a5cd4247”,”x”:1963.3765434958004,”y”:82.81621411828132,”html”:”GC：游览器的垃圾回收机制（内存管理）”,”type”:”mindmap”,”children”:[{“html”:”谷歌：基于查找引用”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”c9e933a5-abac-4736-9646-4da6c8f7d331”,”children”:[],”zIndex”:38},{“html”:”游览器的渲染引擎会在空闲的时候（定期一个时间），依次遍历所有的内存：栈/堆”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”a552e576-57ab-4670-8cdd-2fd1f47182c8”,”children”:[],”zIndex”:35},{“html”:”堆：当前内存如果被占用（指针关联地址），则不能释放；如果没有任何的事物占用这个堆，则游览器会自动把这个堆内存释放掉。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”71b45608-3dd0-4147-ac2b-b543e5f7b8c4”,”children”:[],”zIndex”:36},{“html”:”栈：当前上下文中是否有内容（一般是堆内存）被上下文以外的事物所占用，如果被占用则无法释放（闭包），如果没有被占用则释放掉。&lt;span style=&quot;color:rgb(251, 50, 0);&quot;&gt;EC(G)是加载页面的时候创建，只有关闭页面的时候才会被释放。</span>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”83ab9934-e818-4905-a27b-4830dcf9f399”,”children”:[],”zIndex”:37},{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;主动释放：把占用的事物手动赋值为 null（其余的值也可以，但是 null 更好，null 不占空间的），可以实现内存的手动优化</span>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”7f65522e-b320-4d09-b515-d6946c6b49e5”,”children”:[],”zIndex”:39}],”zIndex”:40},{“id”:”cde09247-87b4-4213-8fda-abefc26c8ca4”,”x”:2917.6565158848593,”y”:69.40691075334075,”html”:”this”,”type”:”mindmap”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212); font-weight:bold;&quot;&gt;函数的执行主体</span>（不等价于执行上下文/作用域）：谁把这个函数执行的”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”b3412def-d12b-42b0-9e81-b06491748424”,”children”:[],”zIndex”:41},{“html”:”在游览器端运行 JS 代码，非函数中的 this 一般都是 window；研究 this 都是研究函数中的 this；有一个特殊的，就是 ES6+中“块级上下文”中的 this，是其所在上下文中的 this（理解为：块级上下文是没有自己 this 的）；”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”f4099a09-54c3-4ded-a4a4-cd92d7da35ce”,”children”:[],”zIndex”:42},{“html”:”想要分清楚函数执行的执行主体(this)，可以按照如下的规律来分析”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”6caf7a24-5eea-48ab-8863-5a4c7c5f12b5”,”children”:[{“html”:”事件绑定”,”id”:”5b615342-4631-45a0-8064-5fca2acb30a2”,”children”:[{“html”:”当前元素本身”,”id”:”d7a4240e-86ef-474b-90d7-5824fc7c3f47”,”children”:[],”zIndex”:49}],”zIndex”:44},{“html”:”普通函数执行”,”id”:”65a6d7ec-7d7c-48b7-bbbb-c0be86de1d6f”,”children”:[{“html”:”看函数前面是否有点，点前面是谁 this 就是谁”,”id”:”a3eda677-65f9-4afc-93ea-d977be9a4484”,”children”:[],”zIndex”:50},{“html”:”没有点就是 window/undefiend(严格模式)”,”id”:”5e8a148b-c639-49d9-93b4-59a428f64a06”,”children”:[],”zIndex”:51},{“html”:”自执行函数中的 this 一般都是 window/undefined(严格模式)”,”id”:”f45e3d01-1e3e-42af-82e8-187a938d4af5”,”children”:[],”zIndex”:52},{“html”:”回调函数中的 this 一般也是 window/undefined(严格模式)，除非做过特殊处理”,”id”:”d889cc4d-2c27-4f10-8ab8-3caff342b27b”,”children”:[],”zIndex”:53},{“html”:”&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;括号包起来的函数执行：</span><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;如果括号中只有一项，就相当于没有括号；</span></div><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;如果括号中有很多项，this 就是最后一项</span></div><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;     (obj.fn)() -&gt; obj</span></div><div>&lt;span style=&quot;color:rgb(107, 45, 98);&quot;&gt;     (a, b, obj.fn)() -&gt; obj</span></div>“,”id”:”1862b77b-564c-4df1-841b-380e09d76cc6”,”children”:[],”zIndex”:54}],”zIndex”:45},{“html”:”构造函数执行”,”id”:”4ed6a01a-8c9c-4c9d-86ea-e5b460d27f93”,”children”:[{“html”:”所属类的实例”,”id”:”4eeacbf2-bb19-435d-b314-be1175456f54”,”children”:[],”zIndex”:56}],”zIndex”:46},{“html”:”箭头函数执行”,”id”:”ec859e1e-b16f-464f-bc42-c30fef007884”,”children”:[{“html”:”它的上级上下文”,”id”:”f41f3832-532e-4dec-997d-a29b355d8d89”,”children”:[],”zIndex”:55}],”zIndex”:47},{“html”:”基于 call/apply/bind 强制改变 this”,”id”:”9213fa2d-0097-4666-8672-ef4eaa5e0637”,”children”:[],”zIndex”:48}],”zIndex”:43}],”zIndex”:57},{“id”:”bb33ab1a-a703-4b16-9298-88e1c82463a8”,”x”:1952.0194459168001,”y”:714.3310716568769,”html”:”高阶编程技巧”,”type”:”mindmap”,”children”:[{“html”:”利用闭包的机制，实现出来的一些高阶编程方式”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”3bc71dce-2aa6-48fa-9edf-547ca5ecc3cd”,”children”:[],”zIndex”:58},{“html”:”高级单例设计模式”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”b1b99533-26bc-4bed-8fb6-93f8037976a3”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(251, 50, 0);&quot;&gt;早期的模块化设计思想</span>“,”id”:”a9c872d8-b357-418c-a123-7119cfea1f45”,”children”:[],”zIndex”:60},{“html”:”闭包+单例<div>一个对象就是一个单例模式<br></div>“,”id”:”09e4872d-3747-47f6-b2d5-32ddc61e3cfb”,”children”:[],”zIndex”:61},{“html”:”基于闭包的“保护作用”，防止了全局变量污染”,”id”:”bb674be6-14cf-4192-8396-742b230695da”,”children”:[],”zIndex”:62}],”zIndex”:59},{“html”:”惰性函数”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”a2524d75-2fa4-4645-ab8c-05a93f75b539”,”children”:[{“html”:”获取元素样式的小知识点”,”id”:”496afb35-356c-4cd0-b91c-e17ac07b2f60”,”children”:[{“html”:”1.dom.style<div>只有获取元素的内联样式</div>“,”id”:”74840378-e046-413e-953c-bcd7faaed8f2”,”children”:[],”zIndex”:65},{“html”:”2.getComputedStyle  IE6<del>8 不兼容<div>获取经过浏览器计算的样式（返回样式对象）</div>“,”id”:”701178cc-bce7-433b-9e36-3a5bd064adf3”,”children”:[],”zIndex”:66}],”zIndex”:64},{“html”:”&lt;span style=&quot;color:rgb(105, 177, 228);&quot;&gt;惰性思想</span>：干一次可以搞定的，绝对不去做第二次”,”id”:”8fb6e374-51db-40c0-9007-4731cdd6bfe7”,”children”:[],”zIndex”:67}],”zIndex”:63},{“html”:”函数柯理化”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”6e2cb5ea-036a-47c4-ac8e-5497b4abf02e”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;预先处理的思想</span><div>形成一个不被释放的闭包，把一些信息储存起来，以后基于作用域链，访问到事先储存的信息，然后进行相关的处理。</div>“,”id”:”de121d25-3528-4666-84c1-44fa43cc03e4”,”children”:[],”zIndex”:69},{“html”:”小知识点”,”id”:”8823ea03-34ee-4373-a13f-aaa02fdd9f42”,”children”:[{“html”:”命令式编程”,”id”:”6ba6485c-6b35-4cb8-90fd-643df71135f9”,”children”:[{“html”:”自己编写代码，管控运行的步骤和逻辑（自己可以灵活掌控执行步骤）”,”id”:”772eaa42-519d-477e-bfc2-669f4108e043”,”children”:[],”zIndex”:73}],”zIndex”:71},{“html”:”函数式编程”,”id”:”ee04ddc8-42f1-4a97-98a6-6006275cf5b3”,”children”:[{“html”:”具体实现的步骤已经被封装成方法，我们只需要调用方法获取结果即可，无需关注怎么实现的，用起来方便，代码量减少<div>弊端：灵活性差</div>“,”id”:”3c256491-3f2f-467e-9dea-de8ec44e6b82”,”children”:[],”zIndex”:74}],”zIndex”:72}],”zIndex”:70},{“html”:”currying”,”id”:”2c706054-c2cf-4a1b-8789-1b683fe2af8a”,”children”:[],”zIndex”:75},{“html”:”&lt;span style=&quot;font-weight:bold;&quot;&gt;compose</span>“,”id”:”65e45b73-c50e-4b6c-bc7e-3cb108c7662e”,”children”:[],”zIndex”:76}],”zIndex”:68}],”zIndex”:77},{“id”:”b98f60f5-dbe8-4268-84f4-155c3118e2b5”,”x”:2516.363393125918,”y”:-3481.224978713911,”html”:”数据类型转换”,”type”:”mindmap”,”children”:[{“html”:”其他类型转换为 Number”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”28fef53e-af7c-4747-bb67-d230b5282773”,”children”:[{“html”:”能用的办法”,”id”:”466f8305-e6c4-40da-8f93-9b658e6e28d5”,”children”:[{“html”:”parseInt/parseFloat([val])”,”layout”:{“quadrant”:1},”id”:”76e08162-00ef-4f04-a538-2dc3a55efb93”,”children”:[{“html”:”把要转换值先转换为字符串”,”id”:”1b8ab5a7-3a68-401c-b9ac-57d652886add”,”children”:[],”zIndex”:102},{“html”:”从字符串左侧的第一位开始查找有效数字字符，遇到非有效字符串则立即停止，最后把有效的数字字符串转为数字，如果没有则返回 NaN”,”id”:”564cda97-5817-4ade-b097-0b95e7498133”,”children”:[],”zIndex”:101}],”zIndex”:93},{“html”:”Number”,”layout”:{“quadrant”:1},”id”:”7ecf1da3-dbf0-41d4-b9c7-86badc9a62f1”,”children”:[{“html”:”只要出现非有效数字字符结果都是 NaN<div>Number(undefined) 是 NaN</div>“,”id”:”d3142c07-3700-4ea2-ab7d-80454189a4e9”,”children”:[],”zIndex”:99},{“html”:”对象转为数字，应该先 valueOf，没有原始值再 toString，最后再把字符串转为数字”,”id”:”2cf1b316-9527-4978-9eef-8de1450440db”,”children”:[],”zIndex”:100}],”zIndex”:94}],”zIndex”:92},{“html”:”隐式转换（游览器内部默认是先转换为 Number 再进行计算的）”,”id”:”624c0e8c-0710-4164-bf8b-92c448803fcc”,”children”:[{“html”:”isNaN([val])”,”id”:”48bd07bd-5a87-4d86-a940-27dee829fd48”,”children”:[],”zIndex”:96},{“html”:”数学运算”,”id”:”d73bf817-4c60-44af-9a70-4082d220eb0a”,”children”:[],”zIndex”:97},{“html”:”在==比较的时候（见== ：2.3）”,”id”:”7b0b5e99-cb8f-44f0-9f7b-29559c3b067f”,”children”:[],”zIndex”:98}],”zIndex”:95}],”zIndex”:91},{“html”:”其他类型转换为 Boolean”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”0db08cae-524b-453e-aa18-f86334d51f7a”,”children”:[{“html”:”只有“0、NaN、null、undefined、空字符串”五个值会变为布尔的 FALSE，其余都是 TRUE”,”id”:”98bd2b3d-fc29-4d68-8f0e-1daa67573970”,”children”:[],”zIndex”:79}],”zIndex”:78},{“html”:”其他类型转换为字符串”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”a0495c36-69de-4b76-a2f2-05735f90994b”,”children”:[{“html”:”1.一般都是直接“”包起来”,”id”:”6bbcb805-20b8-4881-b225-7f03b808ad19”,”children”:[],”zIndex”:89},{“html”:”2.只有{}普通对象 toString()是调取的&lt;span style=&quot;color:rgb(119, 195, 134);&quot;&gt;Object.prototype.toString()</span>，但它不是转换为字符串，而是&lt;span style=&quot;color:rgb(119, 195, 134);&quot;&gt;数据类型检测</span>，返回结果是[object Object]。（&lt;span style=&quot;color:rgb(119, 195, 134);&quot;&gt;其他对象也是可以调用的</span>）”,”id”:”29248173-b7d4-48f9-a477-c22f892f94a8”,”children”:[],”zIndex”:90}],”zIndex”:88},{“html”:”==”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”3a0ae834-99b4-4d65-b308-29a9f9d396e4”,”children”:[{“html”:”1.类型一样”,”id”:”0d83de72-b844-41cb-8ed4-b905b5e7ac6a”,”children”:[{“html”:”对象比较的是堆内存的地址”,”id”:”cb0f32b7-8ee0-4f53-844b-563ba4af1f8f”,”children”:[],”zIndex”:83},{“html”:”NaN == NaN  =&gt; false”,”id”:”0c07dbd7-8b9b-4f71-995d-e68cb0e8265b”,”children”:[],”zIndex”:84}],”zIndex”:81},{“html”:”2.类型不一样（会隐式转换为相同的数据类型）”,”id”:”783b255e-2264-4e1f-9135-26f9e717c368”,”children”:[{“html”:”1.null==undefined =&gt; true<div>但是换成===结果是 false（因为类型不一致）</div><div>剩下的 null/undefined 和其他任何数据类型值都不相等</div>“,”id”:”2014e91c-93da-4093-a4b2-06e6fb0392b7”,”children”:[],”zIndex”:85},{“html”:”2.字符串==对象   要把对象转换为字符串”,”id”:”0514b91b-c0e7-4b26-9999-578024efa867”,”children”:[],”zIndex”:86},{“html”:”3.剩下的如果==两边数据类型不一致，都是需要转换为 Number 再进行比较的”,”id”:”91ca760f-1084-41be-9a78-cfccef4a8e29”,”children”:[],”zIndex”:87}],”zIndex”:82}],”zIndex”:80}],”zIndex”:103},{“id”:”dd04bed1-67c3-41ca-b7ec-81e3e85752a0”,”x”:2014.1738538982459,”y”:-2910.0035004548354,”html”:”parseInt 的处理规则”,”type”:”mindmap”,”children”:[{“html”:”parseInt([value], [radix])”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”59868e0a-450b-4550-9d9c-b4102ebb61fe”,”children”:[],”zIndex”:104},{“html”:”radix 是一个进制，不写或者写 0 默认都按照 10 进制处理。<div>特殊情况：如果 value 是以 0x 开头，则默认值不是 10 而是 16</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”fa5efc41-dbc6-4d15-a0f5-12f0a671ac8a”,”children”:[],”zIndex”:105},{“html”:”radix 有取值范围：2 ～ 36。如果不在这个区间，则会返回 NaN。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”6de683ab-9dc0-4e95-a147-a740ce9985ab”,”children”:[],”zIndex”:106},{“html”:”作用：把[value]看作[radix]机制，最后把[radix]进制的值转换为十机制。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”1cc2600e-69b7-47ab-9364-dac8c9cf3299”,”children”:[],”zIndex”:107},{“html”:”执行过程：<div>1.从左向右开始查找[value]中的有效的[radix]进制值，遇到不是有效的立即停止；如果没有找到，则返回 NaN。</div><div>2.把查找到的结果转为数字，再把它作为[radix]进制转为十进制。</div>“,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”2899be55-c677-4828-9185-023cb9ffc7f4”,”children”:[],”zIndex”:110},{“html”:”小知识点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”ed6dfe5d-d14d-4e0e-b5a1-b3ad3dc15004”,”children”:[{“html”:”把一个任意进制的值转换为十进制值：<div>(每个位的数*进制^位权值)的和</div><div>位权值：个位从 0 开始，依次增 1；小数点后面的从-1 开始，依次减一。</div>“,”id”:”ada36261-f187-4582-854b-b1c80f6e5ecc”,”children”:[],”zIndex”:109}],”zIndex”:108}],”zIndex”:111},{“id”:”586fbcfd-1ba9-4b27-9e5f-05a2c4141ae1”,”x”:2867.8799493504434,”y”:-2914.512275969836,”html”:”变量提升的处理机制”,”type”:”mindmap”,”children”:[{“html”:”ES3+：在当前上下文中，JS 代码执行之前，浏览器会提前（词法解析的时候）把当前上下文中所有&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;带 var/function</span>关键字的进行提前的声明或者定义。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”bea45252-ed7b-4ef0-aa34-5c365b92a17f”,”children”:[],”zIndex”:112},{“html”:”带 var 声明的变量只提前声明不定义”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”80bb52ec-0274-4b57-bdb2-d8672450a41e”,”children”:[],”zIndex”:113},{“html”:”函数会提前声明和定义”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”3817f40f-3bdd-4100-8ada-24b38630b4d9”,”children”:[{“html”:”真实项目中建议用函数表达式创建函数，因为这样在变量提升阶段只会声明 function，更严谨。”,”id”:”b85b09ed-7429-4583-85d5-7ef6dc3f18e1”,”children”:[],”zIndex”:117},{“html”:”在使用函数表达式创建函数时，一般要把匿名函数具名化。<div>当函数执行，在形成的私有上下文中，会把这个具名化的名字作为变量，值就是这个函数来进行处理。这样做的好处是：&lt;span style=&quot;color:rgb(105, 177, 228);&quot;&gt;弥补了在严格模式下不能使用 argments.calle 调用当前函数。</span></div>“,”id”:”ad4c93ca-3165-4625-b3e4-685c8887deed”,”children”:[],”zIndex”:118}],”zIndex”:114},{“html”:”小知识点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”e1eff868-9732-417c-84e0-9fd855f74a84”,”children”:[{“html”:”1.基于“var 或 function”在“全局上下文”中声明的变量（全局变量）会映射到 GO（全局对象 window）上一份，作为它的属性；而且是同时修改的。”,”id”:”4ec71694-0351-4751-b574-34fe7b571446”,”children”:[],”zIndex”:116},{“html”:”<div>2.不论条件成立，都要进行变量提升<div>当条件中带有 var/function 时，</div></div><div>老版中会将函数提前声明并且定义</div><div>新版中只会将函数提前声明</div><div>var 也会提前声明不定义</div>“,”id”:”a599d7d9-4439-4a3b-b71d-2f76ed26c85c”,”children”:[],”zIndex”:119}],”zIndex”:115}],”zIndex”:120},{“id”:”1dca2046-8497-4f05-b115-81852f0b7fac”,”x”:3046.242779214603,”y”:-1647.7008922638222,”html”:”闭包”,”type”:”mindmap”,”children”:[{“html”:”1.函数运行的一种机制：形成一个不被释放的上下文”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”265c167d-a0dc-42c9-b4f6-5ec76d1bda90”,”children”:[],”zIndex”:121},{“html”:”2.函数执行会形成一个私有上下文 EC(FN)，如果上下文中的某些内容(一般指的是堆内存地址)被上下文以外的事物(例如：变量/事件绑定等)所占用，则当前上下文不能被出栈释放(浏览器的垃圾回收机制 GC 所决定的)”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”858dd510-bb77-4e40-891d-4543e5031ff9”,”children”:[],”zIndex”:122},{“html”:”特点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”af8477d5-4ebf-498f-87e7-9d4e574765e7”,”children”:[{“html”:”保护：保护私有上下文中的“私有变量”和外界互不影响”,”id”:”54f34d37-1785-4f9b-a05f-d4169e6ace5b”,”children”:[],”zIndex”:124},{“html”:”保存：上下文不被释放，那么上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用。”,”id”:”20380cab-e226-452f-aded-1f195727dcf5”,”children”:[],”zIndex”:125}],”zIndex”:123},{“html”:”弊端：如果大量使用闭包，会导致内存溢出或内存泄露。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”827aa6af-6e47-4ec9-a0d3-52764b48eaa3”,”children”:[],”zIndex”:126},{“html”:”应用场景”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”b46cbfda-ffd7-4ff0-8641-1e430f653486”,”children”:[{“html”:”1.循环事件绑定的 N 中解决办法”,”id”:”819a137a-9a3b-446f-b013-85fe69930b4a”,”children”:[{“html”:”1.利用闭包，创建私有上下文<div>性能不好</div>“,”id”:”153fdb2d-542e-4989-9b1f-d36498b940a3”,”children”:[{“html”:”自执行函数 function 包起来”,”id”:”8f6e67f1-0491-44f2-9188-a4e18e2721df”,”children”:[],”zIndex”:130},{“html”:”let”,”id”:”ce886cba-ba2c-4a85-9cd6-951884e9e0a7”,”children”:[],”zIndex”:131}],”zIndex”:129},{“html”:”2.自定义属性(与闭包无关)<div>性能好</div>“,”id”:”59bbd6b3-67f7-40dd-baa0-38bc1368d074”,”children”:[],”zIndex”:132},{“html”:”3.事件委托（它们都有一个共同的父元素，冒泡）<div>性能提升 40%～ 60%</div>“,”id”:”1c10e55e-cbc9-48b0-b865-d663b2f02159”,”children”:[],”zIndex”:133}],”zIndex”:128}],”zIndex”:127}],”zIndex”:134},{“id”:”6b5c2568-7f4e-458c-8a4e-4a6eb593dc1c”,”x”:1976.33793831011,”y”:-778.975022658044,”html”:”JS 中声明变量”,”type”:”mindmap”,”children”:[{“html”:”传统：var function”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”79f3c1d1-e2bb-4350-8adb-7dd486ce3000”,”children”:[{“html”:”带 var 的只是提前声明”,”id”:”44efc85a-7c90-4463-bb32-3e1cb5c1fec2”,”children”:[],”zIndex”:142},{“html”:”带 function 的是声明+定义”,”id”:”eff77c0d-9251-4126-ba0c-526ff0bd036d”,”children”:[],”zIndex”:143}],”zIndex”:135},{“html”:”ES6+”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”d0339732-669e-4979-a8eb-4e63b94a833e”,”children”:[{“html”:”ES5 - ES2011 <div>ES6 - ES2015 </div><div>ES2016 </div><div>ES2017 </div><div>…</div>“,”id”:”f7ebf72c-9b6a-4b39-a018-caaa30578fd9”,”children”:[],”zIndex”:138},{“html”:”let”,”id”:”8b58615c-51b7-481b-8b19-0fd6d0e99359”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;声明的变量可以改变引用指向</span>“,”id”:”d25f6d89-3223-48fb-871b-a0534862f5a8”,”children”:[],”zIndex”:139}],”zIndex”:137},{“html”:”const”,”id”:”4c97cef8-2c21-487f-a618-86b66e72d4b1”,”children”:[{“html”:”&lt;span style=&quot;color:rgb(228, 130, 212);&quot;&gt;声明的变量不可以改变引用指向</span>，他声明的值叫常量”,”id”:”b75c0670-4aa5-401d-ba99-c433d751dd84”,”children”:[],”zIndex”:141}],”zIndex”:140}],”zIndex”:136},{“html”:”let VS var”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”9bdc1d9f-84f4-432a-bad3-ae0e855faf5a”,”children”:[{“html”:”1.var 存在变量提升，而 let 不存在”,”id”:”a54ea328-0408-4ead-8550-2e91fda0a894”,”children”:[],”zIndex”:145},{“html”:”&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;2.</span>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;【旧版】“全局上下文 EC(G)”中，基于 var/function 声明的变量，也相当于给 GO 全局对象(window)新增一个属性，并且任何一个发生值的改变，另一个也会跟着改变（映射机制）；</span><div>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;【新版】</span>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;“全局上下文 EC(G)”中，基于 var/function 声明的变量，只是给全局对象 GO 设置一个属性；</span>&lt;span style=&quot;color:rgb(228, 132, 132);&quot;&gt;<br></span><div>&lt;span style=&quot;color:rgb(105, 177, 228);&quot;&gt;但是基于 lei 声明的变量，就是全局变量，和 GO 没有任何的关系。</span></div></div>“,”id”:”fa1140b4-9b3b-427a-979d-9e9468dd463a”,”children”:[{“html”:”没有基于任何关键词声明的变量，则相当于给全局对象设置一个属性”,”id”:”260a8569-e788-4e8e-bd3d-57769f47b5fc”,”children”:[],”zIndex”:147}],”zIndex”:146},{“html”:”3.在相同的上下文中，let 不允许重复声明，如果重复声明会报错(词法分析阶段)；而 var 可以重复声明，浏览器只按声明一次处理”,”id”:”ec9744ae-5847-4e74-944a-b2d9efc23767”,”children”:[],”zIndex”:148,”layout”:{“quadrant”:1}},{“html”:”&lt;span style=&quot;color:rgb(105, 177, 228); font-weight:bold;&quot;&gt;4.let/const/function 会产生块级私有上下文，而 var 是不会的</span>“,”id”:”a7f7fd3c-eb17-4bfc-96a8-dd4ac895b29a”,”children”:[],”zIndex”:153}],”zIndex”:144},{“html”:”小知识点”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”99b5f488-cb43-482f-aeb7-1ca4971c736f”,”children”:[{“html”:”词法分析：浏览在执行代码之前，会先把代码解析为浏览器能识别的事物”,”id”:”c3395f6b-239b-4543-a913-e39d51a9047a”,”children”:[],”zIndex”:150},{“html”:”暂时性死区（浏览器暂存的 BUG）”,”id”:”1b8ab318-1a57-4931-80a9-ba43545b266b”,”children”:[{“html”:”1.基于 typeof 检测一个未被声明的变量，不会报错，结果是 undefined”,”id”:”e0e9bbe0-9a2a-461c-bb38-f344dbffc213”,”children”:[],”zIndex”:152}],”zIndex”:151},{“html”:”上下文 &amp; 作用域”,”id”:”259b605d-7f32-468f-af9b-dc230c4d71a3”,”children”:[{“html”:”全局上下文”,”id”:”60fe1681-c8d2-4032-8e05-146e49efa764”,”children”:[],”zIndex”:155},{“html”:”函数执行形成的“私有上下文””,”id”:”8ad7ba5d-dc97-4fe9-a512-3d7b7d43772a”,”children”:[],”zIndex”:156},{“html”:”块级作用域（块级私有上下文）”,”id”:”33fb2c1b-cc40-4c65-87b9-339e88247ca3”,”children”:[{“html”:”除了对象、函数等的大括号除外（例如：判断体、循环体、代码块…）都有可能会产生块级上下文”,”id”:”d7365bba-ac65-47d5-92f3-5fdf50471eee”,”children”:[],”zIndex”:158}],”zIndex”:157}],”zIndex”:154}],”zIndex”:149}],”zIndex”:159},{“id”:”2b6647d5-7501-40c7-b24a-2af42d4f1d80”,”x”:3224.4260039219885,”y”:-752.6815219819359,”html”:”块级上下文”,”type”:”mindmap”,”children”:[{“html”:”除函数/对象的大括号外，在其他的大括号中出现 let/const/function 则会单独形成块级私有上下文”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”2463084f-5d6f-4afc-81c9-48c143726c2f”,”children”:[],”zIndex”:160}],”zIndex”:161},{“id”:”97ab8408-d69f-4080-ac0f-3eaaa781ae45”,”x”:3223.5822818981683,”y”:-598.6400544426056,”html”:”函数形参默认值”,”type”:”mindmap”,”children”:[{“html”:”如果函数应用了形参默认值，并且在函数体中出现了基于 var/let/const 声明变量的方式，这样除了函数执行，会产生一个私有的上下文之外，还会把函数体及其中的代码当做一个全新的块级上下文。如果这个块级上下文中的变量和函数私有上下文中的变量一致了，则会在块级上下文初始化之前，会把形参变量的值同步给块级上下文中的变量”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”9c8f2b7e-56c2-47a1-b9df-e85c35da883e”,”children”:[],”zIndex”:162}],”zIndex”:163},{“id”:”d5954e00-aacc-43cc-9eb2-c6294ca7aa46”,”x”:2013.3631825544453,”y”:-4147.225387630226,”html”:”闭包剧本 🌟”,”type”:”mindmap”,”children”:[{“html”:”引言：就像人需要氧气才能生存，闭包也需要在特定的环境下才能存在，闭包携带了它自己的“氧气罐”（引用了当前作用域以外的其他作用域上下文），所以它才存活下来（使上下文不会消失）。”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DFB85D”},”id”:”fcdf01ae-8066-4dbe-a424-c00f59dc280a”,”children”:[],”zIndex”:175},{“html”:”基本介绍: ECStack、EC、VO、AO、GO、SCOPE、SCOPE-CHAIN、GC”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#A287E1”},”id”:”60b7c46c-ca7f-4b3f-9396-2db05c8e1e5e”,”children”:[],”zIndex”:164},{“html”:”优缺点：保存和保护、性能消耗（内存泄漏）”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#E48484”},”id”:”cb29cf10-c1b0-487b-bb90-93af243dde80”,”children”:[],”zIndex”:165},{“html”:”实战应用”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#69B1E4”},”id”:”8587ed97-be45-46bc-bd35-8f9d9dbbe64d”,”children”:[{“html”:”项目实战应用：循环事件绑定(突出：事件委托)、let 和 var”,”id”:”69d08b2c-6ab1-4a9f-bade-bf8efb909bf0”,”children”:[],”zIndex”:167},{“html”:”插件组件应用：JS 高阶编程技巧(单例设计模式、惰性函数、柯理化函数、compose 组合函数)”,”id”:”efaa7f8c-3eeb-49f1-84bb-a88b621ba442”,”children”:[],”zIndex”:168},{“html”:”源码阅读应用：Lodash 源码(函数的防抖和节流)、JQ 的源码、redux、react-redux(高阶组件)…”,”id”:”6112fd30-eb39-4da2-8ee3-a4d4baee36b3”,”children”:[],”zIndex”:169},{“html”:”…”,”id”:”c0812e77-5a30-4ab8-b565-ebb7d6253ac9”,”children”:[],”zIndex”:170}],”zIndex”:166},{“html”:”自己的思想和理解(一句话概括)”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#DE81C6”},”id”:”5afc0a83-0a2b-4cdd-b605-a16141839cba”,”children”:[{“html”:”其实我觉得闭包这个东西还是很重要的”,”id”:”d7e2dffd-8111-4ecd-b022-83b31b0e2905”,”children”:[],”zIndex”:172}],”zIndex”:171},{“html”:”小技巧”,”layout”:{“quadrant”:1},”treeEdge”:{“stroke”:”#77C386”},”id”:”89d878f9-c202-4d02-b648-3a3b62c6772b”,”children”:[{“html”:”担心自己表达能力：可以自己写一遍文章，详细的介绍闭包（面试的时候，给面试官看，它边看你边简单说一些）”,”id”:”9428a725-67c5-40f8-9f24-aba604e164b2”,”children”:[],”zIndex”:174}],”zIndex”:173}],”zIndex”:176,”tapered”:false},{“id”:”6c0e58ca-1a82-4e47-949e-087c354b99ad”,”x”:2894.570608794177,”y”:-4162.194456348563,”html”:”简述 let 和 var 的区别”,”type”:”mindmap”,”zIndex”:177}]},”viewportSetting”:{“zoom”:0.9529882937207227,”tlCanvasPoint”:[1970.3826987555492,-4590.259820030305,1],”width”:1040,”height”:898},”text”:”数据类型基本类型 numberstringundefinednullbooleansymbol 引用类型 objectarray…functionJS 代码执行 1.游览器会在内存中开辟一块栈内存，全局上下文（环境），也叫 ECStack。2.然后形成全局执行上下文 EC(G)（默认就是 window/global）供代码执行。创建函数 1.单独开辟一个堆内存（16 进制地址），函数堆内存中存储的是函数体中的“代码字符串”。2.创建函数的时候，就声明了它的作用域[scope]，也就是所在的上下文环境。3.把 16 进制的地址存放到栈中，供变量（函数名等）关联引用即可函数执行 1.形成一个全新的，私有的上下文 EC(…)2.当前私有的上下文中，有一个存放本上下文内声明的变量的地方 AO(…)私有变量对象 -&gt; 这里的变量都是当前上下文内的私有变量(当前上下文中声明的变量，形参变量)3.进栈执行 4.代码执行之前还要处理很多事情 1.初始化作用域链[scope-chain]: &lt;当前自己的上下文，上级上下文(创建函数时形成的作用域)&gt;当前函数的上级上下文是创建函数所在的上下文（作用域）后期函数内代码执行，遇到一个变量，我们首先看是否为自己上下文中的私有变量（看 AO 中有没有），如果是私有的变量，则当前变量的操作和外界环境中的变量互不干扰（没有直接关系）；如果不是自己的私有变量，则按照作用域链，查找是否为其上级上下文中的私有变量…直到找到 EC(G)全局上下文为止 作用域链查找机制 2.初始化 this…3.初始化 arguments…4.形参赋值形参都是私有变量（放到 AO 中的）如果不传递实参值，默认值是 undefined5.变量提升 5.代码自上而下执行 6.一般情况下， 函数进栈执行的上下文，进栈执行完成后，会默认出栈释放掉（私有上下文中存储的私有变量和一些值都会被释放掉） -&gt; 目的：为了优化内存空间，减少栈内存的消耗，提高页面或者计算机的处理速度…GC：游览器的垃圾回收机制（内存管理）谷歌：基于查找引用游览器的渲染引擎会在空闲的时候（定期一个时间），依次遍历所有的内存：栈/堆堆：当前内存如果被占用（指针关联地址），则不能释放；如果没有任何的事物占用这个堆，则游览器会自动把这个堆内存释放掉。栈：当前上下文中是否有内容（一般是堆内存）被上下文以外的事物所占用，如果被占用则无法释放（闭包），如果没有被占用则释放掉。EC(G)是加载页面的时候创建，只有关闭页面的时候才会被释放。主动释放：把占用的事物手动赋值为 null（其余的值也可以，但是 null 更好，null 不占空间的），可以实现内存的手动优化 this 函数的执行主体（不等价于执行上下文/作用域）：谁把这个函数执行的在游览器端运行 JS 代码，非函数中的 this 一般都是 window；研究 this 都是研究函数中的 this；有一个特殊的，就是 ES6+中“块级上下文”中的 this，是其所在上下文中的 this（理解为：块级上下文是没有自己 this 的）；想要分清楚函数执行的执行主体(this)，可以按照如下的规律来分析事件绑定当前元素本身普通函数执行看函数前面是否有点，点前面是谁 this 就是谁没有点就是 window/undefiend(严格模式)自执行函数中的 this 一般都是 window/undefined(严格模式)回调函数中的 this 一般也是 window/undefined(严格模式)，除非做过特殊处理括号包起来的函数执行：如果括号中只有一项，就相当于没有括号；如果括号中有很多项，this 就是最后一项      (obj.fn)() -&gt; obj     (a, b, obj.fn)() -&gt; obj 构造函数执行所属类的实例箭头函数执行它的上级上下文基于 call/apply/bind 强制改变 this 高阶编程技巧利用闭包的机制，实现出来的一些高阶编程方式高级单例设计模式早期的模块化设计思想闭包+单例一个对象就是一个单例模式基于闭包的“保护作用”，防止了全局变量污染惰性函数获取元素样式的小知识点 1.dom.style 只有获取元素的内联样式 2.getComputedStyle  IE6</del>8 不兼容获取经过浏览器计算的样式（返回样式对象）惰性思想：干一次可以搞定的，绝对不去做第二次函数柯理化预先处理的思想形成一个不被释放的闭包，把一些信息储存起来，以后基于作用域链，访问到事先储存的信息，然后进行相关的处理。小知识点命令式编程自己编写代码，管控运行的步骤和逻辑（自己可以灵活掌控执行步骤）函数式编程具体实现的步骤已经被封装成方法，我们只需要调用方法获取结果即可，无需关注怎么实现的，用起来方便，代码量减少弊端：灵活性差 curryingcompose 数据类型转换其他类型转换为 Number 能用的办法 parseInt/parseFloat([val])把要转换值先转换为字符串从字符串左侧的第一位开始查找有效数字字符，遇到非有效字符串则立即停止，最后把有效的数字字符串转为数字，如果没有则返回 NaNNumber 只要出现非有效数字字符结果都是 NaNNumber(undefined) 是 NaN 对象转为数字，应该先 valueOf，没有原始值再 toString，最后再把字符串转为数字隐式转换（游览器内部默认是先转换为 Number 再进行计算的）isNaN([val])数学运算在==比较的时候（见== ：2.3）其他类型转换为 Boolean 只有“0、NaN、null、undefined、空字符串”五个值会变为布尔的 FALSE，其余都是 TRUE 其他类型转换为字符串 1.一般都是直接“”包起来 2.只有{}普通对象 toString()是调取的 Object.prototype.toString()，但它不是转换为字符串，而是数据类型检测，返回结果是[object Object]。（其他对象也是可以调用的）==1.类型一样对象比较的是堆内存的地址 NaN == NaN  =&gt; false2.类型不一样（会隐式转换为相同的数据类型）1.null==undefined =&gt; true 但是换成===结果是 false（因为类型不一致）剩下的 null/undefined 和其他任何数据类型值都不相等 2.字符串==对象   要把对象转换为字符串 3.剩下的如果==两边数据类型不一致，都是需要转换为 Number 再进行比较的 parseInt 的处理规则 parseInt([value], [radix])radix 是一个进制，不写或者写 0 默认都按照 10 进制处理。特殊情况：如果 value 是以 0x 开头，则默认值不是 10 而是 16radix 有取值范围：2 ～ 36。如果不在这个区间，则会返回 NaN。作用：把[value]看作[radix]机制，最后把[radix]进制的值转换为十机制。执行过程：1.从左向右开始查找[value]中的有效的[radix]进制值，遇到不是有效的立即停止；如果没有找到，则返回 NaN。2.把查找到的结果转为数字，再把它作为[radix]进制转为十进制。小知识点把一个任意进制的值转换为十进制值：(每个位的数*进制^位权值)的和位权值：个位从 0 开始，依次增 1；小数点后面的从-1 开始，依次减一。变量提升的处理机制 ES3+：在当前上下文中，JS 代码执行之前，浏览器会提前（词法解析的时候）把当前上下文中所有带 var/function 关键字的进行提前的声明或者定义。带 var 声明的变量只提前声明不定义函数会提前声明和定义真实项目中建议用函数表达式创建函数，因为这样在变量提升阶段只会声明 function，更严谨。在使用函数表达式创建函数时，一般要把匿名函数具名化。当函数执行，在形成的私有上下文中，会把这个具名化的名字作为变量，值就是这个函数来进行处理。这样做的好处是：弥补了在严格模式下不能使用 argments.calle 调用当前函数。小知识点 1.基于“var 或 function”在“全局上下文”中声明的变量（全局变量）会映射到 GO（全局对象 window）上一份，作为它的属性；而且是同时修改的。2.不论条件成立，都要进行变量提升当条件中带有 var/function 时，老版中会将函数提前声明并且定义新版中只会将函数提前声明 var 也会提前声明不定义闭包 1.函数运行的一种机制：形成一个不被释放的上下文 2.函数执行会形成一个私有上下文 EC(FN)，如果上下文中的某些内容(一般指的是堆内存地址)被上下文以外的事物(例如：变量/事件绑定等)所占用，则当前上下文不能被出栈释放(浏览器的垃圾回收机制 GC 所决定的)特点保护：保护私有上下文中的“私有变量”和外界互不影响保存：上下文不被释放，那么上下文中的“私有变量”和“值”都会被保存起来，可以供其下级上下文中使用。弊端：如果大量使用闭包，会导致内存溢出或内存泄露。应用场景 1.循环事件绑定的 N 中解决办法 1.利用闭包，创建私有上下文性能不好自执行函数 function 包起来 let2.自定义属性(与闭包无关)性能好 3.事件委托（它们都有一个共同的父元素，冒泡）性能提升 40%～ 60%JS 中声明变量传统：var function 带 var 的只是提前声明带 function 的是声明+定义 ES6+ES5 - ES2011 ES6 - ES2015 ES2016 ES2017 …let 声明的变量可以改变引用指向 const 声明的变量不可以改变引用指向，他声明的值叫常量 let VS var1.var 存在变量提升，而 let 不存在 2.【旧版】“全局上下文 EC(G)”中，基于 var/function 声明的变量，也相当于给 GO 全局对象(window)新增一个属性，并且任何一个发生值的改变，另一个也会跟着改变（映射机制）；【新版】“全局上下文 EC(G)”中，基于 var/function 声明的变量，只是给全局对象 GO 设置一个属性；但是基于 lei 声明的变量，就是全局变量，和 GO 没有任何的关系。没有基于任何关键词声明的变量，则相当于给全局对象设置一个属性 3.在相同的上下文中，let 不允许重复声明，如果重复声明会报错(词法分析阶段)；而 var 可以重复声明，浏览器只按声明一次处理 4.let/const/function 会产生块级私有上下文，而 var 是不会的小知识点词法分析：浏览在执行代码之前，会先把代码解析为浏览器能识别的事物暂时性死区（浏览器暂存的 BUG）1.基于 typeof 检测一个未被声明的变量，不会报错，结果是 undefined 上下文 &amp; 作用域全局上下文函数执行形成的“私有上下文”块级作用域（块级私有上下文）除了对象、函数等的大括号除外（例如：判断体、循环体、代码块…）都有可能会产生块级上下文块级上下文除函数/对象的大括号外，在其他的大括号中出现 let/const/function 则会单独形成块级私有上下文函数形参默认值如果函数应用了形参默认值，并且在函数体中出现了基于 var/let/const 声明变量的方式，这样除了函数执行，会产生一个私有的上下文之外，还会把函数体及其中的代码当做一个全新的块级上下文。如果这个块级上下文中的变量和函数私有上下文中的变量一致了，则会在块级上下文初始化之前，会把形参变量的值同步给块级上下文中的变量闭包剧本 🌟 引言：就像人需要氧气才能生存，闭包也需要在特定的环境下才能存在，闭包携带了它自己的“氧气罐”（引用了当前作用域以外的其他作用域上下文），所以它才存活下来（使上下文不会消失）。基本介绍: ECStack、EC、VO、AO、GO、SCOPE、SCOPE-CHAIN、GC 优缺点：保存和保护、性能消耗（内存泄漏）实战应用项目实战应用：循环事件绑定(突出：事件委托)、let 和 var 插件组件应用：JS 高阶编程技巧(单例设计模式、惰性函数、柯理化函数、compose 组合函数)源码阅读应用：Lodash 源码(函数的防抖和节流)、JQ 的源码、redux、react-redux(高阶组件)……自己的思想和理解(一句话概括)其实我觉得闭包这个东西还是很重要的小技巧担心自己表达能力：可以自己写一遍文章，详细的介绍闭包（面试的时候，给面试官看，它边看你边简单说一些）简述 let 和 var 的区别”}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;{“format”:”lakemind”,”type”:”Mind”,”version”:”1.0”,”diagramData”:{“head”:{“version”:”2.0.0”},”body”:[{“id”:”init”,”type”:”mindmap”,”html”</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>未来的路</title>
    <link href="https://resonance.fun/2020/06/02/yuque/%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%B7%AF/"/>
    <id>https://resonance.fun/2020/06/02/yuque/%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%B7%AF/</id>
    <published>2020-06-02T12:10:59.000Z</published>
    <updated>2022-06-28T21:13:34.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><div class="story post-story"><ol><li>先达到 P6 再考虑其他岗位</li><li>根据自己的喜欢选择 P6 之后要做什么</li><li>先长高、再长胖、最后锻炼为型男。</li><li>读书、读书、读书、读书，目的：锻炼学习能力。</li><li>不要写中规中矩的简历，要按照一定的维度写。只要简历写的好，面试基本上都会过。</li><li>自我介绍不要打磕。</li><li>面试是场修行，是在任何地方都学不到的。</li><li>面试十家左右，即使不去。</li><li>以面养面，做好面试总结。</li><li>面试录音，写成文字稿，重新规划话术。</li><li>今日事今日毕。</li><li>把自己当作一个导演，把面试问答写成剧本，背下来！</li><li>携带自己的思想、见解、经验。</li><li>把每一次面试当做一次演讲。</li><li>任何事情都有三种解决办法，只要心态好。</li></ol></div><h2 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h2><div class="story post-story"><ol><li>不要说上家公司的坏话。</li></ol></div><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><div class="story post-story"><ol><li>温故而知新，可以为师矣a. 养成写笔记、写博客的习惯b. 经常复习之前的内容c. 养成项目总结的习惯</li><li>多练习：敲代码的数量和薪资成正比</li><li>多思考：学而不思则罔、思而不学则殆</li><li>纵向横向发展a. 知其然而知其所以然b. 研究源码c. 多参与开源和讨论d. 多接触一些非技术类的东西</li></ol></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h2&gt;&lt;div class=&quot;story post-story&quot;&gt;&lt;ol&gt;
&lt;li&gt;先达到 P6 再考虑其他岗位&lt;/li&gt;
&lt;li&gt;根据自己的喜欢选择 </summary>
      
    
    
    
    
  </entry>
  
</feed>
