<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>All Resonance</title>
  
  <subtitle>物质的本质是能量，而能量的底层是精神！。</subtitle>
  <link href="https://resonance.fun/atom.xml" rel="self"/>
  
  <link href="https://resonance.fun/"/>
  <updated>2021-07-23T13:02:15.899Z</updated>
  <id>https://resonance.fun/</id>
  
  <author>
    <name>all-resonance</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识汇总</title>
    <link href="https://resonance.fun/2021/06/29/yuque/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://resonance.fun/2021/06/29/yuque/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2021-06-29T16:21:19.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS-的模块化方案"><a href="#JS-的模块化方案" class="headerlink" title="JS 的模块化方案"></a>JS 的模块化方案</h2><p>在浏览器端，有 AMD，通过 require.js 库实现，具有异步按需加载和兼容性好的特点。有 ES Module，它是一种新特性，通过 import、export 实现导入和导出，它的兼容性不太好。在 NodeJS 端，有 CommonJS 方案，它是同步加载的</p><h2 id="JS-小数点计算为什么会丢失精度"><a href="#JS-小数点计算为什么会丢失精度" class="headerlink" title="JS 小数点计算为什么会丢失精度"></a>JS 小数点计算为什么会丢失精度</h2><h2 id="JS-如何精确浮点计算"><a href="#JS-如何精确浮点计算" class="headerlink" title="JS 如何精确浮点计算"></a>JS 如何精确浮点计算</h2><p>例如：如何实现 0.1+0.2=0.3</p><h2 id="JS-如何进行大数计算"><a href="#JS-如何进行大数计算" class="headerlink" title="JS 如何进行大数计算"></a>JS 如何进行大数计算</h2><p>Int 类型超出最大安全数的计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS-的模块化方案&quot;&gt;&lt;a href=&quot;#JS-的模块化方案&quot; class=&quot;headerlink&quot; title=&quot;JS 的模块化方案&quot;&gt;&lt;/a&gt;JS 的模块化方案&lt;/h2&gt;&lt;p&gt;在浏览器端，
有 AMD，通过 require.js 库实现，具有异步按需加载和兼容</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Webpack核心原理</title>
    <link href="https://resonance.fun/2021/06/27/yuque/Webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>https://resonance.fun/2021/06/27/yuque/Webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-27T03:49:50.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>对于<code>Webpack</code>来说，它本质上就是一个模块打包器，正是由于有了<code>Loader</code>和<code>Plugin</code>，才让<code>Webpack</code>有了其他各种各样的功能。​</p><h2 id="Webpack-打包后的文件"><a href="#Webpack-打包后的文件" class="headerlink" title="Webpack 打包后的文件"></a>Webpack 打包后的文件</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo &amp;&amp; cd demo</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack webpack-cli html-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="comment">// devtool: &#x27;none&#x27;, // webpack5中不用配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;built.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="运行打包"><a href="#运行打包" class="headerlink" title="运行打包"></a>运行打包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn webpack</span><br></pre></td></tr></table></figure><p><code>Webpack4</code>打包结果：在<code>Webpack4</code>中，<code>Webpack</code>打包后的文件只是一个<code>IIFE</code>，这个函数的参数是一个“模块定义”的对象。键名是当前被加载文件的文件路径和文件名拼接而来的，键值是一个函数(和<code>NodeJS</code>中的模块加载有些类似)，这个函数会在将来的某个时机被调用，同时会接收到一定的参数，利用这些参数就可以实现模块的加载操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(</span><br><span class="line">      <span class="string">&quot;const test = __webpack_require__(/*! ./test */ \&quot;./src/test.js\&quot;)\nconsole.log(&#x27;hello wlord!&#x27;)\nconsole.log(test)\n\nmodule.exports = &#x27;Index Export&#x27;\n\n//# sourceURL=webpack:///./src/index.js?&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;./src/test.js&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(</span><br><span class="line">      <span class="string">&quot;console.log(11111)\n\n\nmodule.exports = &#x27;Test Exports&#x27;\n\n//# sourceURL=webpack:///./src/test.js?&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Webpack5</code>打包结果：而在<code>Webpack5</code>中，模块定义对象被放到函数内部了，函数参数是空的，代码相比<code>Webpack4</code>更少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">    <span class="string">&quot;./src/index.js&quot;</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="built_in">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      __unused_webpack_exports,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_require__</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(</span><br><span class="line">        <span class="string">&quot;const test = __webpack_require__(/*! ./test */ \&quot;./src/test.js\&quot;)\nconsole.log(&#x27;hello wlord!&#x27;)\nconsole.log(test)\n\nmodule.exports = &#x27;Index Export&#x27;\n\n//# sourceURL=webpack://01/./src/index.js?&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./src/test.js&quot;</span>: <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">eval</span>(</span><br><span class="line">        <span class="string">&quot;console.log(11111)\n\n\nmodule.exports = &#x27;Test Exports&#x27;\n\n//# sourceURL=webpack://01/./src/test.js?&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Check if module is in cache</span></span><br><span class="line">    <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">    <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">      <span class="comment">// no module.id needed</span></span><br><span class="line">      <span class="comment">// no module.loaded needed</span></span><br><span class="line">      <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the module function</span></span><br><span class="line">    __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// startup</span></span><br><span class="line">  <span class="comment">// Load entry module and return exports</span></span><br><span class="line">  <span class="comment">// This entry module is referenced by other modules so it can&#x27;t be inlined</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_exports__ = __webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>我们可以看到打包后是一个<code>IIFE</code>(自执行函数)，而这是为了产生一个闭包。</p><h2 id="单文件打包执行流程解析"><a href="#单文件打包执行流程解析" class="headerlink" title="单文件打包执行流程解析"></a>单文件打包执行流程解析</h2><h2 id="Webpack-打包主流程分析"><a href="#Webpack-打包主流程分析" class="headerlink" title="Webpack 打包主流程分析"></a>Webpack 打包主流程分析</h2><p>编写调试代码，新建<code>debug.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(options);</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    stats.toJson(&#123;</span><br><span class="line">      <span class="attr">entries</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">chunks</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">assets</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打开<code>VS Code</code>调试模式，将断点定到第四行，接下来就开始分析它的主要流程：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于&lt;code&gt;Webpack&lt;/code&gt;来说，它本质上就是一个模块打包器，正是由于有了&lt;code&gt;Loader&lt;/code&gt;和&lt;code&gt;Plugin&lt;/code&gt;，才让&lt;code&gt;Webpack&lt;/code&gt;有了其他各种各样的功能。
​&lt;/p&gt;
&lt;h2 id=&quot;Web</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://resonance.fun/2021/06/07/yuque/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://resonance.fun/2021/06/07/yuque/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-06-07T01:49:08.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>在没有 Node 的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是 Node，如果说 Ajax 给前端能力范围带来了一次革命，那么 Node 也同样给前端工程化带来一次伟大的革命！</p><h2 id="工程化概述"><a href="#工程化概述" class="headerlink" title="工程化概述"></a>工程化概述</h2><p>前端工程化是指遵循一定标准和规范，通过工具去提升效率，他是一种降低成本的手段。</p><p>当下前端功能不断提高，业务复杂日益复杂。因此，在我们没有工程化之前，我们不得不面对一些问题：</p><ul><li>想要使用 ES6+新特性，但是兼容有问题</li><li>想要使用 Less/Sass/PostCSS 增强 CSS 的编程性，但是运行环境不能直接支持。</li><li>想要使用模块化的方式提高项目的可维护性，但是运行环境不能直接支持。</li><li>部署上线前需要<strong>手动</strong>压缩代码及资源文件，部署过程需要<strong>手动</strong>上传代码到服务器。</li><li>多人协作开发，无法硬性统一大家的代码风格，从仓库中 pull 的代码质量无法保证。</li><li>部分功能开发时需要等待后端服务接口提前完成</li></ul><h3 id="工程化主要解决的问题"><a href="#工程化主要解决的问题" class="headerlink" title="工程化主要解决的问题"></a>工程化主要解决的问题</h3><ul><li>传统语言或语法的弊端</li><li>无法使用模块化/组件化</li><li>重复的机械式工作</li><li>代码风格统一、质量保证</li><li>依赖后端服务接口支持</li><li>整体依赖后端项目</li></ul><h3 id="一个项目过程中工程化的表现"><a href="#一个项目过程中工程化的表现" class="headerlink" title="一个项目过程中工程化的表现"></a>一个项目过程中工程化的表现</h3><p>一切以提高效率、降低成本、质量保证为目的的手段都属于工程化。一切重复的工作都应该被自动化，例如：创建项目一&gt;编码一&gt;预览/测试一&gt;提交一&gt;部署</p><h3 id="工程化不等工具"><a href="#工程化不等工具" class="headerlink" title="工程化不等工具"></a>工程化不等工具</h3><p>工具不是工程化的核心，工程化的核心是对项目整体的规划、架构。而工具只是帮助我们去实现和落地的一种手段，例如文件的组织结构，源代码的开发范式(语法、规范、标准)一些成熟的工程化集成有：create-react-app、vue-cli、angular-cli、gatsby-cli</p><p>工程化的一切都应该归功于 Node.js，它让整个前端进行了一次工业革命，可以说，没有 Node.js 就没有现在的前端。因为几乎所有的工程化工具都是用 Node.js 来编写的。但是，面对各种技术工具和新鲜名词，我们不必盲目追求，因为所有的工具都应该是为了解决问题而存在的。</p><p>从一个项目的开发过程开始，我们来了解前端工程化具体实现：</p><h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><p>自动帮助我们创建项目基础结构，并且提供项目规范和约定。看似很普通的需求，背后却隐藏了一定的哲学。因为除了创建文件，它更重要的是还给开发者<strong>提供了一套规范和约定</strong>。比如在开发类似项目时，他们都有以下特征：</p><ul><li>相同的组织结构</li><li>相同的开发范式</li><li>相同的模块依赖</li><li>相同的工具配置</li><li>相同的基础代码</li></ul><p>这导致我们在创建新项目时，有大量的重复工作要做，所以脚手架工具就是用来解决这一类问题的。我们可以通过脚手架快速搭建项目基础骨架，然后基于这个项目骨架来开发项目。由于前端技术选型比较多样，另外也没有一个统一的标准，所以前端方向的脚手架不会集成在某个 IDE 中，它都是以一个独立的工具存在。</p><h3 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h3><p>是一个用于创建现代化 web 应用的脚手架工具。不同于<code>vue-cli</code>这样的工具，它更像一个脚手架的运行平台，我们可以通过<code>Yeoman</code>搭配不同的<code>generator</code>去创建任何类型的项目。也就是说，我们可以创建自己的<code>generator</code>，从而定制属于我们自己的前端的前端脚手架。</p><p>但是它的优点也是它的缺点，在专注于基于框架开发项目的人的眼中，它过于通用化，不够专注。所以他们更愿意使用<code>vue-cli</code>这种专注于某个框架的脚手架。</p><h3 id="Yeoman-基本使用"><a href="#Yeoman-基本使用" class="headerlink" title="Yeoman 基本使用"></a>Yeoman 基本使用</h3><h4 id="安装Yeoman"><a href="#安装Yeoman" class="headerlink" title="安装Yeoman"></a>安装<code>Yeoman</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add yo</span><br></pre></td></tr></table></figure><p>Yeoman 是搭配特定的 generator 才能使用的，所以还需要安装 generator</p><h4 id="安装对应的generator"><a href="#安装对应的generator" class="headerlink" title="安装对应的generator"></a>安装对应的<code>generator</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add generator-node</span><br></pre></td></tr></table></figure><h4 id="通过yo运行generator"><a href="#通过yo运行generator" class="headerlink" title="通过yo运行generator"></a>通过<code>yo</code>运行<code>generator</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo node</span><br></pre></td></tr></table></figure><p>然后根据提示输入项目的相关信息，完成后会自动生成项目。</p><h3 id="Sub-Generator"><a href="#Sub-Generator" class="headerlink" title="Sub Generator"></a>Sub Generator</h3><p>有时候我们并不想安转完整的项目，仅仅只是想在原有的项目基础之上去增加部分文件。</p><p>例如我们想运行<code>generator-node</code>子集下面的 cli 命令，创建一个 cli 应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo node:cli</span><br></pre></td></tr></table></figure><h2 id="自定义-Generator"><a href="#自定义-Generator" class="headerlink" title="自定义 Generator"></a>自定义 Generator</h2><p>虽然市面上也有很多<code>generator</code>，但是他们并不包含我们自己项目的一些公用的依赖或者业务代码。所以，我们仍然有必要自己编写一个专属的<code>generator</code>。</p><h3 id="创建-Generator-模块"><a href="#创建-Generator-模块" class="headerlink" title="创建 Generator 模块"></a>创建 Generator 模块</h3><p>generator 本质上就是一个 npm 模块。不同于其他模块，yeoman 的 ganerator 模块名称必须是 generator-<name>的格式命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir generator</span><br><span class="line">cd generator</span><br><span class="line">yarn init</span><br><span class="line">yarn add yeoman-generator</span><br></pre></td></tr></table></figure><p>上述命令完成后，接下来我们打开项目，然后在项目根目录创建<code>generators/app/index.js</code>文件这个文件会作为<code>Generator</code>的核心入口它需要导出一个继承自<code>Yeoman Generator</code>的类Yeoman Generator 在工作时会自动调用我们在此类中定义的一些生命周期方法我们在这些方法中可以调用父类提供的一些工具方法实现一些功能，例如文件写入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Genetator = <span class="built_in">require</span>(<span class="string">&quot;yeoman-generator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="built_in">this</span>.fs.write(<span class="built_in">this</span>.destinationPath(<span class="string">&quot;temp.txt&quot;</span>), <span class="built_in">Math</span>.random().toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们把这个模块，挂载到本地全局上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure><p>接着就可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo simple  // simple 是上面创建项目定义的项目名称</span><br></pre></td></tr></table></figure><h3 id="根据模板创建文件"><a href="#根据模板创建文件" class="headerlink" title="根据模板创建文件"></a>根据模板创建文件</h3><p>很多时候我们需要自动去创建的文件有很多，而且文件的内容也相对复杂，在这样的情况下，我们可以用模板来创建文件，因为这样更加便捷。在 app 目录下创建<code>templates/foo.txt</code>文件，模板文件支持 ejs 模板引擎的模板语法，比如我们可以使用模板标记<code>&lt;%= title %&gt;</code>动态输出内容，也可以做一些判断、循环的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Genetator = <span class="built_in">require</span>(<span class="string">&quot;yeoman-generator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="built_in">this</span>.templatePath(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = &#123; <span class="attr">title</span>: <span class="string">&quot;Hello xsl~&quot;</span> &#125;;</span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tmpl, output, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对于手动创建每一个文件，通过模板创建大大提升了效率，特别是文件比较多比较复杂的情况下。</p><h3 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a>接收用户输入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="title">prompting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// Yeoman 在询问用户环节会自动调用此方法</span></span><br><span class="line">   <span class="comment">//  在此方法中可以调用父类的prompt() 方法发出对用户的命令行询问</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.prompt([&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;input&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">      <span class="attr">message</span>:<span class="string">&quot;Your project name&quot;</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="built_in">this</span>.appname, <span class="comment">// appname为项目生成目录名称</span></span><br><span class="line">   &#125;]).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.answers = answers</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">writing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="built_in">this</span>.fs.copyTpl(tmpl, output, <span class="built_in">this</span>.answers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plop"><a href="#Plop" class="headerlink" title="Plop"></a>Plop</h2><p>一个小而美的脚手架工具。主要创建项目中特定类型文件的小工具，它类似于 Yeoman 中的 Sub Generator。不过它一般不会独立运行，它用来集成在项目当中，去创建同类型的项目文件。在一个项目当中使用 Plop，需要以下几个步骤：</p><ol><li>将 Plop 模块作为项目开发依赖安装</li><li>在项目根目录下创建一个 plopfile.js 文件</li><li>在 plopfile.js 文件中定义脚手架任务</li><li>编写用于生成特定类型文件的模板</li><li>通过 Plop 提供的 CLI 运行脚手架任务</li></ol><h2 id="脚手架工作原理"><a href="#脚手架工作原理" class="headerlink" title="脚手架工作原理"></a>脚手架工作原理</h2><p>脚手架启动后，会先询问用户一些问题，然后根据这些问题的答案，结合一些模版文件去自动生成项目结构。</p><h2 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h2><blockquote><p>一切重复工作本应该自动化。自动化：让机器代替手工；构建：将 A 转换为 B。</p></blockquote><p>将开发环境的源代码自动化构建为生产环境可运行的代码。一般我们把这个转换的过程称为自动化构建工作流，它的作用是尽可能脱离运行环境兼容带来的问题，在开发环境阶段使用一些提高效率的语法、规范和标准。</p><p>自动化构建将那些不被支持的『特性』，转换为能够直接运行的代码，我们在开发过程中就可以尽情使用提高效率的代码了。</p><h2 id="NPM-Scripts-自动构建工作流"><a href="#NPM-Scripts-自动构建工作流" class="headerlink" title="NPM Scripts 自动构建工作流"></a>NPM Scripts 自动构建工作流</h2><p>可以在 package.json 中定义一些与项目相关的构建命令，它是实现自动化构建工作流的最简方式。在启动 serve 之前构建项目：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;preserve&quot;</span>: <span class="string">&quot;yarn build&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync .&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时执行多个任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add npm-run-all</span><br></pre></td></tr></table></figure><p>然后在 scripts 中添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;build&quot;</span>: <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync .&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;run-p build serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听文件变化并重新编译，监听文件变化并自动热更新：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;build&quot;</span>: <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;browser-sync . --files \“css/*.css\&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;run-p build serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见的自动化构建工具"><a href="#常见的自动化构建工具" class="headerlink" title="常见的自动化构建工具"></a>常见的自动化构建工具</h2><blockquote><p>严格意义上来说，Webpack 属于模块化打包工具，所以不归类在此处</p></blockquote><h3 id="Grunt"><a href="#Grunt" class="headerlink" title="Grunt"></a>Grunt</h3><p>最早的前端构建系统，生态完善。因为它基于临时文件编译的，它在构建过程会对磁盘进行读写操作，所以构建速度会比较慢。例如它在工作时，上个插件将构建结果存储到一个临时文件中，下一个插件又会基于这个临时文件读取内容。如果处理的环节越多，那么对磁盘读写的次数也就会越多，也会更加耗时。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>对于文件读写都是在内存中完成的，所以相对于磁盘读写操作，它的速度更快。同时他也支持多个任务同时执行。它的使用方式比 Grunt 更简单，生态也很完善，是目前前端构建最流行的系统。</p><h3 id="FIS"><a href="#FIS" class="headerlink" title="FIS"></a>FIS</h3><p>百度前端开源内部的构建系统，它把我们在项目中常见的需求都集成在内部了。例如资源加载、模块化开发、代码部署、性能优化。​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在没有 Node 的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是 Node，如果说 Ajax 给前端能力范围带来了一次革命，那么 Node 也同样给前端工程化带来一次伟大的革命</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS性能优化</title>
    <link href="https://resonance.fun/2021/05/26/yuque/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://resonance.fun/2021/05/26/yuque/JS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-26T13:16:12.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存为什么需要管理？如果我们在写代码的过程中，不够了解内存的管理机制，写出不容易被察觉的内存问题性代码，就会给程序带来意想不到的 BUG。</p><ul><li>内存：由可读写单元组成，表示一片可操作空间</li><li>管理：人为的去操作一片空间的申请、使用和释放。</li><li>内存管理: 开发者主动申请空间、使用空间、释放空间。</li><li>管理流程:申请一使用一释放</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请空间（由于JavaScript没有提供相关api，我们只能通过JS执行引擎，遇到变量定义的时候，自动去申请空间）</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 使用空间</span></span><br><span class="line">obj.name = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="JS-中的垃圾回收"><a href="#JS-中的垃圾回收" class="headerlink" title="JS 中的垃圾回收"></a>JS 中的垃圾回收</h2><p>对象在什么情况下会被视为垃圾？</p><ul><li>JS 中的垃圾回收是自动的</li><li>当对象不再被引用时，被视为垃圾</li><li>对象不能从根(全局执行上下文)上访问到时是垃圾</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="number">11</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> ali = obj;</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// &#123;name: 11&#125; 被ali引用，不是一个垃圾</span></span><br></pre></td></tr></table></figure><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><p>GC：垃圾回收机制；它可以找到内存中的垃圾、并释放和回收空间。那么什么样的东西可以被当作垃圾呢？</p><ul><li>程序中不再使用的对象</li><li>程序中能再访问的对象</li></ul><p>GC 算法：算法就是工作时查找和回收所遵循的规则。常见的 GC 算法有：</p><ul><li><p>引用计数</p><p>判断对象的引用来决定是不是垃圾</p></li><li><p>标记清除</p><p>给活动对象添加标记，来判断他是不是垃圾</p></li><li><p>标记整理</p><p>类似标记清除</p></li><li><p>分代回收</p></li></ul><h2 id="引用计数算法实现原理"><a href="#引用计数算法实现原理" class="headerlink" title="引用计数算法实现原理"></a>引用计数算法实现原理</h2><p>核心思想：内部通过一个计数器来维护当前对象的引用数，从而判断当前对象的引用数是否为 0，来决定它是不是一个垃圾对象。当这个对象的引用为 0 的时候，GC 就开始工作，将其所在的对象空间进行回收和释放，然后再使用。</p><p>当某个对象的引用关系发生改变时，引用计数器就会主动去修改当前对象所对应的引用数值。当引用为 0 时，GC 就会将其所在的空间回收。引用关系发生改变：假设我们的代码里面有一个对象空间，如果有一个变量名指向它，这时就把对象空间的引用加 1，如果又有一个变量指向它，那就再加 1；如果是减少的情况，例如取消引用，那就减 1。为 0 时，GC 就会立即将其回收。</p><h3 id="引用计数算法的优缺点"><a href="#引用计数算法的优缺点" class="headerlink" title="引用计数算法的优缺点"></a>引用计数算法的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>发现垃圾时立即回收</li></ul><p>如果引用为 0 就会立即进行回收、释放</p><ul><li>最大限度减少程序暂停</li></ul><p>由于引用计数算法会时刻监控着那么引用为 0 的对象，如果在栈满时，会以最快的速度释放空间。程序就不会因为栈满而停止运行了。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法回收循环引用的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 在全局上下文中，没有使用到这两个对象了，他们已经可以被回收了</span></span><br><span class="line">  <span class="comment">// 但是由于这两个对象相互循环引用，在使用引用计数算法时，他仍然还是有引用并且不为0，因此GC无法对其回收。</span></span><br><span class="line">  obj1.name = obj2;</span><br><span class="line">  obj2.name = obj1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 当函数执行完毕，会释放里面的空间</span></span><br></pre></td></tr></table></figure><ul><li>时间开销大</li></ul><p>需要时刻监控对象是否修改，如果有很多的对象需要修改，需要的时间就会更久一点</p><h2 id="标记清除算法实现原理"><a href="#标记清除算法实现原理" class="headerlink" title="标记清除算法实现原理"></a>标记清除算法实现原理</h2><blockquote><p>标记清除算法相较于引用计数算法，他能解决更多的问题，因此它在 V8 中被大量使用。</p></blockquote><p>核心思想：将整个垃圾回收操作分为两个阶段；第一个阶段，遍历所有对象，然后找到这些活动的对象(可达对象)并进行标记，如果不可达就不会标记并且会在第二个阶段被回收掉。第二个阶段，再次遍历所有对象，然后把那些没有被标记的对象进行清除操作，并把第一阶段中设置的标记抹掉，便于下次 GC 还能够正常工作。最后就可以把相应的垃圾进行回收，然后再把回收的空间交给空闲链表进行维护，下次程序执行就可以向空闲链表申请空间进行使用。</p><h3 id="标记清除算法的优缺点"><a href="#标记清除算法的优缺点" class="headerlink" title="标记清除算法的优缺点"></a>标记清除算法的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>解决了引用计数算法中对象循环引用无法回收的问题</li></ul><p>标记清除算法会递归遍历所有对象，然后将可达对象进行标记；如果两个对象相互循环引用，一旦对象不可达，它始终也能清除标记，GC 也能正常回收。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>不会立即回收对象</p><pre><code> 当遍历对象的时候，即使发现了不可达对象，它也不会立即去进行回收，只有等到最后才会去回收，而且其实这个时候程序是停止工作的。</code></pre></li><li><p>空间碎片化</p></li></ul><p>回收后的空闲地址有可能不是连续的，使用空间时很容易造成空间上的浪费。</p><h2 id="标记整理算法实现原理"><a href="#标记整理算法实现原理" class="headerlink" title="标记整理算法实现原理"></a>标记整理算法实现原理</h2><blockquote><p>和标记清除算法一样，标记整理算法在 V8 也被频繁使用</p></blockquote><p>标记整理算法其实可以看做是标记清除算法的增强版，因为它们在第一个阶段是相同的，都会先遍历所有对象，然后对当前活动对象(可达对象)进行标记操作。</p><p>但是不同的是，标记清除算法是直接对没有标记的进行清除，而标记整理算法会在清除之前进行整理操作，移动对象的位置，并让他们在地址上产生连续。</p><p>这样连续的可用空间，能够最大化的让程序使用到内存释放出来的空闲空间，避免空间碎片化造成空间浪费。</p><h3 id="标记整理算法优缺点"><a href="#标记整理算法优缺点" class="headerlink" title="标记整理算法优缺点"></a>标记整理算法优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>减少碎片化空间</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>不会立即回收垃圾对象</p><h2 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h2><p>V8 是一款主流的 JavaScript 执行引擎。V8 之所以有优越的性能，是因为它优秀的内存管理机制以及 V8 采用的即时编译机制。V8 内存的上限设定：64 位 1.5G 32 位 800M</p><h3 id="V8-垃圾回收策略"><a href="#V8-垃圾回收策略" class="headerlink" title="V8 垃圾回收策略"></a>V8 垃圾回收策略</h3><p>采用分代回收的思想，把内存空间按照一定的规则分为两类，<strong>新生代</strong>存储区和<strong>老生代</strong>存储区。针对不同代采用最高效的 GC 算法，从而对不同的对象进行回收操作。</p><h3 id="V8-中常用的-GC-算法"><a href="#V8-中常用的-GC-算法" class="headerlink" title="V8 中常用的 GC 算法"></a>V8 中常用的 GC 算法</h3><ul><li>分代回收</li><li>空间复制</li><li>标记清除</li><li>标记整理</li><li>标记增量</li></ul><h3 id="V8-如何回收新生代对象"><a href="#V8-如何回收新生代对象" class="headerlink" title="V8 如何回收新生代对象"></a>V8 如何回收新生代对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1429353/1622954154226-5f921e40-e7a4-4868-9956-afae918bd89f.png#align=left&display=inline&height=89&id=ubca4cc3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=831&size=12542&status=done&style=shadow&width=749" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/1429353/1622954154226-5f921e40-e7a4-4868-9956-afae918bd89f.png#align=left&display=inline&height=89&id=ubca4cc3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=831&size=12542&status=done&style=shadow&width=749" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png">如图所示，V8 内部将空间分为了两部分，左侧(From To)小空间专门用于存储新生代对象，在 64 位操作系统中，它的大小为 32M，32 位系统中，它的大小是 16M；<strong>新生代指的是存活时间较短的对象</strong>。比如局部作用域(函数)中定义的变量，当函数执行完，函数出栈时函数中的变量就会被回收。那么，V8 是如何完成新生代对象回收的呢？</p><h4 id="新生代对象回收实现"><a href="#新生代对象回收实现" class="headerlink" title="新生代对象回收实现"></a>新生代对象回收实现</h4><p>回收过程采用复制算法+标记整理算法。首先它会将左侧的小空间也会分成两个部分(From、To)，而且这两个空间是相同大小的。其中我们将 From 称为使用空间，将 To 称为空闲空间。当程序要申请空间时，它会将新申请的活动对象存储于 From 空间，这个时候 To 空间是空闲的没有使用。当 From 使用到一定程度后就会触发 GC 操作，它将 From 空间中的活动对象进行标记，然后对空间整理为连续的，便于后续不会产生碎片化空间，这些操作完成后再将这些活动对象拷贝至 To 空间，From 空间里的对象就有一份备份，这就意味着可以对它进行回收，因为活动对象都在 To 空间里有所体现，所以会直接把 From 空间中的对象进行回收。</p><h4 id="回收细节"><a href="#回收细节" class="headerlink" title="回收细节"></a>回收细节</h4><p>如果我们在拷贝时，发现某一个变量对象所指向的空间，在我们老生代存储区也存在，这个时候就会发生<strong>晋升</strong>的现象。这里的晋升指的就是将新生代的对象移动至老生代中进行存储。判断是否晋升的条件有以下几个：</p><ul><li>经过一轮 GC 还存活的新生代对象需要晋升</li></ul><p>如果新生代中的对象经过一轮 GC 还存活的，我们就可以把它拷贝至老生代存储区进行存储操作。</p><ul><li>在拷贝的过程中，发现 To 空间的使用率超过 25%，也需要把这次的活动对象都移动至老生代存储区中进行存储。</li></ul><p>To 空间的使用率如果超过了限制，那么新进来的对象空间好像就存放不进去了，所以在这里有 25%的限制操作。</p><h3 id="V8-如何回收老生代对象"><a href="#V8-如何回收老生代对象" class="headerlink" title="V8 如何回收老生代对象"></a>V8 如何回收老生代对象</h3><p>如上图所示，老生代对象存放在右侧老生代区域。同样针对于老生代存储区也有大小限制，64 位的操作系统为 1.4G，32 位的操作系统为 700M。老生代对象就是指存活时间较长的对象，例如在全局上下文中存放的变量、闭包中存放的变量数据等。</p><h3 id="老生代对象回收实现"><a href="#老生代对象回收实现" class="headerlink" title="老生代对象回收实现"></a>老生代对象回收实现</h3><p>主要采用标记清除、标记整理、增量标记算法。其实首先使用的是标记清除算法完成垃圾空间的释放和回收，因为它执行的速度是比较快的。当把新生代区域中的内容往老生代存储区域中移动(也就是晋升)的时候，而且老生代的空间又不足以存放所移过来的这些对象，就会触发标记整理，把之前的碎片空间进行整理回收，让我们有更多的空间进行使用。最后会采用增量标记算法对回收效率进行提升。</p><h4 id="新老代细节对比"><a href="#新老代细节对比" class="headerlink" title="新老代细节对比"></a>新老代细节对比</h4><p>新生代区域垃圾回收使用空间换时间，因为他采用的是复制算法，这也就意味着每时每刻都会有空闲的空间存在。但是新生代存储区本身的存储就很小，那么优化出来的空间就更小，所以相对于它带来的时间效率上的提升是微不足道的。老生代区域垃圾回收不适合复制算法，因为他的空间很大，复制很多对象时也会非常消耗时间。</p><h2 id="标记增量如何优化垃圾回收"><a href="#标记增量如何优化垃圾回收" class="headerlink" title="标记增量如何优化垃圾回收"></a>标记增量如何优化垃圾回收</h2><p>当垃圾回收机制工作的时候，是会阻塞我们的程序运行的，程序执行完成后，会暂停下来进行回收操作。标记增量其实就是将一整段的垃圾回收操作拆分成多个小步骤组合着去完成，从而替换掉我们之前一口气去做完的垃圾回收操作。这样做的好处是可以让程序和垃圾回收机制交替着去执行，而不是执行程序时不能进行垃圾回收，垃圾回收时不能执行程序，这样带来的时间消耗也是非常合理的。而且 GC 执行的效率非常快，给用户带来的体验也更加友好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;p&gt;内存为什么需要管理？
如果我们在写代码的过程中，不够了解内存的管理机制，写出不容易被察觉的内存问题性代码，就会给程序带来意想</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES新特性与TypeScript</title>
    <link href="https://resonance.fun/2021/05/26/yuque/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript/"/>
    <id>https://resonance.fun/2021/05/26/yuque/ES%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8ETypeScript/</id>
    <published>2021-05-26T07:47:31.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>我们常说 ECMAScript 是一种脚本语言，通常我们把 ECMAScript 看做是一种标准化规范，而实际上是 JavaScript 是 ECMAScript 的扩展语言。</p><p>在浏览器环境中，JavaScript 等于 ECMAScript 加上 WEB API(DOM+BOM)</p><p>在 NodeJs 环境中，JavaScript 等于 ECMAScript 加上 Node APIS(fs、net、etc.)</p><p>所以，JavaScript 语言本身指的就是 ECMAScript。</p><p>由于 ES5.1 以后的版本相较于之前有了很大的改动，有很多人就习惯简称它们为 ES6，其实他的准确简称应该是 ES2015。</p><h2 id="ES2015-let-与块级作用域"><a href="#ES2015-let-与块级作用域" class="headerlink" title="ES2015 let 与块级作用域"></a>ES2015 let 与块级作用域</h2><p>var 会被变量提升，let 不会有这个问题</p><h2 id="ES2015-const"><a href="#ES2015-const" class="headerlink" title="ES2015 const"></a>ES2015 const</h2><p>const 声明的常量不能再次修改引用的内存地址。</p><h2 id="ES2015-数组的解构"><a href="#ES2015-数组的解构" class="headerlink" title="ES2015 数组的解构"></a>ES2015 数组的解构</h2><p>const [a.b] = [100, 200]可以根据位置提取对应的值</p><h2 id="ES2015-对象的解构"><a href="#ES2015-对象的解构" class="headerlink" title="ES2015 对象的解构"></a>ES2015 对象的解构</h2><p>const {a} = {a:200}和数组不同的是，它需要指定解构的属性名</p><h2 id="ES2015-模板字符串"><a href="#ES2015-模板字符串" class="headerlink" title="ES2015 模板字符串"></a>ES2015 模板字符串</h2><p>和传统的字符串相比，支持多行字符串，还可以使用插值表达式拼接内容，而不用像传统字符串用+号拼接，更便捷。</p><h2 id="ES2015-带标签的模板字符串"><a href="#ES2015-带标签的模板字符串" class="headerlink" title="ES2015 带标签的模板字符串"></a>ES2015 带标签的模板字符串</h2><p>const str = console.log’hello wolrd’模板字符串前面可以带上一个函数，这个函数中可以接收到所有表达式出现的值。</p><h2 id="ES2015-字符串的扩展方法"><a href="#ES2015-字符串的扩展方法" class="headerlink" title="ES2015 字符串的扩展方法"></a>ES2015 字符串的扩展方法</h2><p>startWithendWithincludes</p><h2 id="ES-2015-参数默认值"><a href="#ES-2015-参数默认值" class="headerlink" title="ES 2015 参数默认值"></a>ES 2015 参数默认值</h2><p>function fn(a = 100){}可以在形参后面加上=值一定要将需要添加默认值的形参放在最后，不然可能导致参数默认值无法正常工作。比如:function fn(a=100,b){}fn(100) //我想要形参 a 有一个默认值，但是我可能只会传这一个参数，a 的参数默认值就不能正常工作。因为参数是依次传递的，可选的参数应该放在后面，保证必传的参数能够优先传递。</p><h2 id="ES2015-剩余参数"><a href="#ES2015-剩余参数" class="headerlink" title="ES2015 剩余参数"></a>ES2015 剩余参数</h2><p>arguments…args</p><h2 id="ES2015-展开数组"><a href="#ES2015-展开数组" class="headerlink" title="ES2015 展开数组"></a>ES2015 展开数组</h2><p>console.log(…[100,200,300])</p><h2 id="ES2015-箭头函数与-this"><a href="#ES2015-箭头函数与-this" class="headerlink" title="ES2015 箭头函数与 this"></a>ES2015 箭头函数与 this</h2><p>在箭头函数中没有 this，它的 this 指向它的上级作用域。</p><h2 id="ES2015-对象字面量的增强"><a href="#ES2015-对象字面量的增强" class="headerlink" title="ES2015 对象字面量的增强"></a>ES2015 对象字面量的增强</h2><p>对象中可以省略属性名对应的值，前提是属性名和字面量名称相同。</p><h2 id="ES2015-Object-assign"><a href="#ES2015-Object-assign" class="headerlink" title="ES2015 Object.assign"></a>ES2015 Object.assign</h2><p>var obj3=Object.assign(obj1, obj2)用 obj2 覆盖 obj1 对象，返回的 obj3 它其实就是 obj1</p><h2 id="ES2015-Object-is"><a href="#ES2015-Object-is" class="headerlink" title="ES2015 Object.is"></a>ES2015 Object.is</h2><p>==只比较值，不比较类型，会自动类型转换===比较值和类型，严格模式NaN ===NaN //falseObject.is(NaN,NaN)//true</p><h2 id="ES2015-Proxy"><a href="#ES2015-Proxy" class="headerlink" title="ES2015 Proxy"></a>ES2015 Proxy</h2><p>可以对对象的属性改动进行检测和拦截</p><h2 id="ES2015-Proxy-对比-Object-defineProperty"><a href="#ES2015-Proxy-对比-Object-defineProperty" class="headerlink" title="ES2015 Proxy 对比 Object.defineProperty"></a>ES2015 Proxy 对比 Object.defineProperty</h2><p>Proxy 功能更强大一些。proxy 能够检测 defineProperty 检测不到的行为，比如属性删除，方法调用可以对数组检测Proxy 是一种非侵入式的方式进行代理，不用对原来的对象做任何改动，而 Object.definePropery 则需要我们对原对象做一些特有的改动。</p><h2 id="ES2015-Reflect"><a href="#ES2015-Reflect" class="headerlink" title="ES2015 Reflect"></a>ES2015 Reflect</h2><p>Reflect.getReflect.set提供了一套对对象操作的 api以前的操作方式可能会被废弃掉</p><h2 id="ES2015-Promise"><a href="#ES2015-Promise" class="headerlink" title="ES2015 Promise"></a>ES2015 Promise</h2><p>异步编程解决方案</p><h2 id="ES2015-class"><a href="#ES2015-class" class="headerlink" title="ES2015 class"></a>ES2015 class</h2><h2 id="es2015-静态方法"><a href="#es2015-静态方法" class="headerlink" title="es2015 静态方法"></a>es2015 静态方法</h2><h2 id="es2015-类的继承"><a href="#es2015-类的继承" class="headerlink" title="es2015 类的继承"></a>es2015 类的继承</h2><p>super</p><h2 id="ES2015-Set"><a href="#ES2015-Set" class="headerlink" title="ES2015 Set"></a>ES2015 Set</h2><p>不重复的数组 常用来去重</p><h2 id="ES2015-Map"><a href="#ES2015-Map" class="headerlink" title="ES2015 Map"></a>ES2015 Map</h2><p>let obj ={a:100}let o = new Map()o.set(obj, 666) //它的键就是 obj 对象本身严格的键值对集合，它的键可以是任意类型。</p><h2 id="ES2015-Symbol"><a href="#ES2015-Symbol" class="headerlink" title="ES2015 Symbol"></a>ES2015 Symbol</h2><p>Symbol 表示独一无二的值，他可以作为对象的键( key)。</p><h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h4><p>内部维护了一个全局的注册表，提供了字符串和 Symbol 的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因此Symbol.for(&quot;aa&quot;) = Symbol. for(&quot;aa&quot;) // true</span></span><br><span class="line"><span class="comment">// 如果传入的不是字符串，会自动转换为字符串。</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="literal">true</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot; true&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Symbol-用途"><a href="#Symbol-用途" class="headerlink" title="Symbol 用途"></a>Symbol 用途</h4><ol><li>我们在使用第三方模块时，想要对其扩展，由于我们不知道内部具体定义的哪些属性，在这种情况下，去为其扩展属性，就会很大可能发生冲突的问题。那么使用<code>Symbol</code>作为属性就不会出现这种问题。</li><li>可以为对象添加私有属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  [name]: <span class="string">&quot;xsl&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 只能通过这种方式访问</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.[name])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而当我们在外部使用时，由于不知道内部的唯一键是什么，因此只能通过实例间接访问，而无法在外部直接访问。</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>. log(obj.say)</span><br></pre></td></tr></table></figure><ol start="3"><li> <code>Symbol</code>提供了很多内置常量，用于作为内部方法的标识。这些标识符可以让自定义对象实现 JS 当中内置的接口。比如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol.iterator</span></span><br><span class="line"><span class="comment">// Symbol.hasInstance</span></span><br><span class="line"><span class="comment">// Symbol.toStringTag</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;XObject&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">// [ object XObject]</span></span><br></pre></td></tr></table></figure><p>对象的<code>Symbol</code>属性无法通过<code>for in</code>和<code>Object.keys</code>获取，<code>JSON.stringify</code>时<code>Symbol</code>的属性也会被忽略掉。<strong>可以使用</strong><code>**Object.getOwnPropertySymbols**</code><strong>获取对象的所有</strong><code>**Symbol**</code><strong>类型的属性。</strong></p><h2 id="ES2015-for-of"><a href="#ES2015-for-of" class="headerlink" title="ES2015 for of"></a>ES2015 for of</h2><p>使用 for of 可以遍历所有数据类型默认可以对数组遍历需要实现统一的 Iterable 接口，数组默认内部已经实现了。</p><h2 id="ES2015-Iterable"><a href="#ES2015-Iterable" class="headerlink" title="ES2015 Iterable"></a>ES2015 Iterable</h2><h2 id="ES2016-概述"><a href="#ES2016-概述" class="headerlink" title="ES2016 概述"></a>ES2016 概述</h2><h2 id="ES2017-概述"><a href="#ES2017-概述" class="headerlink" title="ES2017 概述"></a>ES2017 概述</h2><p>允许在参数和数组字面量后边加上小逗号</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们常说 ECMAScript 是一种脚本语言，通常我们把 ECMAScript 看做是一种标准化规范，而实际上是 JavaScript 是 ECMAScript 的扩展语言。&lt;/p&gt;
&lt;p&gt;在浏览器环境中，JavaScript 等于 ECMAScript 加上 WEB A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Javascript中的异步编程</title>
    <link href="https://resonance.fun/2021/05/25/yuque/Javascript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://resonance.fun/2021/05/25/yuque/Javascript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-25T09:49:59.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>javascript 被设计为单线程的，因为如果是多线程的话，在多个并行任务中去操作 DOM 会发生意想不到的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;javascript 被设计为单线程的，因为如果是多线程的话，在多个并行任务中去操作 DOM 会发生意想不到的内容。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>说透函数式编程</title>
    <link href="https://resonance.fun/2021/05/22/yuque/%E8%AF%B4%E9%80%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://resonance.fun/2021/05/22/yuque/%E8%AF%B4%E9%80%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-22T13:18:37.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>说到函数式编程，不得不提到数学里的函数，例如数学公式 x=f(y)就很好的描述了 x 和 y 的映射关系，其实，函数式编程正来源于此。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>函数式编程(Function Programming FP)，FP 是编程范式之一。函数式编程是一个很古老的概念，它和面向对象等概念是并列的，我们可以认为它是一种如何编写代码的“方法论”。函数式编程的思维方式是把现实世界的事物和事物之间的联系抽象到程序世界，在程序中对运算过程进行抽象，具体的做法是，根据输入某种运算获得相应的输出，因为程序开发过程中会涉及很多有输入和输出的函数。有一点需要注意的是，函数式编程中的函数指的不是程序中的函数，而是数学中的函数，即不同数据之间的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数学中的函数</span></span><br><span class="line">y = sin(x); <span class="comment">// 描述x和y之间的映射关系</span></span><br></pre></td></tr></table></figure><p>由此可见在函数式编程的中，对于相同的输入，函数的输出是恒定的，也就是没有副作用的纯函数；没有副作用的意思是它的输出不会因为外部变量的变化而发生变化。</p><p>上面说它是一种“方法论”，那么我们为什么要使用这种“方法论”呢？要想弄清楚这个问题，我们可以从使用函数式编程有什么好处来作为切入口。</p><h2 id="使用函数式编程的好处"><a href="#使用函数式编程的好处" class="headerlink" title="使用函数式编程的好处"></a>使用函数式编程的好处</h2><ul><li>函数式编程可以抛弃 this，不再向面向对象那样经常用到 this</li><li>打包过程中可以更好的利用 tree shaking 过滤无用代码</li><li>方便测试和并行处理</li></ul><p>了解了它的好处，下面来介绍常见的函数式编程都有哪些？不过在此之前，我们先来了解一下函数是一等公民的概念，因为它是后续高阶函数、柯里化等的基础。</p><h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>在 JavaScript 中函数就是一个普通的对象(可以通过 new Function()创建)，我们可以把函数存储到变量、数组、对象中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 new Function(‘alert(1)’)来构造一个新的函数。总结来说，函数是一等公民，它有以下特点：</p><ul><li>函数可以存储在变量中</li><li>函数可以作为参数</li><li>函数可以作为返回值</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数(Higher-order-function)的定义是：可以把函数作为参数传递给另一个函数；可以把函数作为另一个函数的返回结果。我们为什么要使用高阶函数呢？</p><h3 id="使用高阶函数的意义-好处"><a href="#使用高阶函数的意义-好处" class="headerlink" title="使用高阶函数的意义/好处"></a>使用高阶函数的意义/好处</h3><ul><li>使函数抽象化，可以帮我们屏蔽实现细节，每次在调用函数时，我们只需要关注想要的目标。</li><li>对通用问题进行抽象，方便重复调用</li><li>使代码更加简洁</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包(Closure)的定义是：函数和周围的状态(词法环境)的引用捆绑在一起形成闭包。换句话说就是，闭包的形成是因为函数引用了当前作用域以外的其他作用域中的变量。</p><p>深入函数执行机制，函数执行会形成一个执行栈，当执行栈中的内容被执行完成之后，会被游览器垃圾回收机制移除。但如果堆上的作用域成员被外部引用，是不会被移除的，因此内部函数依然可以访问外部函数中的成员。这就是闭包的本质。</p><h3 id="使用闭包的好处"><a href="#使用闭包的好处" class="headerlink" title="使用闭包的好处"></a>使用闭包的好处</h3><p>延长了外部函数中的变量的作用范围。</p><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数的概念其实很简单：“相同的输入永远会得到相同的输出”。也就是我们重复调用同一个函数，函数的返回值是和函数的参数一一对应的。我们可以把纯函数理解为数学中的函数，比如数学中常见的数学公式：y=f(x)，它描述了数据与数据之间(x 和 y)的映射关系。纯函数的特点就是不会保留中间的计算结果，比如无法访问函数内部的运算中间结果，因为它不会对计算结果做数据持久化，并且变量是不可变的，所以纯函数是无状态的。</p><h3 id="使用纯函数的好处"><a href="#使用纯函数的好处" class="headerlink" title="使用纯函数的好处"></a>使用纯函数的好处</h3><ul><li>可缓存：由于纯函数相同的输入始终有相同的输出，我们就可以把函数的结果<strong>缓存</strong>起来，避免重复调用，提高性能。</li><li>方便测试</li><li>方便并行处理：在多线程环境下，避免并行操作共享的内存数据引发的意外情况。</li></ul><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>副作用会让一个函数变得不纯，纯函数根据相同的输入返回相同的输出，如果一个函数依赖于外部的状态就无法保证函数输出相同，就会带来副作用。副作用可能的来源：配置文件、数据库、获取用户的输入等。所有的外部交互都有可能导致副作用，副作用也使得方法通用性下降不适合可扩展性和通用性，同时副作用会给程序中带来安全隐患和不确定性，但是副作用不可能完全禁止，我们应该尽可能控制他们在可控的范围内发生。</p><h2 id="柯里化-Curry"><a href="#柯里化-Curry" class="headerlink" title="柯里化(Curry)"></a>柯里化(Curry)</h2><p>当一个函数有多个参数的时候，先传一部分参数并调用它，这部分参数以后永远不变。然后返回一个新的函数接收剩余的参数，最后返回结果。柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数。因此，柯里化是一种对函数参数的<strong>缓存</strong>。</p><h3 id="柯里化的好处"><a href="#柯里化的好处" class="headerlink" title="柯里化的好处"></a>柯里化的好处</h3><ul><li>让函数变得灵活，让函数的粒度变得更小</li><li>可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能。</li></ul><h3 id="通用柯里化函数"><a href="#通用柯里化函数" class="headerlink" title="通用柯里化函数"></a>通用柯里化函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">iner</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length !== args.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> iner(args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fn.apply(fn, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数组合-compose"><a href="#函数组合-compose" class="headerlink" title="函数组合(compose)"></a>函数组合(compose)</h2><p>纯函数和柯里化函数很容易写出洋葱代码，这是我们不希望看到的。而函数组合可以让我们把细粒度的函数重新组合生成一个新的函数。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">ret, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn(ret);</span><br><span class="line">    &#125;, value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数组合需要满足<strong>结合律</strong>，假如有三个函数 a、b、c，我们可以先把 a、b 函数组合，然后再组合 c；也可以先把 b、c 组合，然后再组合 a，结果是一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说到函数式编程，不得不提到数学里的函数，例如数学公式 x=f(y)就很好的描述了 x 和 y 的映射关系，其实，函数式编程正来源于此。&lt;/p&gt;
&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何提升开发与设计表单类页面时的效率</title>
    <link href="https://resonance.fun/2021/03/06/yuque/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%8D%95%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87/"/>
    <id>https://resonance.fun/2021/03/06/yuque/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%A1%A8%E5%8D%95%E7%B1%BB%E9%A1%B5%E9%9D%A2%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87/</id>
    <published>2021-03-06T11:22:40.000Z</published>
    <updated>2021-07-23T13:02:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>可视化表单   编辑器   代码生成   表单设计</p><table><thead><tr><th align="center">版本</th><th align="center">作者</th><th align="center">更新日期</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">1.0</td><td align="center">feline</td><td align="center">2021/3/8</td><td align="left">拖拽方式组合控件</td></tr><tr><td align="center">2.0</td><td align="center">feline</td><td align="center">2021/3/16</td><td align="left">1.重新布局，设计区域扩大很多(核心不变)</td></tr><tr><td align="center">2.控件拖拽时，页面展示辅助线</td><td align="center"></td><td align="center"></td><td align="left"></td></tr></tbody></table><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开发者要开发表单类业务时，由于表单类型多而且复杂，要将这些表单控件一一组合，未免费时费力。而表单通常都是一些固定的组合，那么能不能在编码之间通过某种方式生成出来呢？此时，我想到如果有一款可视化的编辑器产品能够通过拖拽方式组装页面，同时通过设置面板给所有/单个控件设置统一属性，最后不仅能直观的看到页面效果，还能一键复制代码，一定会带来很大的效率提升！同时也可以用于产品原型的制作。</p><p><a href="https://resonances.gitee.io/react-visual-editor/">点此进入预览版</a> | <a href="https://gitee.com/resonances/react-visual-editor/tree/master/docs/imgs">效果图</a></p><h2 id="利益相关方"><a href="#利益相关方" class="headerlink" title="利益相关方**"></a>利益相关方**</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1617853708633-c4bf2a5c-fe21-4c9f-9931-5d9383eedded.jpeg" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2021/jpeg/1429353/1617853708633-c4bf2a5c-fe21-4c9f-9931-5d9383eedded.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><ol><li>用例开始</li><li>用户打开页面</li><li>页面提示可以点击左侧按钮展开控件面板</li><li>用户点击左侧菜单按钮</li><li>左侧区域出现控件面板</li><li>用户点选某个控件</li><li>控件被自动添加到页面中间的设计区域</li><li>系统提示可以对控件进行设置属性</li><li>用户右击控件</li><li>弹出菜单选项</li><li>用户选择“设置属性”</li><li>右侧区域出现属性面板</li><li>用户直接选择系统预设的不同属性</li><li>系统提示可以点击运行按钮查看生成的页面与代码</li><li>用户点击运行按钮</li><li>系统自动生成代码成功</li><li>系统展示生成完成的代码与效果页面</li><li>用户将代码复制</li><li>用例结束</li></ol><h2 id="扩展流程"><a href="#扩展流程" class="headerlink" title="扩展流程"></a>扩展流程</h2><p>11a. 用户选择“复制这个”11a1. 系统自动添加一个相同的控件11b. 用户选择“删除这个”11b1. 系统自动将此控件删除16a. 系统自动生成代码失败16a1. 系统提示：运行错误16a2. 执行用例 1</p><h2 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h2><ul><li><input checked="" disabled="" type="checkbox"> 布局设置流程打通</li></ul><p>目前可以对全部或部分组件进行布局设置了。</p><ul><li><input disabled="" type="checkbox"> 支持用户自定义请求 options</li><li><input disabled="" type="checkbox"> 支持用户自定义表单提交方法</li></ul><p>比如请求某个接口</p><ul><li><input disabled="" type="checkbox"> 生成的代码提取公共部分并抽离</li><li><input disabled="" type="checkbox"> 快捷键支持</li></ul><p>使用快捷键来快速实现某个功能比如：复制、剪切、删除、打开面板</p><ul><li><input disabled="" type="checkbox"> 生成后的页面可以转为 HTML 并下载、预览</li><li><input disabled="" type="checkbox"> 支持绘制元素</li></ul><p>不仅限于表单，也可以绘制图标、方块、等多种元素</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可视化表单   编辑器   代码生成   表单设计&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;版本&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作者&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;更新日期&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    
  </entry>
  
</feed>
