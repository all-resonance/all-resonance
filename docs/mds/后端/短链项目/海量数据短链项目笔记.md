---
urlname: short-link-project
title: 海量数据短链项目笔记
updated: '2024-01-16 15:04:37'
date: '2024-01-16 15:04:15'
status: 已发布
catalog:
  - 后端
  - 短链项目
---
## 业务背景：为啥需要短链?
- 公司电商产品推广、业务活动⻚、广告落地⻚缺少实时【数据反馈和渠道效果分析】

- 老项目业务推广【没人维护，无法做埋点】需要统计效果

- APP和营销活动发送营销短信链接过⻓，【浪费短信发送费用】

- SaaS平台盈利
	- 用户按量付费，根据流量包选择付费购买对应的套餐
		- 不同流量包权益不一样
		- 每天可以创建的短链次数不一样
			- 流量包使用时间限制、支持流量包叠加
			- 注册用户每天有一定免费使用次数，但是不能查看数据
		
## 为什么需要学方法论
### 方法论: 通俗来说就是【做事套路，解决问题的方法(手段/途径/工具)】
### 为什么要学方法论，常⻅的有哪些是必备的
- 新业务规划(PEST)
	- 指的是政治(Political)、经济(Economic)、社会 (Social)和技术(Technological)
		- 政治环境主要是看我们的国家现在是否鼓励相关的业务
			- 经济环境又可以分为宏观经济和微观经济，包括居⺠消费 水平、产业结构
			- 社会环境则是说跟社会的⻛俗习惯是否吻合
			- 技术环境当然就是说的我们的技术实力(ASML光刻机)
		
- 运营推广(AARRR)
	- 什么是AARRR用户增⻓模型
		- AARRR是Acquisition、Activation、Retention、Revenue、 Referral 五个单词的缩写，对应用户生命周期中的5个重要环节。
			- 通俗来说就是一个产品从0~1到100的方法论
			- 指引产品运营在不同的产品运营阶段，思考哪些关键节点，更好各个节点的指标数据
			- AARRR详细解释
		- 获取：新用户首单免费/低价(瑞幸、拼多多)、厂商预装(手 机)、买量投放
			- 激活：app推送、短信推送、产品价值激活
			- 留存：签到、活动短信推送、平台价值提供
			- 收益：平台广告、电商变现、付费会员、融资、软件服务
			- 传播：好友助力、分享抽奖、兄弟砍我一刀
		
- SWOT态势分析法
	- 官方: 用来确定企业自身的竞争优势、劣势、外部市场的机会和威胁，从而将公司的战略与公司内部资源、外部环境有机地结合起来的一种科学的分析方法
		- 4个单词的缩写 优势=strength、劣势=weakness、机会 =opportunity、威胁=threats
		- 优势和弱势是内部环境的分析，机会和威胁是对于外部环境的分析
			![image.png](/images/c81eab63612e9f0def627640652a94e3.png)	- 外部的机会正好是你的优势，赶紧利用起来
			- 外部的机会但是你的劣势，需要改进
			- 自身具有优势但外部存在威胁，就需要时刻思考、保持警惕
			- 是威胁又是你的劣势，就规避并消除
		
- 团队管理(SMART)
	- 源于国外管理大师的《管理的实践》
		- 是为了利于员工更加明确高效地工作，更是为了管理者将来对员工实施绩效考核提供了考核目标和考核标准，使考核更加科学化、规范化
		- 是5个单词的缩写
		- Specific: 目标要具体
			- Measurable: 目标成果要可衡量(量化)
			- Attainable: 目标要可实现，避免过高/过低
			- Relevant: 与其他目标有一定的相关性
			- Time bound: 目标必须有明确的期限
			- 意义: 在制定工作目标或者任务目标时，考虑一下目标与计划 是不是SMART化的。只有具备SMART化的计划才是具有良好可实施性的，也才能指导保证计划得以实现
	
## 开发规范
### 开发人员
总负责人：1

| 岗位   | 技术              | 设计 | 产品          | 运营+市场                  |
| ---- | --------------- | -- | ----------- | ---------------------- |
| 负责人  | 1               | 1  | 1           | 1                      |
| 相关人员 | 后端4、前端2、测试1、运维1 | 1  | 产品需求1、数据分析1 | 用户运营1、内容运营1、渠道投放1、KA客户 |

项目业务的1号位，负责总把控各个事项，也是背负最大KPI压力的人，做的好也是最受益的人
岗位负责人：1号位正常都是带多个项目的，很少可能只带一个项目，基本只和岗位负责人进行对接岗位负责人负责团的组建和管理
### 一定要避免单点故障
- 一个微服务起码两个人熟悉：一个是主程一个是技术leader，推荐是团队里面两个开发人员

### N方库说明
- 一方库: 本工程内部子项目模块依赖的库(jar 包)。

- 二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库 (jar包)。

- 三方库: 公司之外的开源库(jar 包)。

### POJO实体类
- POJO(Plain Ordinary Java Object): 在手册中，POJO 专指只有 setter / getter / toString 的简单类，包括DO/DTO/BO/VO 等，禁止命名成xxxPOJO

### 各个层级约束规范
- A) Service/DAO层方法命名规约

1. 获取单个对象的方法用get做前缀。

1. 获取多个对象的方法用list做前缀，复数形式结尾，如: listObjects。

1. 获取统计值的方法用count做前缀。

1. 插入的方法用save/insert做前缀。

1. 删除的方法用remove/delete做前缀。

1. 修改的方法用update做前缀。

- B) 领域模型命名规约

1. 数据对象: xxxDO，xxx即为数据表名。

1. 一般数据传输对象: xxxDTO，xxx为业务领域相关的名称，项目里面也用VO。

1. 展示对象: xxxVO，也就是响应给前端的实体包装类。

1. 接收前端json对象请求的命名为XXXRequest

### Manager分层说明
- 通用业务处理层，它有如下特征
	![image.png](/images/865a361153d663414bd5db718da95afe.png)	- 对第三方平台封装的层，预处理返回结果及转化异常信息
		- 对Service层通用能力的下沉，如缓存方案、中间件通用处理
		- 与DAO层交互，对多个DAO的组合复用。
	
## 统一接口响应协议-响应工具类封装
### 1. 新建`enums`包，在新建的包中新建`BizCodeEnum`枚举。
统一业务状态码 `BizCodeEnum`，这是一个枚举类。
### 2. 新建`util`包，在新建的包中新建`JsonData`类。
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonData {
    /**
     * 状态码 0 表示成功
     */

    private Integer code;
    /**
     * 数据
     */
    private Object data;
    /**
     * 描述
     */
    private String msg;

    /**
     *  获取远程调用数据
     *  注意事项：
     *      支持多单词下划线专驼峰（序列化和反序列化）
     *
     * @param typeReference
     * @param <T>
     * @return
     */
    public <T> T getData(TypeReference<T> typeReference){
        return JSON.parseObject(JSON.toJSONString(data),typeReference);
    }

    /**
     * 成功，不传入数据
     * @return
     */
    public static JsonData buildSuccess() {
        return new JsonData(0, null, null);
    }

    /**
     * 成功，传入数据
     * @param data
     * @return
     */
    public static JsonData buildSuccess(Object data) {
        return new JsonData(0, data, null);
    }

    /**
     * 失败，传入描述信息
     * @param msg
     * @return
     */
    public static JsonData buildError(String msg) {
        return new JsonData(-1, null, msg);
    }

    /**
     * 自定义状态码和错误信息
     * @param code
     * @param msg
     * @return
     */
    public static JsonData buildCodeAndMsg(int code, String msg) {
        return new JsonData(code, null, msg);
    }

    /**
     * 传入枚举，返回信息
     * @param codeEnum
     * @return
     */
    public static JsonData buildResult(BizCodeEnum codeEnum){
        return JsonData.buildCodeAndMsg(codeEnum.getCode(),codeEnum.getMessage());
    }
}

```
## 自定义全局异常+处理器开发
### 1. 新建`exception`包，在新建的包中新建`BizException`类。
```java
@Data
public class BizException extends RuntimeException {

    private int code;

    private String msg;

    public BizException(Integer code, String message) {
        super(message);
        this.code = code;
        this.msg = message;
    }

    public BizException(BizCodeEnum bizCodeEnum){
        super(bizCodeEnum.getMessage());
        this.code = bizCodeEnum.getCode();
        this.msg = bizCodeEnum.getMessage();
    }

}
```
### 2. 继续，在新建的包中新建`CustomExceptionHandler`类，它是一个全局异常处理器。
```java
@ControllerAdvice
//@RestControllerAdvice
@Slf4j
public class CustomExceptionHandler {
    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public JsonData handler(Exception e){

        if(e instanceof BizException){
            BizException bizException = (BizException) e;
            log.error("[业务异常]{}",e);
            return JsonData.buildCodeAndMsg(bizException.getCode(),bizException.getMsg());
        }else {
            log.error("[系统异常]{}",e);
            return JsonData.buildError("系统异常");
        }
    }
}
```
## common通用工具和时间格式化工具类
### 时间格式化工具类封装
```java
public class TimeUtil {

    /**
     * 默认日期格式
     */
    private static final String DEFAULT_PATTERN = "yyyy-MM-dd HH:mm:ss";

    /**
     * 默认日期格式
     */
    private static final DateTimeFormatter DEFAULT_DATE_TIME_FORMATTER  = DateTimeFormatter.ofPattern(DEFAULT_PATTERN);

    private static final ZoneId DEFAULT_ZONE_ID = ZoneId.systemDefault();

    /**
     * LocalDateTime 转 字符串，指定日期格式
     * @param localDateTime
     * @param pattern
     * @return
     */
    public static String format(LocalDateTime localDateTime, String pattern){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String timeStr = formatter.format(localDateTime.atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     * Date 转 字符串, 指定日期格式
     * @param time
     * @param pattern
     * @return
     */
    public static String format(Date time, String pattern){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        String timeStr = formatter.format(time.toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     *  Date 转 字符串，默认日期格式
     * @param time
     * @return
     */
    public static String format(Date time){
        String timeStr = DEFAULT_DATE_TIME_FORMATTER.format(time.toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     * timestamp 转 字符串，默认日期格式
     *
     * @param timestamp
     * @return
     */
    public static String format(long timestamp) {
        String timeStr = DEFAULT_DATE_TIME_FORMATTER.format(new Date(timestamp).toInstant().atZone(DEFAULT_ZONE_ID));
        return timeStr;
    }

    /**
     * 字符串 转 Date
     *
     * @param time
     * @return
     */
    public static Date strToDate(String time) {
        LocalDateTime localDateTime = LocalDateTime.parse(time, DEFAULT_DATE_TIME_FORMATTER);
        return Date.from(localDateTime.atZone(DEFAULT_ZONE_ID).toInstant());
    }

    /**
     * 获取当天剩余的秒数,用于流量包过期配置
     * @param currentDate
     * @return
     */
    public static Integer getRemainSecondsOneDay(Date currentDate) {
        LocalDateTime midnight = LocalDateTime.ofInstant(currentDate.toInstant(),
                        ZoneId.systemDefault()).plusDays(1).withHour(0).withMinute(0)
                .withSecond(0).withNano(0);

        LocalDateTime currentDateTime = LocalDateTime.ofInstant(currentDate.toInstant(),
                ZoneId.systemDefault());
        long seconds = ChronoUnit.SECONDS.between(currentDateTime, midnight);
        return (int) seconds;
    }
}
```
### Json序列化工具类封装
生产环境不能用`e.printStackTrace()`输出堆栈，有性能影响。
```java
@Slf4j
public class JsonUtil {
    private static final ObjectMapper mapper = new ObjectMapper();

    static {
        //设置可用单引号
        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);

        //序列化的时候序列对象的所有属性
        mapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);

        //反序列化的时候如果多了其他属性,不抛出异常
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        //如果是空对象的时候,不抛异常
        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);

        //取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
    }

    /**
     * 对象转为Json字符串
     * @param obj
     * @return
     */
    public static String obj2Json(Object obj) {
        String jsonStr = null;
        try {
            jsonStr = mapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return jsonStr;
    }
  
    /**
     * json字符串转为对象
     * @param jsonStr
     * @param beanType
     * @return
     */
    public static <T> T json2Obj(String jsonStr, Class<T> beanType) {
        T obj = null;
        try {
            obj = mapper.readValue(jsonStr, beanType);
        } catch (Exception e){
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return obj;
    }

    /**
     * json数据转换成pojo对象list
     * @param jsonData
     * @param beanType
     * @return
     */
    public static <T> List<T> json2List(String jsonData, Class<T> beanType) {
        JavaType javaType = mapper.getTypeFactory().constructParametricType(List.class, beanType);
        try {
            List<T> list = mapper.readValue(jsonData, javaType);
            return list;
        } catch (Exception e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return null;
    }

    /**
     * 对象转为byte数组
     * @param obj
     * @return
     */
    public static byte[] obj2Bytes(Object obj) {
        byte[] byteArr = null;
        try {
            byteArr = mapper.writeValueAsBytes(obj);
        } catch (JsonProcessingException e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return byteArr;
    }

    /**
     * byte数组转为对象
     * @param byteArr
     * @param beanType
     * @return
     */
    public static <T> T bytes2Obj(byte[] byteArr, Class<T> beanType) {
        T obj = null;
        try {
            obj = mapper.readValue(byteArr, beanType);
        } catch (Exception e) {
            //e.printStackTrace();
            log.error("json格式化异常:{}",e);
        }
        return obj;
    }
}
```
### common工具大集合
```java
@Slf4j
public class CommonUtil {
    /**
     * 获取ip
     *
     * @param request
     * @return
     */
    public static String getIpAddr(HttpServletRequest request) {
        String ipAddress = null;
        try {
            ipAddress = request.getHeader("x-forwarded-for");
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("WL-Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getRemoteAddr();
                if (ipAddress.equals("127.0.0.1")) {
                    // 根据网卡取本机配置的IP
                    InetAddress inet = null;
                    try {
                        inet = InetAddress.getLocalHost();
                    } catch (UnknownHostException e) {
                        // e.printStackTrace();
                        log.warn("获取ip异常", e);
                    }
                    ipAddress = inet.getHostAddress();
                }
            }
            // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割
            if (ipAddress != null && ipAddress.length() > 15) {
                // "***.***.***.***".length()
                // = 15
                if (ipAddress.indexOf(",") > 0) {
                    ipAddress = ipAddress.substring(0, ipAddress.indexOf(","));
                }
            }
        } catch (Exception e) {
            ipAddress = "";
        }
        return ipAddress;
    }

    /**
     * 获取全部请求头
     *
     * @param request
     * @return
     */
    public static Map<String, String> getAllRequestHeader(HttpServletRequest request) {
        Enumeration<String> headerNames = request.getHeaderNames();
        Map<String, String> map = new HashMap<>();
        while (headerNames.hasMoreElements()) {
            String key = (String) headerNames.nextElement();
            //根据名称获取请求头的值
            String value = request.getHeader(key);
            map.put(key, value);
        }

        return map;
    }

    /**
     * MD5加密
     *
     * @param data
     * @return
     */
    public static String MD5(String data) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] array = md.digest(data.getBytes("UTF-8"));
            StringBuilder sb = new StringBuilder();
            for (byte item : array) {
                sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));
            }
            return sb.toString().toUpperCase();
        } catch (Exception exception) {
        }
        return null;
    }

    /**
     * 获取验证码随机数
     *
     * @param length
     * @return
     */
    public static String getRandomCode(int length) {

        String sources = "0123456789";
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < length; j++) {
            sb.append(sources.charAt(random.nextInt(9)));
        }
        return sb.toString();
    }

    /**
     * 获取当前时间戳
     *
     * @return
     */
    public static long getCurrentTimestamp() {
        return System.currentTimeMillis();
    }

    /**
     * 生成uuid
     *
     * @return
     */
    public static String generateUUID() {
        return UUID.randomUUID().toString().replaceAll("-", "").substring(0, 32);
    }

    /**
     * 获取随机长度的串
     *
     * @param length
     * @return
     */
    private static final String ALL_CHAR_NUM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    public static String getStringNumRandom(int length) {
        //生成随机数字和字母,
        Random random = new Random();
        StringBuilder saltString = new StringBuilder(length);
        for (int i = 1; i <= length; ++i) {
            saltString.append(ALL_CHAR_NUM.charAt(random.nextInt(ALL_CHAR_NUM.length())));
        }
        return saltString.toString();
    }

    /**
     * 响应json数据给前端
     *
     * @param response
     * @param obj
     */
    public static void sendJsonMessage(HttpServletResponse response, Object obj) {
        response.setContentType("application/json; charset=utf-8");

        try (PrintWriter writer = response.getWriter()) {
            writer.print(JsonUtil.obj2Json(obj));
            response.flushBuffer();
        } catch (IOException e) {
            log.warn("响应json数据给前端异常:{}", e);
        }
    }
}
```
## Q: 海量数据下每天免费次数怎么更新? 
记录中...
## Q: 海量数据付费流量套餐包每天次数限制怎么更新? 
记录中...
## Q: 高性能扣减流量包设计怎么做? 
记录中...
## Q: 流量包数据更新处理-高并发下分布式事务怎么解决
记录中...
## 账号微服务注册模块+短信验证码
### 功能需求
- 使用手机号注册，已经注册的手机号不能︎重复注册，密码不能使用简单的MD5加密

- 用户上传头像需要用文件存储

### 安全需求
- 高并发下账号唯一性，注册邮箱或者手机验证码不能被恶意调用
	- 验证码+唯一索引
	
- 头像文件存储访问方便扩容和管理
	- 阿里云OSS
	
- 高并发处理
	- 异步+池化思想
	
### 短链平台选择
- 使用短信验证码注册

- 头像存储使用阿里云OSS

## Jmeter压测
开源免费，功能强大，在互联网公司普遍使用
## 常规压测流程
- 内网环境

- 非GUI下压测

- 停止其他无关资源进程

- 压测机和被压测机器隔离

## Q: 高并发下异步请求解决方案-`@Async`注解
同步发送请求在高并发下有性能问题，用测试工具压测结果：
- 错误: Connection timed out

- 400到500qps

解决方式是异步发送+池化思想
### A: `@Async`组件
- 使用场景
	- 适用于处理log、发送邮件、短信......等
		- 涉及到网络IO调用等操作
	
- 使用方式
	- 启动类里面使用`@EnableAsync`注解开启功能，自动扫描
		- 定义异步任务类并使用`@Component`标记组件被容器扫描，异步方法加上`@Async`
	
- `@Async`失效情况
	- 注解`@Async`的方法不是`public`方法
		- 注解`@Async`的返回值只能为`void`或者`Future`
		- 注解`@Async`方法使用`static`修饰也会失效
		- spring无法扫描到异步类，没加注解`@Async` 或 `@EnableAsync`注解
		- 调用方与被调方不能在同一个类
		- Spring 在扫描bean的时候会扫描方法上是否包含`@Async`注解，动态地生成一个子类(即proxy代理类)，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，代理类在调用时增加异步作用
			- 如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean，所以就失效了
			- 所以调用方与被调方不能在同一个类，主要是使用了动态代理，同一个类的时候直接调用，不是通过生成的动态代理类调用
			- 一般将要异步执行的方法单独抽取成一个类
			- 类中需要使用`@Autowired`或`@Resource`等注解自动注入，不能自己手动new对象
		- 在Async方法上标注`@Transactional`是没用的，但在Async方法调用的方法上标注`@Transactional`是有效的
	
#### 线程池默认机制问题
- 压测后很快跑完全部内容，是因为都在线程池内部的阻塞队列里面

- 极容易出现OOM，或者消息丢失

#### 默认线程策略说明
- 代码位置
	- `TaskExecutionProperties`
		- `TaskExecutionAutoConfiguration`
	
- 若未指定线程池，使用 `@Async` 注解时，将默认使用 Spring 创建的 `ThreadPoolTaskExecutor`。

- 核心线程数：8

- 最大线程数：`Integer.MAX_VALUE`（约 21 亿多）

- 队列类型：`LinkedBlockingQueue`

- 队列容量：`Integer.MAX_VALUE`

- 空闲线程保留时间：60 秒

- 线程池拒绝策略：`AbortPolicy`

#### **线程池****工作机制**
- 当新任务到达并且当前运行的线程数少于核心线程数时，线程池会创建新线程来处理任务，即使有空闲线程。

- 当运行的线程数达到核心线程数但小于最大线程数时，新来的任务会被加入到队列中（如果队列已满，则会创建新线程，直到达到最大线程数）。

- 如果运行的线程数已经等于最大线程数，新来的任务将会根据配置的拒绝策略被处理，例如抛出异常、运行拒绝任务的处理程序等。

Spring线程池的默认行为可能不会适当地处理运行时异常。如果没有正确配置错误处理逻辑，这可能导致问题被忽略或不正确地处理。

存在OOM风险，所以需要根据情况重新配置线程池策略。
#### 自定义线程池策略
```java
@Configuration
@EnableAsync
public class ThreadPoolTaskConfig {
    @Bean("threadPoolTaskExecutor")
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){

        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        //线程池创建的核心线程数，线程池维护线程的最少数量，即使没有任务需要执行，也会一直存活
        //如果设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
        executor.setCorePoolSize(16);
        //executor.setAllowCoreThreadTimeOut();

        //阻塞队列 当核心线程数达到最大时，新任务会放在队列中排队等待执行
        executor.setQueueCapacity(124);

        //最大线程池数量，当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
        //任务队列已满时, 且当线程数=maxPoolSize，，线程池会拒绝处理任务而抛出异常
        executor.setMaxPoolSize(64);

        //当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
        //允许线程空闲时间30秒，当maxPoolSize的线程在空闲时间到达的时候销毁
        //如果allowCoreThreadTimeout=true，则会直到线程数量=0
        executor.setKeepAliveSeconds(30);

        //spring 提供的 ThreadPoolTaskExecutor 线程池，是有 setThreadNamePrefix() 方法的。
        //jdk 提供的ThreadPoolExecutor 线程池是没有 setThreadNamePrefix() 方法的
        executor.setThreadNamePrefix("自定义线程池-");

        // rejection-policy：当pool已经达到max size的时候，如何处理新任务
        // CallerRunsPolicy()：交由调用方线程运行，比如 main 线程；如果添加到线程池失败，那么主线程会自己去执行该任务，不会等待线程池中的线程去执行
        // AbortPolicy()：该策略是线程池的默认策略，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。
        // DiscardPolicy()：如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常
        // DiscardOldestPolicy()：丢弃队列中最老的任务，队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());

        executor.initialize();
        return executor;
    }
}
```
#### 指定自定义线程池
```java
@Async("threadPoolTaskExecutor")
```
#### 总结
先是`CorePoolSize`是否满足，然后是`Queue`阻塞队列是否满，最后才是`MaxPoolSize`是否满足
## Q: ThreadPoolTaskExecutor线程池有哪几个重要参数，什么时候会创建线程？
- 查看核心线程池是否已满，不满就创建一条线程执行任务，否则执行第二步。

- 查看阻塞队列是否已满，不满就将任务存储在阻塞队列中，否则执行第三步。

- 查看线程池是否已满，即是否达到最大线程池数，不满就创建一条线程执行任务，否则就按照策略处理无法执行的任务。

## Q: 高并发下核心线程怎么设置?
- 分IO密集还是CPU密集，一般情况按以下设置性能更好
	- CPU密集设置为跟核心数一样大小
		- IO密集型设置为2倍CPU核心数
	
- 没有固定的参数，根据实际情况压测进行调整

## 消费方⻆度，提高消费能力
- 客户端每次请求都要和服务端建立新的连接，即三次握手将会非常耗时

- 通过http连接池可以减少连接建立与释放的时间，提升http请求的性能

- Spring的restTemplate是对httpclient进行了封装, 而httpclient是支持池化机制

- 拓展
	- 对httpclient进行封装的有: Apache的Fluent、es的 restHighLevelClient、spring的restTemplate等
	
### 配置RestTemplate连接池
```java
@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(ClientHttpRequestFactory requestFactory){
        return new RestTemplate(requestFactory);
    }

    @Bean
    public ClientHttpRequestFactory httpRequestFactory(){
        return new HttpComponentsClientHttpRequestFactory(httpClient());
    }

    @Bean
    public HttpClient httpClient(){
        Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()
                .register("http", PlainConnectionSocketFactory.getSocketFactory())
                .register("https", SSLConnectionSocketFactory.getSocketFactory())
                .build();
        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(registry);

        //设置连接池最大是500个连接
        connectionManager.setMaxTotal(500);
        //MaxPerRoute是对maxTotal的细分，每个主机的并发最大是300，route是指域名
        connectionManager.setDefaultMaxPerRoute(300);
        /**
         * 只请求resonance.fun, 最大并发300
         *
         * 请求resonance.fun, 最大并发300
         * 请求open1024.com, 最大并发200
         */
        RequestConfig requestConfig = RequestConfig.custom()
                //返回数据的超时时间
                .setSocketTimeout(20000)
                //连接上服务器的超时时间
                .setConnectTimeout(10000)
                //从连接池中获取连接的超时时间
                .setConnectionRequestTimeout(1000)
                .build();
      
        CloseableHttpClient closeableHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(requestConfig)
                .setConnectionManager(connectionManager)
                .build();

        return closeableHttpClient;
    }
}
```
## 10倍+提升: Jmeter5.x压测优化后RestTemplate前后性能对比
### 同步发送+resttemplate未池化
- 压测结果：几百qps

### 异步发送+resttemplate池化
- 压测结果：2000～3000qps，但这是同一台机器，实际分开测试更高

## 池化思想应用-Redis6.X配置连接池实战
### 连接池好处
- 使用连接池不用每次都走三次握手、每次都关闭Jedis

#### 注意
- 相对于直连，使用相对麻烦，在资源管理上需要很多参数来保证，规划不合理也会出现问题

- 如果pool已经分配了maxActive个jedis实例，则此时pool的状态就成exhausted了

### 连接池配置 common项目
```xml
<!--redis客户端-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <exclusions>
        <exclusion>
            <groupId>io.lettuce</groupId>
            <artifactId>lettuce-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```
### 配置Redis连接
```yaml
    redis:
      client-type: jedis
      host: 47.108.67.134
      password: resonancefun
      port: 8000
      jedis:
        pool:
          # 连接池最大连接数（使用负值表示没有限制）
          max-active: 100
          # 连接池中的最大空闲连接
          max-idle: 100
          # 连接池中的最小空闲连接
          min-idle: 100
          # 连接池最大阻塞等待时间（使用负值表示没有限制）
          max-wait: 60000
```
### 序列化配置
```java
@Configuration
public class RedisTemplateConfiguration {

    @Bean
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object,Object> redisTemplate = new RedisTemplate<>();

        redisTemplate.setConnectionFactory(redisConnectionFactory);

        //配置序列化规则
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        //设置key-value序列化规则
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);

        //设置hash-value序列化规则
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);

        return redisTemplate;
    }
}
```
## try-with-resources
在`try(...)`里声明的资源，会在try-catch代码块结束后自动关闭掉
### 注意点
- 实现了`AutoCloseable`接口的类，在`try()`里声明该类实例的时候，try结束后自动调用的`close`方法，这个动作会早于`finally`里调用的方法

- 不管是否出现异常，`try()`里的实例都会被调用close方法

- try里面可以声明多个自动关闭的对象，越早声明的对象， 会越晚被close掉

```java
try (BufferedReader reader = new BufferedReader(new FileReader("somefile.txt"));
     BufferedWriter writer = new BufferedWriter(new FileWriter("outputfile.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        // 可能还有一些其他的处理
    }
} catch (IOException e) {
    // 处理异常
}
// 这里 reader 和 writer 都会自动关闭
```
## 注册短信验证码防刷方案
### 需求
一定时间内禁止重复发送短信
### 两个时间要求
- 60秒后才可以重新发送短信验证码

- 发送的短信验证码10分钟内有效

### 方案：Redis中code存储，基于原先的code拼接时间戳
#### 控制层
匹配上图形验证码后，先删除redis中的旧数据，再发送。
```java
@PostMapping("/send_code")
public JsonData sendCode(@RequestBody SendCodeRequest sendCodeRequest, HttpServletRequest request) {
    String key = getCaptchaKey(request);
    String cacheCaptcha = redisTemplate.opsForValue().get(key);
    String captcha = sendCodeRequest.getCaptcha();

    if (captcha != null && cacheCaptcha != null && cacheCaptcha.equalsIgnoreCase(captcha)) {
        //成功
        redisTemplate.delete(key);
        JsonData jsonData = notifyService.sendCode(SendCodeEnum.USER_REGISTER, sendCodeRequest.getTo());
        return jsonData;
    } else {
        return JsonData.buildResult(BizCodeEnum.CODE_CAPTCHA_ERROR);
    }
}
```
#### 服务层：防刷实现
```java
public JsonData sendCode(SendCodeEnum sendCodeEnum, String to) {
    String cacheKey = String.format(RedisKey.CHECK_CODE_KEY, sendCodeEnum.name(), to);
    String cacheValue = redisTemplate.opsForValue().get(cacheKey);

    if (StringUtils.isNotBlank(cacheValue)) {
        long ttl = Long.parseLong(cacheValue.split("_")[1]);
        //当前时间戳-验证码发送的时间戳，如果小于60秒，则不给重复发送
        long leftTime = CommonUtil.getCurrentTimestamp() - ttl;
        if (leftTime < (1000 * 60)) {
            log.info("重复发送短信验证码，时间间隔:{}秒", leftTime);
            return JsonData.buildResult(BizCodeEnum.CODE_LIMITED);
        }
    }

    String code = CommonUtil.getRandomCode(6);
    //生成拼接好验证码
    String value = code + "_" + CommonUtil.getCurrentTimestamp();
    redisTemplate.opsForValue().set(cacheKey, value, CODE_EXPIRED, TimeUnit.MILLISECONDS);
    if (CheckUtil.isEmail(to)) {
        //发送邮箱验证码  TODO
    } else if (CheckUtil.isPhone(to)) {
        //发送手机验证码
        smsComponent.send(to, smsConfig.getTemplateId(), code);
    }

    return JsonData.buildSuccess();
}
```
