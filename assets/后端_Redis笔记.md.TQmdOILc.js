import{_ as e,c as s,o as a,U as i}from"./chunks/framework.qwUbILKO.js";const u=JSON.parse('{"title":"学习Redis目的是解决高并发下性能问题","description":"","frontmatter":{},"headers":[],"relativePath":"后端/Redis笔记.md","filePath":"后端/Redis笔记.md"}'),t={name:"后端/Redis笔记.md"},l=i('<h1 id="学习redis目的是解决高并发下性能问题" tabindex="-1">学习Redis目的是解决高并发下性能问题 <a class="header-anchor" href="#学习redis目的是解决高并发下性能问题" aria-label="Permalink to &quot;学习Redis目的是解决高并发下性能问题&quot;">​</a></h1><p>常规我们能想到的高并发下的性能解决方案：</p><ul><li>队列：Rabbitmq、Kafka</li><li>缓存 <ol><li>分布式缓存：Redis、Memcached</li><li>本地缓存：Mybatis、Redis本地单机服务</li></ol></li></ul><details><summary>问题：分布式缓存和本地缓存怎么选择？</summary><p>结合业务数据选择，一般都是共同存在的。</p><details><summary>OK，衍生问题又来了，热点Key怎么解决？</summary><p>热点Key问题：<strong>缓存中的某些key对应的value存储在集群中的某台机器，使得所有流量集中涌向这台机器，造成系统瓶颈，并且无法通过扩容来解决。</strong></p><p>比如：热搜词、热点新闻、热卖商品</p><p>解决方案一：排除带宽或者传输影响，服务在拿到分布式缓存数据后，在本地缓存一份(可以设置过期时间)，以后每次请求，都先检查本地缓存是否存在缓存key，如果存在则直接返回，如果不存在则再去访问分布式缓存机器获取数据。</p></details></details><h1 id="redis简介" tabindex="-1">Redis简介 <a class="header-anchor" href="#redis简介" aria-label="Permalink to &quot;Redis简介&quot;">​</a></h1><ol><li>属于Nosql的一种</li></ol><details><summary>Nosql又是啥？</summary> - 是一种非关系型数据库管理系统 - 不使用SQL作为查询语言 - 不需要固定的表格模式：键值对、列存储、文档存储、图形数据库 - 产品：Redis、Memcached、Mongodb、Hbase </details><ol start="2"><li>是一个开源的由C语言编写的存储数据库，支持网络，支持基于内存、分布式、可选持久化。并且它提供了多种语言的API，比如Java、JavaScript、Python都可以使用Redis</li><li>Redis是内存中的数据结构存储系统，它可以被用作数据库、缓存、消息中间件，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等</li></ol>',8),d=[l];function r(o,n,_,c,m,p){return a(),s("div",null,d)}const R=e(t,[["render",r]]);export{u as __pageData,R as default};
